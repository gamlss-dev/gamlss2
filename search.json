[
  {
    "objectID": "vignettes/specials.html",
    "href": "vignettes/specials.html",
    "title": "Special Model Terms",
    "section": "",
    "text": "In order to add any new machine learning type algorithm in gamlss2 you need to define three special functions:\nHere we demonstrate how this can be done using the local polynomial smoothing function loess() in R, Cleveland, Grosse, and Shyu (1993).\nNote that any regression type machine learning function is R can be easily incorporated in gamlss2 especially if there is a prior weights argument in the function. loess() has the argument weights for prior weights so it can be incorporated easily.",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#the-special-model-term-constructor",
    "href": "vignettes/specials.html#the-special-model-term-constructor",
    "title": "Special Model Terms",
    "section": "1 The special model term constructor",
    "text": "1 The special model term constructor\nAny special model term constructor must be registered in the fake_formula() function. If not yet registered, the user can provide a new special name in the specials argument of fake_formula(). Another option is to use the special model term constructor name ‘“user”’, which is already part of the special names list in fake_formula().\nThe definition function can take all relevant loess and loess.control arguments so it can pass them into the fitting function.\n\nlo &lt;- function(formula, ...) \n{\n  ## ensure it's a formula\n  if(!inherits(formula, \"formula\")) {\n    formula &lt;- as.character(substitute(formula))\n    formula &lt;- as.formula(paste(\"~\", formula))\n    environment(formula) &lt;- sys.frame(-1)\n  }\n\n  ## list for setting up the special model term \n  st &lt;- list()\n\n  ## control arguments\n  st$control &lt;- list(...)\n\n  ## variables, label and data\n  st$term &lt;- all.vars(formula) \n  st$label &lt;- paste0(\"lo(\", paste0(gsub(\" \", \"\",\n    as.character(formula)), collapse = \"\"), \")\") \n  st$data &lt;- model.frame(formula)\n\n  ## New model formula used for fitting.\n  st$formula &lt;- update(formula, response_z ~ .)\n\n  ## Assign the \"special\" class and the new class \"n\".\n  class(st) &lt;- c(\"special\", \"lo\")\n\n  return(st) \n}",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#the-fitting-function",
    "href": "vignettes/specials.html#the-fitting-function",
    "title": "Special Model Terms",
    "section": "2 The fitting function",
    "text": "2 The fitting function\nThe fitting function takes the current working response, the iterative weights and the corresponding relevant term and creates a call to the loess function to fit the relevant model. It then saves the fitted values and the fitted objects for later use.\n\nspecial_fit.lo &lt;- function(x, z, w, control, ...)\n{\n  ## assign current working response and weights\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## set up loess call\n  call &lt;- \"loess(formula = x$formula, data = x$data, weights = weights_w\"\n\n  ## add optional control parameters\n  if(!is.null(x$control)) {\n    for(j in names(x$control))\n      call &lt;- paste0(call, \", \", j, \"= x$control$\", j)\n  }\n  call &lt;- paste0(call, \")\")\n\n  ## estimate model\n  rval &lt;- list(\"model\" = eval(parse(text = call)))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- fitted(rval$model) \n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift \n\n  ## degrees of freedom\n  rval$edf &lt;-  rval$model$trace.hat\n\n  ## assign class for predict method \n  class(rval) &lt;- \"lo.fitted\" \n\n  return(rval) \n}",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#the-predict-function",
    "href": "vignettes/specials.html#the-predict-function",
    "title": "Special Model Terms",
    "section": "3 The predict function",
    "text": "3 The predict function\nThe prediction function shows how the predicted values of the model can be extracted.\n\nspecial_predict.lo.fitted &lt;- function(x, data, se.fit = FALSE, ...) \n{\n  p &lt;- as.numeric(predict(x$model, newdata = data))\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#example-rent99-data",
    "href": "vignettes/specials.html#example-rent99-data",
    "title": "Special Model Terms",
    "section": "4 Example: rent99 data",
    "text": "4 Example: rent99 data\nWe use the rent99 data to demonstrate the use of the functions\n\n## load the Munich rent data\ndata(\"rent99\", package = \"gamlss.data\") \n\n## scale covariates\nrent99$area &lt;- scale(rent99$area)\nrent99$yearc &lt;- scale(rent99$yearc)\n\nNote that the continuous variables in the data area and yearc have been standardised. We defined four formulae for modelling the rent data. The first two use loess and the third and fourth uses the additive smoothing function s() for comparison. Formula f uses main effect smoothing terms for area and yearc for parameters \\(\\mu\\) and \\(\\sigma\\), respectively, while the second, f1, uses two dimensional smoothing functions for modelling one way interaction. The third formula uses one dimensional smoother for main effects and the fourth two dimensional cubic splines smoothers for interactions. Note that in this example we only use explanatory terms for the first two parameters \\(\\mu\\) and \\(\\sigma\\) and constants for the rest, \\(\\nu\\) and \\(\\tau\\).\n\nf &lt;- rent ~ lo(~area)+lo(~yearc)+location+bath+kitchen| \n            lo(~area)+lo(~yearc)+location+bath+kitchen|\n            1|1 \n\nf1 &lt;- rent ~ lo(~area*yearc)+location+bath+kitchen| \n             lo(~area*yearc)+location+bath+kitchen|\n             1|1\n\nsf &lt;- rent ~ s(~area)+s(~yearc)+location+bath+kitchen| \n             s(~area)+s(~yearc)+location+bath+kitchen|\n            1|1 \n\nsf1 &lt;- rent ~ te(area,yearc) + location + bath + kitchen | \n              te(area,yearc) + location + bath + kitchen |\n            1|1",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#estimation",
    "href": "vignettes/specials.html#estimation",
    "title": "Special Model Terms",
    "section": "5 Estimation",
    "text": "5 Estimation\nBelow we use the package tictoc to measure the time is taken to fit each model. The main effect fit for loess is;\n\nlibrary(\"tictoc\")\ntic()\nb1 &lt;- gamlss2(f, data = rent99, family = BCTo) \n\nGAMLSS-RS iteration  1: Global Deviance = 38409.6672 eps = 0.286141     \nGAMLSS-RS iteration  2: Global Deviance = 38363.6237 eps = 0.001198     \nGAMLSS-RS iteration  3: Global Deviance = 38360.7687 eps = 0.000074     \nGAMLSS-RS iteration  4: Global Deviance = 38359.9016 eps = 0.000022     \nGAMLSS-RS iteration  5: Global Deviance = 38359.6113 eps = 0.000007     \n\ntoc()\n\n4.33 sec elapsed\n\n\nThe first order interaction fit for loess is;\n\ntic()\nb2 &lt;- gamlss2(f1, data = rent99, family = BCTo) \n\nGAMLSS-RS iteration  1: Global Deviance = 38410.5652 eps = 0.286125     \nGAMLSS-RS iteration  2: Global Deviance = 38359.84 eps = 0.001320     \nGAMLSS-RS iteration  3: Global Deviance = 38356.7695 eps = 0.000080     \nGAMLSS-RS iteration  4: Global Deviance = 38355.8814 eps = 0.000023     \nGAMLSS-RS iteration  5: Global Deviance = 38355.6119 eps = 0.000007     \n\ntoc()\n\n7.515 sec elapsed\n\n\nNow the main effect model using s()\n\nlibrary(tictoc)\ntic()\na1&lt;- gamlss2(sf, data = rent99, family = BCT) \n\nGAMLSS-RS iteration  1: Global Deviance = 38462.44 eps = 0.285216     \nGAMLSS-RS iteration  2: Global Deviance = 38414.9787 eps = 0.001233     \nGAMLSS-RS iteration  3: Global Deviance = 38411.2225 eps = 0.000097     \nGAMLSS-RS iteration  4: Global Deviance = 38409.6335 eps = 0.000041     \nGAMLSS-RS iteration  5: Global Deviance = 38409.0103 eps = 0.000016     \nGAMLSS-RS iteration  6: Global Deviance = 38408.8217 eps = 0.000004     \n\ntoc()\n\n1.303 sec elapsed\n\n\nThe interaction model using te()\n\nlibrary(tictoc)\ntic()\na2&lt;- gamlss2(sf1, data = rent99, family = BCT) \n\nGAMLSS-RS iteration  1: Global Deviance = 38433.744 eps = 0.285749     \nGAMLSS-RS iteration  2: Global Deviance = 38391.1221 eps = 0.001108     \nGAMLSS-RS iteration  3: Global Deviance = 38388.3527 eps = 0.000072     \nGAMLSS-RS iteration  4: Global Deviance = 38387.4626 eps = 0.000023     \nGAMLSS-RS iteration  5: Global Deviance = 38387.1819 eps = 0.000007     \n\ntoc()\n\n1.166 sec elapsed\n\n\nThe cubic spline function is lot faster than the loess() implementation lo() in gamlss2, but let us now compare the models using AIC.\n\n## deviance\nAIC(b1, b2, a1, a2, k = 0)\n\n        AIC       df\nb2 38355.61 36.77363\nb1 38359.61 33.15714\na2 38387.18 33.61847\na1 38408.82 32.80415\n\n## BIC\nAIC(b1, b2, a1, a2, k = log(nrow(rent99)))\n\n        AIC       df\nb1 38625.97 33.15714\nb2 38651.03 36.77363\na2 38657.25 33.61847\na1 38672.35 32.80415\n\n\nIt seems that the two lo() models do better that the s() as far as the AIC criteria are concern.",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "vignettes/specials.html#visualise-the-fits",
    "href": "vignettes/specials.html#visualise-the-fits",
    "title": "Special Model Terms",
    "section": "6 Visualise the fits",
    "text": "6 Visualise the fits\nThe standard plot() function of gamlss2 can be used to visualises the smooth curves fits (under certain circumstances). For example for the main effect model using lo() we have;\n\nplot(b1)\n\n\n\n\n\n\n\n\nNote that no standard errors are shown here compare to the s() function model shown below;\n\nplot(a1)\n\n\n\n\n\n\n\n\nFor the first order interaction model b2 and because the effects are not defined within gamlss2 calling plot() produces the standard residual plots;\n\nplot(b2)\n\n\n\n\n\n\n\n\nFor the first order interaction model a2 using tensor products the plot are more informative;\n\nplot(a2)\n\n\n\n\n\n\n\n\nOne can use the function vis.lo() of the package gamlss to visualised the fitted terms fitted with lo(). Here we show the area fitted values for parameter \\(\\mu\\) and model b including the partial residuals from the model.\n\ngamlss:::vis.lo(specials(b1, model=\"mu\")[[1]]$model, partial = TRUE)\n\n\n\n\n\n\n\n\nNext we show the year of construction yearc fit for parameters \\(\\mu\\) from model b without partial residuals.\n\ngamlss:::vis.lo(specials(b1, model = \"mu\")[[2]]$model, partial = FALSE)\n\n\n\n\n\n\n\n\nHere we plot the fitted surface fit from model b2 and parameters \\(\\mu\\);\n\ngamlss:::vis.lo(specials(b2, model = \"mu\")$model, partial = FALSE)\n\n\n\n\n\n\n\n\nHere we plot the same fitted surface as above adding a 95% confidence intervals;\n\ngamlss:::vis.lo(specials(b2, model = \"mu\")$model, se = 1.97)\n\n\n\n\n\n\n\n\nFinally we plot the fitted surface fit from the \\(\\mu\\) model of b2 adding the partial residuals.\n\ngamlss:::vis.lo(specials(b2, model = \"mu\")$model, partial = TRUE)\n\n\n\n\n\n\n\n\nNote that similar plots are given in section 9.6.3 of Stasinopoulos et al. (2017), where the lo() function within package gamlss, is described.",
    "crumbs": [
      "Articles",
      "Special Model Terms"
    ]
  },
  {
    "objectID": "man/special_terms.html",
    "href": "man/special_terms.html",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## predict parameters of the GA distribution\npar &lt;- predict(b, newdata = nd)\n\n## compute median rent R estimate\nnd$fit &lt;- family(b)$q(0.5, par)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Reference",
      "special_terms"
    ]
  },
  {
    "objectID": "man/special_terms.html#special-model-terms-for-gamlss",
    "href": "man/special_terms.html#special-model-terms-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## predict parameters of the GA distribution\npar &lt;- predict(b, newdata = nd)\n\n## compute median rent R estimate\nnd$fit &lt;- family(b)$q(0.5, par)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Reference",
      "special_terms"
    ]
  },
  {
    "objectID": "man/new_formula.html",
    "href": "man/new_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Reference",
      "new_formula"
    ]
  },
  {
    "objectID": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "href": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Reference",
      "new_formula"
    ]
  },
  {
    "objectID": "man/stepwise.html",
    "href": "man/stepwise.html",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Reference",
      "stepwise"
    ]
  },
  {
    "objectID": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "href": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Reference",
      "stepwise"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html",
    "href": "man/prodist.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1777 eps = 0.002913     \nGAMLSS-RS iteration  3: Global Deviance = 405.8035 eps = 0.000921     \nGAMLSS-RS iteration  4: Global Deviance = 405.7928 eps = 0.000026     \nGAMLSS-RS iteration  5: Global Deviance = 405.7928 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                     1                                      2 \n\"GAMLSS NO(mu = 23.13, sigma = 10.05)\" \"GAMLSS NO(mu = 58.79, sigma = 18.57)\" \n                                     3 \n\"GAMLSS NO(mu = 95.49, sigma = 34.32)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.600763 23.12533  39.64990\n2 28.245303 58.79229  89.33928\n3 39.041768 95.49447 151.94716\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.600763  58.792294 151.947164 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\nvariance(d)\n\n        1         2         3 \n 100.9266  344.8914 1177.9175 \n\n## simulate random numbers\nrandom(d, 5)\n\n        r_1       r_2       r_3      r_4       r_5\n1   9.87218  40.45075  15.06109 37.13889  25.54674\n2  76.18076  63.88086  53.52327 24.81920  35.80294\n3 104.72565 143.42552 100.87338 69.46350 100.60912\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 9.593018e-35 1.241567e-13 0.0028074163 0.001109086 7.655011e-15\n2 2.860520e-18 7.588365e-10 0.0001431525 0.019204244 1.832074e-03\n3 1.046908e-09 1.455282e-06 0.0002422388 0.004828343 1.152419e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 7.812120e-35 1.682930e-13 0.0106706090 0.99626467 1.0000000\n2 6.131240e-18 2.340931e-09 0.0007733678 0.31795118 0.9867532\n3 6.129224e-09 1.121339e-05 0.0026978609 0.09249186 0.5522219\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                      1 \n\"GAMLSS PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Reference",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "href": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1777 eps = 0.002913     \nGAMLSS-RS iteration  3: Global Deviance = 405.8035 eps = 0.000921     \nGAMLSS-RS iteration  4: Global Deviance = 405.7928 eps = 0.000026     \nGAMLSS-RS iteration  5: Global Deviance = 405.7928 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                     1                                      2 \n\"GAMLSS NO(mu = 23.13, sigma = 10.05)\" \"GAMLSS NO(mu = 58.79, sigma = 18.57)\" \n                                     3 \n\"GAMLSS NO(mu = 95.49, sigma = 34.32)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.600763 23.12533  39.64990\n2 28.245303 58.79229  89.33928\n3 39.041768 95.49447 151.94716\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.600763  58.792294 151.947164 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\nvariance(d)\n\n        1         2         3 \n 100.9266  344.8914 1177.9175 \n\n## simulate random numbers\nrandom(d, 5)\n\n        r_1       r_2       r_3      r_4       r_5\n1   9.87218  40.45075  15.06109 37.13889  25.54674\n2  76.18076  63.88086  53.52327 24.81920  35.80294\n3 104.72565 143.42552 100.87338 69.46350 100.60912\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 9.593018e-35 1.241567e-13 0.0028074163 0.001109086 7.655011e-15\n2 2.860520e-18 7.588365e-10 0.0001431525 0.019204244 1.832074e-03\n3 1.046908e-09 1.455282e-06 0.0002422388 0.004828343 1.152419e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 7.812120e-35 1.682930e-13 0.0106706090 0.99626467 1.0000000\n2 6.131240e-18 2.340931e-09 0.0007733678 0.31795118 0.9867532\n3 6.129224e-09 1.121339e-05 0.0026978609 0.09249186 0.5522219\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                      1 \n\"GAMLSS PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Reference",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html",
    "href": "man/select_gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Reference",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "href": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Reference",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html",
    "href": "man/Kumaraswamy.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "href": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/quantiles.html",
    "href": "man/quantiles.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Reference",
      "quantiles"
    ]
  },
  {
    "objectID": "man/quantiles.html#quantiles-for-gamlss",
    "href": "man/quantiles.html#quantiles-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Reference",
      "quantiles"
    ]
  },
  {
    "objectID": "man/misc.html",
    "href": "man/misc.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Reference",
      "misc"
    ]
  },
  {
    "objectID": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "href": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Reference",
      "misc"
    ]
  },
  {
    "objectID": "man/ologit.html",
    "href": "man/ologit.html",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nologit(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe ologit() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = ologit(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = ologit(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink function: location = identity, theta1 = identity, delta2 = identity\n*--------\nParameter: location \n---\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nInflMedium       0.5671     0.5367   1.057   0.2947  \nInflHigh         1.2904     0.5572   2.316   0.0238 *\nTypeApartment   -0.5731     0.6345  -0.903   0.3698  \nTypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nTypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nContHigh         0.3607     0.4462   0.808   0.4219  \n*--------\nParameter: theta1 \n---\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   -0.6932  3481.4687       0        1\n*--------\nParameter: delta2 \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.1724     0.2191   0.787    0.434\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = 2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533",
    "crumbs": [
      "Reference",
      "ologit"
    ]
  },
  {
    "objectID": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "href": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nologit(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe ologit() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = ologit(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = ologit(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink function: location = identity, theta1 = identity, delta2 = identity\n*--------\nParameter: location \n---\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)  \n(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nInflMedium       0.5671     0.5367   1.057   0.2947  \nInflHigh         1.2904     0.5572   2.316   0.0238 *\nTypeApartment   -0.5731     0.6345  -0.903   0.3698  \nTypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nTypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nContHigh         0.3607     0.4462   0.808   0.4219  \n*--------\nParameter: theta1 \n---\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   -0.6932  3481.4687       0        1\n*--------\nParameter: delta2 \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.1724     0.2191   0.787    0.434\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = 2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533",
    "crumbs": [
      "Reference",
      "ologit"
    ]
  },
  {
    "objectID": "man/softplus.html",
    "href": "man/softplus.html",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Reference",
      "softplus"
    ]
  },
  {
    "objectID": "man/softplus.html#softplus-link-object",
    "href": "man/softplus.html#softplus-link-object",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Reference",
      "softplus"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html",
    "href": "man/gamlss2.family.html",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nThe following lists the minimum requirements on a gamlss2 family object to be used with gamlss2:\n\n\nThe family object is expected to return a list of class “gamlss2.family”.\n\n\nThe object must contain the family name as a character string.\n\n\nThe object must contain the names of the parameters as a character string, as well as the corresponding link functions as character string.\n\n\nThe family object must contain a $d() function to evaluate the (log-)density.\n\n\nFurthermore, it is assumed that the density function in a family object has the following arguments:\nd(y, par, log = FALSE, …)\nwhere argument y is the response (possibly a matrix) and par is a named list holding the evaluated parameters of the distribution, e.g., using a normal distribution par has two elements, one for the mean par$mu and one for the standard deviation par$sigma. The dots argument is for passing special internally used objects, depending on the type of model this feature is usually not needed.\nOptionally, the family object holds derivative functions evaluating derivatives of the log-likelihood w.r.t. the predictors (or expectations of derivatives). For each parameter, these functions must have the following arguments:\nfunction(y, par, …)\nfor computing the first derivative of the log-likelihood w.r.t. a predictor and\nfunction(y, par, …)\nfor computing the negative second derivatives. Within the family object these functions are organized in a named list, see the examples below. If these functions are not specified, all derivatives will be approximated numerically. Note that also cross derivatives can be implemented, e.g., when using the CG algorithm for fitting a GAMLSS.\nIn addition, for the cumulative distribution function (p(y, par, …)), for the quantile function (q(y, par, …)) or for creating random numbers (r(n, par, …)) the same structure is assumed.\nUsing function gamlss2 the family objects may also specify the optimizer()er function that should be used with this family.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"d\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"p\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"r\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"q\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $p() and $q() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"p\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"q\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $p() and $q() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "href": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nThe following lists the minimum requirements on a gamlss2 family object to be used with gamlss2:\n\n\nThe family object is expected to return a list of class “gamlss2.family”.\n\n\nThe object must contain the family name as a character string.\n\n\nThe object must contain the names of the parameters as a character string, as well as the corresponding link functions as character string.\n\n\nThe family object must contain a $d() function to evaluate the (log-)density.\n\n\nFurthermore, it is assumed that the density function in a family object has the following arguments:\nd(y, par, log = FALSE, …)\nwhere argument y is the response (possibly a matrix) and par is a named list holding the evaluated parameters of the distribution, e.g., using a normal distribution par has two elements, one for the mean par$mu and one for the standard deviation par$sigma. The dots argument is for passing special internally used objects, depending on the type of model this feature is usually not needed.\nOptionally, the family object holds derivative functions evaluating derivatives of the log-likelihood w.r.t. the predictors (or expectations of derivatives). For each parameter, these functions must have the following arguments:\nfunction(y, par, …)\nfor computing the first derivative of the log-likelihood w.r.t. a predictor and\nfunction(y, par, …)\nfor computing the negative second derivatives. Within the family object these functions are organized in a named list, see the examples below. If these functions are not specified, all derivatives will be approximated numerically. Note that also cross derivatives can be implemented, e.g., when using the CG algorithm for fitting a GAMLSS.\nIn addition, for the cumulative distribution function (p(y, par, …)), for the quantile function (q(y, par, …)) or for creating random numbers (r(n, par, …)) the same structure is assumed.\nUsing function gamlss2 the family objects may also specify the optimizer()er function that should be used with this family.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"d\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"p\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"r\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"q\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $p() and $q() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"p\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"q\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $p() and $q() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/pb.html",
    "href": "man/pb.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26377.8229 eps = 0.390162     \nGAMLSS-RS iteration  2: Global Deviance = 26205.3586 eps = 0.006538     \nGAMLSS-RS iteration  3: Global Deviance = 26202.541 eps = 0.000107     \nGAMLSS-RS iteration  4: Global Deviance = 26202.1755 eps = 0.000013     \nGAMLSS-RS iteration  5: Global Deviance = 26202.0501 eps = 0.000004     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "pb"
    ]
  },
  {
    "objectID": "man/pb.html#p-splines-for-gamlss",
    "href": "man/pb.html#p-splines-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26377.8229 eps = 0.390162     \nGAMLSS-RS iteration  2: Global Deviance = 26205.3586 eps = 0.006538     \nGAMLSS-RS iteration  3: Global Deviance = 26202.541 eps = 0.000107     \nGAMLSS-RS iteration  4: Global Deviance = 26202.1755 eps = 0.000013     \nGAMLSS-RS iteration  5: Global Deviance = 26202.0501 eps = 0.000004     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "pb"
    ]
  },
  {
    "objectID": "man/make.link2.html",
    "href": "man/make.link2.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr \"link-glm\"",
    "crumbs": [
      "Reference",
      "make.link2"
    ]
  },
  {
    "objectID": "man/make.link2.html#create-a-link-for-families",
    "href": "man/make.link2.html#create-a-link-for-families",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr \"link-glm\"",
    "crumbs": [
      "Reference",
      "make.link2"
    ]
  },
  {
    "objectID": "man/find_family.html",
    "href": "man/find_family.html",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\n…\n\n\nFurther arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family().\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)",
    "crumbs": [
      "Reference",
      "find_family"
    ]
  },
  {
    "objectID": "man/find_family.html#find-and-fit-gamlss-families",
    "href": "man/find_family.html#find-and-fit-gamlss-families",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\n…\n\n\nFurther arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family().\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)",
    "crumbs": [
      "Reference",
      "find_family"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")\n\n\n\n\nThe development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))\n\n\n\n\nThe package is available under the General Public License version 3 or version 2\n\n\n\nThe package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nTo illustrate the workflow using gamlss2, we analyze the WeatherGermany data,\n\nif(!(\"WeatherGermany\" %in% installed.packages())) {\n  install.packages('WeatherGermany',\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\n\nInstalling package into '/usr/local/lib/R/site-library'\n(as 'lib' is unspecified)\n\ndata(\"WeatherGermany\", package = \"WeatherGermany\")\nhead(WeatherGermany)\n\n  id       date Wmax pre Tmax Tmin sun name alt     lat    lon\n1  1 1981-01-01   NA 1.7  3.4 -5.0  NA Aach 478 47.8413 8.8493\n2  1 1981-01-02   NA 1.7  1.2 -0.4  NA Aach 478 47.8413 8.8493\n3  1 1981-01-03   NA 5.4  5.4  1.0  NA Aach 478 47.8413 8.8493\n4  1 1981-01-04   NA 8.8  5.6 -0.4  NA Aach 478 47.8413 8.8493\n5  1 1981-01-05   NA 3.7  1.2 -2.4  NA Aach 478 47.8413 8.8493\n6  1 1981-01-06   NA 4.0  1.2 -2.2  NA Aach 478 47.8413 8.8493\n\n\nThe dataset contains daily observations from weather stations across Germany. It includes the station identifier (id), the recording date, the maximum wind speed (Wmax, in m/s), the precipitation amount (pre, in mm), the maximum and minimum temperatures (Tmax and Tmin, in °C), and the number of sunshine hours (sun). Additionally, it provides the station’s name, altitude (in meters above sea level), and its geographic coordinates (longitude and latitude).\nIn this example, we use daily maximum temperature (Tmax) data to estimate a climatology model based on over 37 years of observations from Germany’s highest meteorological station, located at Zugspitze. Situated at an altitude of 2956 meters above sea level, this station provides a unique dataset for high-altitude climate analysis.\nFirst, we subset the dataset to include only observations from the Zugspitze station.\n\nd &lt;- subset(WeatherGermany, name == \"Zugspitze\")\n\nBefore estimating a climatology model using gamlss2, it is good practice to inspect the distribution of the response variable\n\nhist(d$Tmax, freq = FALSE, breaks = \"Scott\")\n\n\n\n\n\n\n\n\nThe histogram suggests that the data is slightly left-skewed, with longer tails for temperatures below zero. This indicates that the commonly used normal distribution may not be the most appropriate choice for modeling daily maximum temperatures.\nTo address this, the gamlss2 package provides the find_family() function, which helps identify the most suitable distribution by minimizing an information criterion, AIC by default. Here, we evaluate several continuous distributions available in the gamlss.dist package.\n\nfams &lt;- find_family(d$Tmax,\n  families = c(NO, TF, JSU, SEP4))\n\n.. NO family\n.. .. IC = 92044.1 \n.. TF family\n.. .. IC = 92046.12 \n.. JSU family\n.. .. IC = 91975.24 \n.. SEP4 family\n.. .. IC = 91879.66 \n\nprint(fams)\n\n      TF       NO      JSU     SEP4 \n92046.12 92044.10 91975.24 91879.66 \n\n\nHere, the SEP4 family appears to provide the best fit. To further assess its suitability, we can visualize the fitted density using\n\nfit_family(d$Tmax, family = SEP4)\n\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\n\n\nGAMLSS-RS iteration  1: Global Deviance = 91950.4801 eps = 0.044494     \nGAMLSS-RS iteration  2: Global Deviance = 91907.9542 eps = 0.000462     \nGAMLSS-RS iteration  3: Global Deviance = 91889.9353 eps = 0.000196     \nGAMLSS-RS iteration  4: Global Deviance = 91880.9925 eps = 0.000097     \nGAMLSS-RS iteration  5: Global Deviance = 91876.7482 eps = 0.000046     \nGAMLSS-RS iteration  6: Global Deviance = 91874.399 eps = 0.000025     \nGAMLSS-RS iteration  7: Global Deviance = 91872.4447 eps = 0.000021     \nGAMLSS-RS iteration  8: Global Deviance = 91871.6641 eps = 0.000008     \n\n\n\n\n\n\n\n\n\nAfter identifying a suitable distributional model, we can now incorporate covariates to estimate a full GAMLSS. Since temperature data exhibits a strong seasonal pattern, as illustrated in the following scatterplot\n\nd$yday &lt;- as.POSIXlt(d$date)$yday\nplot(Tmax ~ yday, data = d, col = rgb(0.1, 0.1, 0.1, alpha = 0.4))\n\n\n\n\n\n\n\n\nIt is essential to include a model term that captures these seasonal effects. The gamlss2 package supports all model terms from the mgcv package, allowing us to use the s() constructor to model seasonality.\nAdditionally, we include a time trend to examine whether maximum temperatures have increased over the observed period. In the full GAMLSS model, each parameter of the selected SEP4 distribution is estimated separately. To incorporate the time trend, we first create a new covariate, year, representing the long-term temporal effect\n\nd$year &lt;- as.POSIXlt(d$date)$year + 1900\n\nNext, we define the model formula for the four parameters of the SEP4 distribution.\n\nf &lt;- Tmax ~ s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\"))\n\nIn this formula, the vertical bars | separate the specifications for each parameter of the SEP4 distribution. The argument bs = \"cc\" specifies a cyclical spline to account for the seasonal effect, ensuring continuity at the beginning and end of the year, and argument k controls the dimension of the basis used to represent the smooth term.\nFinally, we estimate the model using\n\nb &lt;- gamlss2(f, data = d, family = SEP4)\n\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\n\n\nGAMLSS-RS iteration  1: Global Deviance = 79918.3054 eps = 0.169526     \nGAMLSS-RS iteration  2: Global Deviance = 79804.3251 eps = 0.001426     \nGAMLSS-RS iteration  3: Global Deviance = 79759.9851 eps = 0.000555     \nGAMLSS-RS iteration  4: Global Deviance = 79745.0554 eps = 0.000187     \nGAMLSS-RS iteration  5: Global Deviance = 79738.3587 eps = 0.000083     \nGAMLSS-RS iteration  6: Global Deviance = 79736.4781 eps = 0.000023     \nGAMLSS-RS iteration  7: Global Deviance = 79735.2054 eps = 0.000015     \nGAMLSS-RS iteration  8: Global Deviance = 79734.6366 eps = 0.000007     \n\n\nThis approach allows us to flexibly capture both seasonal patterns and long-term trends in daily maximum temperatures.\nAfter estimating the model, we can examine the model summary using\n\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = d, family = SEP4)\n---\nFamily: SEP4 \nLink function: mu = identity, sigma = log, nu = log, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  -0.9380     0.1507  -6.224    5e-10 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 16.3620  7.6634        17.997\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  1.88151    0.00144    1307   &lt;2e-16 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 15.9695  4.6506        5.9388\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  0.63884    0.02157   29.62   &lt;2e-16 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 12.2077  6.0049        2.0948\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 1.027653   0.009979     103   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf  11.060   1.013        1.4077\n*--------\nn = 13665 df =  106.37 res.df =  13558.63\nDeviance = 79734.6366 Null Dev. Red. = 13.21%\nAIC = 79947.3743 elapsed = 28.28sec\n\n\nThe summary output is structured similarly to those of lm() and glm(), with the key difference being that it provides results for all parameters of the selected distribution. Specifically, it displays the estimated linear coefficients (in this case, primarily the intercepts), along with the effective degrees of freedom for each smooth term. Additionally, the AIC and deviance values are reported.\nTo extract the AIC separately, we use\n\nAIC(b)\n\n[1] 79947.37\n\n\nSimilarly, the log-likelihood can be obtained with\n\nlogLik(b)\n\n'log Lik.' -39867.32 (df=106.3689)\n\nlogLik(b, newdata = d)\n\n'log Lik.' -39867.32 (df=106.3689)\n\n\nHere we use the newdata argument just to show, that the log-likelihood can also be evaluated on, e.g., out-of-sample data.\nAdditionally, the estimated effects can be visualized instantly using\n\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n\nThis plot provides a direct visualization of the smooth effects included in the model, helping to interpret seasonal variations and long-term trends efficiently.\nTo assess the calibration of the estimated model, we examine the quantile residuals using a histogram, Q-Q plot, and worm plot.\n\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n\nThese diagnostic plots indicate that the model is well-calibrated when using the SEP4 distribution, demonstrating a good fit to the observed data.\nModel predictions can be obtained for various statistical quantities, including the mean, quantiles, probability density function (PDF), and cumulative distribution function (CDF). To illustrate this, we first examine the marginal effect of the long-term time trend. For this purpose, we create a new data frame containing only the years of interest.\n\nnd &lt;- data.frame(\"year\" = 1981:2018, \"yday\" = 182)\n\nNext, we predict quantiles by first computing the estimated parameters\n\npar &lt;- predict(b, newdata = nd)\n\nTo compute, e.g., the 50% quantile (median), we extract the gamlss2.family of the fitted model and call the corresponding $q() (quantile) function provided by the family.\n\nq50 &lt;- family(b)$q(0.5, par)\n\nSimilarly, we can compute the 10% and 90% quantiles\n\nq10 &lt;- family(b)$q(0.1, par)\nq90 &lt;- family(b)$q(0.9, par)\n\nFinally, we visualize the long-term trend in temperature.\n\nmatplot(nd$year, cbind(q10, q50, q90), type = \"l\",\n  lwd = 2, xlab = \"Year\", ylab = \"Estimated Quantiles\")\nlegend(\"topleft\", c(\"10%\", \"Median\", \"90%\"),\n  col = 1:3, lty = 1:3, bg = \"white\")\n\n\n\n\n\n\n\n\nThe plot reveals an upward trend in the median temperature over time, highlighting the effects of long-term climate change.\nTo visualize exceedance probabilities for the 2019 season, we use the $p() function of the family object. For example, we can compute the probabilities of maximum temperatures exceeding 10, 11, 12, 13, and 14 °C as follows\n\nnd &lt;- data.frame(\"year\" = 2019, \"yday\" = 0:365)\npar &lt;- predict(b, newdata = nd)\nTmax &lt;- rev(seq(0, 14, by = 2))\nprobs &lt;- sapply(Tmax, function(t) 1 - family(b)$p(t, par))\ncolnames(probs) &lt;- paste0(\"Prob(Tmax &gt; \", Tmax, \")\")\nhead(probs)\n\n     Prob(Tmax &gt; 14) Prob(Tmax &gt; 12) Prob(Tmax &gt; 10) Prob(Tmax &gt; 8)\n[1,]    1.590061e-12    5.501117e-10    7.673712e-08   4.605888e-06\n[2,]    1.635692e-12    5.493598e-10    7.520458e-08   4.469749e-06\n[3,]    1.630585e-12    5.369963e-10    7.269465e-08   4.302274e-06\n[4,]    1.585621e-12    5.161699e-10    6.952153e-08   4.115322e-06\n[5,]    1.514233e-12    4.901235e-10    6.598375e-08   3.919732e-06\n[6,]    1.428635e-12    4.618508e-10    6.234650e-08   3.725021e-06\n     Prob(Tmax &gt; 6) Prob(Tmax &gt; 4) Prob(Tmax &gt; 2) Prob(Tmax &gt; 0)\n[1,]   0.0001275031    0.001753963     0.01299744     0.05663021\n[2,]   0.0001233908    0.001701366     0.01267788     0.05562356\n[3,]   0.0001188968    0.001647312     0.01236082     0.05464662\n[4,]   0.0001142025    0.001592977     0.01204944     0.05370176\n[5,]   0.0001094721    0.001539443     0.01174679     0.05279154\n[6,]   0.0001048512    0.001487695     0.01145582     0.05191868\n\n\nTo illustrate these exceedance probabilities, we plot them over the course of the year\n\ncol &lt;- colorspace::heat_hcl(ncol(probs))\nmatplot(0:365, probs, type = \"l\", lty = 1, lwd = 2, col = col,\n  xlab = \"Day of the Year\", ylab = \"Estimated Probabilities\")\nabline(h = 0.05, lty = 2, col = \"lightgray\")\nlegend(\"topleft\", colnames(probs),\n  lwd = 2, lty = 1, col = col, bty = \"n\")\n\n\n\n\n\n\n\n\nThe plot reveals that even at this high-altitude station, the probability of Tmax &gt; 14°C reaches approximately 5% during summer. This is particularly striking considering that the Zugspitze once had a permanent glacier field, emphasizing the impact of rising temperatures in this region. Likewise, the probability of Tmax &gt; 0°C during the winter months is also about 5%, highlighting significant temperature patterns."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The package is available under the General Public License version 3 or version 2"
  },
  {
    "objectID": "index.html#illustration",
    "href": "index.html#illustration",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nTo illustrate the workflow using gamlss2, we analyze the WeatherGermany data,\n\nif(!(\"WeatherGermany\" %in% installed.packages())) {\n  install.packages('WeatherGermany',\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\n\nInstalling package into '/usr/local/lib/R/site-library'\n(as 'lib' is unspecified)\n\ndata(\"WeatherGermany\", package = \"WeatherGermany\")\nhead(WeatherGermany)\n\n  id       date Wmax pre Tmax Tmin sun name alt     lat    lon\n1  1 1981-01-01   NA 1.7  3.4 -5.0  NA Aach 478 47.8413 8.8493\n2  1 1981-01-02   NA 1.7  1.2 -0.4  NA Aach 478 47.8413 8.8493\n3  1 1981-01-03   NA 5.4  5.4  1.0  NA Aach 478 47.8413 8.8493\n4  1 1981-01-04   NA 8.8  5.6 -0.4  NA Aach 478 47.8413 8.8493\n5  1 1981-01-05   NA 3.7  1.2 -2.4  NA Aach 478 47.8413 8.8493\n6  1 1981-01-06   NA 4.0  1.2 -2.2  NA Aach 478 47.8413 8.8493\n\n\nThe dataset contains daily observations from weather stations across Germany. It includes the station identifier (id), the recording date, the maximum wind speed (Wmax, in m/s), the precipitation amount (pre, in mm), the maximum and minimum temperatures (Tmax and Tmin, in °C), and the number of sunshine hours (sun). Additionally, it provides the station’s name, altitude (in meters above sea level), and its geographic coordinates (longitude and latitude).\nIn this example, we use daily maximum temperature (Tmax) data to estimate a climatology model based on over 37 years of observations from Germany’s highest meteorological station, located at Zugspitze. Situated at an altitude of 2956 meters above sea level, this station provides a unique dataset for high-altitude climate analysis.\nFirst, we subset the dataset to include only observations from the Zugspitze station.\n\nd &lt;- subset(WeatherGermany, name == \"Zugspitze\")\n\nBefore estimating a climatology model using gamlss2, it is good practice to inspect the distribution of the response variable\n\nhist(d$Tmax, freq = FALSE, breaks = \"Scott\")\n\n\n\n\n\n\n\n\nThe histogram suggests that the data is slightly left-skewed, with longer tails for temperatures below zero. This indicates that the commonly used normal distribution may not be the most appropriate choice for modeling daily maximum temperatures.\nTo address this, the gamlss2 package provides the find_family() function, which helps identify the most suitable distribution by minimizing an information criterion, AIC by default. Here, we evaluate several continuous distributions available in the gamlss.dist package.\n\nfams &lt;- find_family(d$Tmax,\n  families = c(NO, TF, JSU, SEP4))\n\n.. NO family\n.. .. IC = 92044.1 \n.. TF family\n.. .. IC = 92046.12 \n.. JSU family\n.. .. IC = 91975.24 \n.. SEP4 family\n.. .. IC = 91879.66 \n\nprint(fams)\n\n      TF       NO      JSU     SEP4 \n92046.12 92044.10 91975.24 91879.66 \n\n\nHere, the SEP4 family appears to provide the best fit. To further assess its suitability, we can visualize the fitted density using\n\nfit_family(d$Tmax, family = SEP4)\n\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\n\n\nGAMLSS-RS iteration  1: Global Deviance = 91950.4801 eps = 0.044494     \nGAMLSS-RS iteration  2: Global Deviance = 91907.9542 eps = 0.000462     \nGAMLSS-RS iteration  3: Global Deviance = 91889.9353 eps = 0.000196     \nGAMLSS-RS iteration  4: Global Deviance = 91880.9925 eps = 0.000097     \nGAMLSS-RS iteration  5: Global Deviance = 91876.7482 eps = 0.000046     \nGAMLSS-RS iteration  6: Global Deviance = 91874.399 eps = 0.000025     \nGAMLSS-RS iteration  7: Global Deviance = 91872.4447 eps = 0.000021     \nGAMLSS-RS iteration  8: Global Deviance = 91871.6641 eps = 0.000008     \n\n\n\n\n\n\n\n\n\nAfter identifying a suitable distributional model, we can now incorporate covariates to estimate a full GAMLSS. Since temperature data exhibits a strong seasonal pattern, as illustrated in the following scatterplot\n\nd$yday &lt;- as.POSIXlt(d$date)$yday\nplot(Tmax ~ yday, data = d, col = rgb(0.1, 0.1, 0.1, alpha = 0.4))\n\n\n\n\n\n\n\n\nIt is essential to include a model term that captures these seasonal effects. The gamlss2 package supports all model terms from the mgcv package, allowing us to use the s() constructor to model seasonality.\nAdditionally, we include a time trend to examine whether maximum temperatures have increased over the observed period. In the full GAMLSS model, each parameter of the selected SEP4 distribution is estimated separately. To incorporate the time trend, we first create a new covariate, year, representing the long-term temporal effect\n\nd$year &lt;- as.POSIXlt(d$date)$year + 1900\n\nNext, we define the model formula for the four parameters of the SEP4 distribution.\n\nf &lt;- Tmax ~ s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\")) |\n  s(yday, bs = \"cc\", k = 20) + s(year) + te(yday, year, bs = c(\"cc\", \"cr\"))\n\nIn this formula, the vertical bars | separate the specifications for each parameter of the SEP4 distribution. The argument bs = \"cc\" specifies a cyclical spline to account for the seasonal effect, ensuring continuity at the beginning and end of the year, and argument k controls the dimension of the basis used to represent the smooth term.\nFinally, we estimate the model using\n\nb &lt;- gamlss2(f, data = d, family = SEP4)\n\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\nWarning in family$loglik(y, family$map2par(eta)): non finite log-density\nvalues, set to -100!\n\n\nGAMLSS-RS iteration  1: Global Deviance = 79918.3054 eps = 0.169526     \nGAMLSS-RS iteration  2: Global Deviance = 79804.3251 eps = 0.001426     \nGAMLSS-RS iteration  3: Global Deviance = 79759.9851 eps = 0.000555     \nGAMLSS-RS iteration  4: Global Deviance = 79745.0554 eps = 0.000187     \nGAMLSS-RS iteration  5: Global Deviance = 79738.3587 eps = 0.000083     \nGAMLSS-RS iteration  6: Global Deviance = 79736.4781 eps = 0.000023     \nGAMLSS-RS iteration  7: Global Deviance = 79735.2054 eps = 0.000015     \nGAMLSS-RS iteration  8: Global Deviance = 79734.6366 eps = 0.000007     \n\n\nThis approach allows us to flexibly capture both seasonal patterns and long-term trends in daily maximum temperatures.\nAfter estimating the model, we can examine the model summary using\n\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = d, family = SEP4)\n---\nFamily: SEP4 \nLink function: mu = identity, sigma = log, nu = log, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  -0.9380     0.1507  -6.224    5e-10 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 16.3620  7.6634        17.997\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  1.88151    0.00144    1307   &lt;2e-16 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 15.9695  4.6506        5.9388\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  0.63884    0.02157   29.62   &lt;2e-16 ***\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf 12.2077  6.0049        2.0948\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 1.027653   0.009979     103   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    s(yday) s(year) te(yday,year)\nedf  11.060   1.013        1.4077\n*--------\nn = 13665 df =  106.37 res.df =  13558.63\nDeviance = 79734.6366 Null Dev. Red. = 13.21%\nAIC = 79947.3743 elapsed = 28.28sec\n\n\nThe summary output is structured similarly to those of lm() and glm(), with the key difference being that it provides results for all parameters of the selected distribution. Specifically, it displays the estimated linear coefficients (in this case, primarily the intercepts), along with the effective degrees of freedom for each smooth term. Additionally, the AIC and deviance values are reported.\nTo extract the AIC separately, we use\n\nAIC(b)\n\n[1] 79947.37\n\n\nSimilarly, the log-likelihood can be obtained with\n\nlogLik(b)\n\n'log Lik.' -39867.32 (df=106.3689)\n\nlogLik(b, newdata = d)\n\n'log Lik.' -39867.32 (df=106.3689)\n\n\nHere we use the newdata argument just to show, that the log-likelihood can also be evaluated on, e.g., out-of-sample data.\nAdditionally, the estimated effects can be visualized instantly using\n\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n\nThis plot provides a direct visualization of the smooth effects included in the model, helping to interpret seasonal variations and long-term trends efficiently.\nTo assess the calibration of the estimated model, we examine the quantile residuals using a histogram, Q-Q plot, and worm plot.\n\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n\nThese diagnostic plots indicate that the model is well-calibrated when using the SEP4 distribution, demonstrating a good fit to the observed data.\nModel predictions can be obtained for various statistical quantities, including the mean, quantiles, probability density function (PDF), and cumulative distribution function (CDF). To illustrate this, we first examine the marginal effect of the long-term time trend. For this purpose, we create a new data frame containing only the years of interest.\n\nnd &lt;- data.frame(\"year\" = 1981:2018, \"yday\" = 182)\n\nNext, we predict quantiles by first computing the estimated parameters\n\npar &lt;- predict(b, newdata = nd)\n\nTo compute, e.g., the 50% quantile (median), we extract the gamlss2.family of the fitted model and call the corresponding $q() (quantile) function provided by the family.\n\nq50 &lt;- family(b)$q(0.5, par)\n\nSimilarly, we can compute the 10% and 90% quantiles\n\nq10 &lt;- family(b)$q(0.1, par)\nq90 &lt;- family(b)$q(0.9, par)\n\nFinally, we visualize the long-term trend in temperature.\n\nmatplot(nd$year, cbind(q10, q50, q90), type = \"l\",\n  lwd = 2, xlab = \"Year\", ylab = \"Estimated Quantiles\")\nlegend(\"topleft\", c(\"10%\", \"Median\", \"90%\"),\n  col = 1:3, lty = 1:3, bg = \"white\")\n\n\n\n\n\n\n\n\nThe plot reveals an upward trend in the median temperature over time, highlighting the effects of long-term climate change.\nTo visualize exceedance probabilities for the 2019 season, we use the $p() function of the family object. For example, we can compute the probabilities of maximum temperatures exceeding 10, 11, 12, 13, and 14 °C as follows\n\nnd &lt;- data.frame(\"year\" = 2019, \"yday\" = 0:365)\npar &lt;- predict(b, newdata = nd)\nTmax &lt;- rev(seq(0, 14, by = 2))\nprobs &lt;- sapply(Tmax, function(t) 1 - family(b)$p(t, par))\ncolnames(probs) &lt;- paste0(\"Prob(Tmax &gt; \", Tmax, \")\")\nhead(probs)\n\n     Prob(Tmax &gt; 14) Prob(Tmax &gt; 12) Prob(Tmax &gt; 10) Prob(Tmax &gt; 8)\n[1,]    1.590061e-12    5.501117e-10    7.673712e-08   4.605888e-06\n[2,]    1.635692e-12    5.493598e-10    7.520458e-08   4.469749e-06\n[3,]    1.630585e-12    5.369963e-10    7.269465e-08   4.302274e-06\n[4,]    1.585621e-12    5.161699e-10    6.952153e-08   4.115322e-06\n[5,]    1.514233e-12    4.901235e-10    6.598375e-08   3.919732e-06\n[6,]    1.428635e-12    4.618508e-10    6.234650e-08   3.725021e-06\n     Prob(Tmax &gt; 6) Prob(Tmax &gt; 4) Prob(Tmax &gt; 2) Prob(Tmax &gt; 0)\n[1,]   0.0001275031    0.001753963     0.01299744     0.05663021\n[2,]   0.0001233908    0.001701366     0.01267788     0.05562356\n[3,]   0.0001188968    0.001647312     0.01236082     0.05464662\n[4,]   0.0001142025    0.001592977     0.01204944     0.05370176\n[5,]   0.0001094721    0.001539443     0.01174679     0.05279154\n[6,]   0.0001048512    0.001487695     0.01145582     0.05191868\n\n\nTo illustrate these exceedance probabilities, we plot them over the course of the year\n\ncol &lt;- colorspace::heat_hcl(ncol(probs))\nmatplot(0:365, probs, type = \"l\", lty = 1, lwd = 2, col = col,\n  xlab = \"Day of the Year\", ylab = \"Estimated Probabilities\")\nabline(h = 0.05, lty = 2, col = \"lightgray\")\nlegend(\"topleft\", colnames(probs),\n  lwd = 2, lty = 1, col = col, bty = \"n\")\n\n\n\n\n\n\n\n\nThe plot reveals that even at this high-altitude station, the probability of Tmax &gt; 14°C reaches approximately 5% during summer. This is particularly striking considering that the Zugspitze once had a permanent glacier field, emphasizing the impact of rising temperatures in this region. Likewise, the probability of Tmax &gt; 0°C during the winter months is also about 5%, highlighting significant temperature patterns."
  },
  {
    "objectID": "CITATION.html",
    "href": "CITATION.html",
    "title": "Citation",
    "section": "",
    "text": "Citation\nTo cite GAMLSS in publications use:\n\nR.A. Rigby, D.M. Stasinopoulos (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Citation"
    ]
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "gamlss2 0.1-0",
    "section": "",
    "text": "gamlss2 0.1-0\n\nFirst version of ‘gamlss2’ providing a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.",
    "crumbs": [
      "News"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html",
    "href": "man/gamlss2_control.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Reference",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html#control-parameters",
    "href": "man/gamlss2_control.html#control-parameters",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Reference",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html",
    "href": "man/gamlss2-package.html",
    "title": "gamlss2",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Reference",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "href": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "title": "gamlss2",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Reference",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2.html",
    "href": "man/gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4529 eps = 0.534347     \nGAMLSS-RS iteration  2: Global Deviance = 4770.23 eps = 0.000884     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1675 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1566 eps = 0.000002     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  226.334      1.257     180   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 4.551\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -2.92263    0.01101  -265.5   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 2.564\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.18024    0.04599  -3.919 9.93e-05 ***\n---\nSmooth terms:\n      s(x)\nedf 1.0015\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   2.6547     0.0144   184.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n      s(x)\nedf 1.0004\n*--------\nn = 610 df =  13.12 res.df =  596.88\nDeviance = 4770.1566 Null Dev. Red. = 33.39%\nAIC = 4796.3906 elapsed =  0.86sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4789.3844 eps = 0.556049     \nGAMLSS-RS iteration  2: Global Deviance = 4775.2264 eps = 0.002956     \nGAMLSS-RS iteration  3: Global Deviance = 4772.53 eps = 0.000564     \nGAMLSS-RS iteration  4: Global Deviance = 4770.7437 eps = 0.000374     \nGAMLSS-RS iteration  5: Global Deviance = 4769.9311 eps = 0.000170     \nGAMLSS-RS iteration  6: Global Deviance = 4769.9052 eps = 0.000005     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 4799.4176 eps = 0.555119     \nGAMLSS-RS iteration  2: Global Deviance = 4795.2801 eps = 0.000862     \nGAMLSS-RS iteration  3: Global Deviance = 4795.2666 eps = 0.000002     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.349307           -2.922923            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4902.0842 eps = 0.372275     \nGAMLSS-RS iteration  2: Global Deviance = 4775.4005 eps = 0.025842     \nGAMLSS-RS iteration  3: Global Deviance = 4774.5559 eps = 0.000176     \nGAMLSS-RS iteration  4: Global Deviance = 4774.5318 eps = 0.000005     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4529 eps = 0.534347     \nGAMLSS-RS iteration  2: Global Deviance = 4770.23 eps = 0.000884     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1675 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1566 eps = 0.000002",
    "crumbs": [
      "Reference",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "href": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4529 eps = 0.534347     \nGAMLSS-RS iteration  2: Global Deviance = 4770.23 eps = 0.000884     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1675 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1566 eps = 0.000002     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  226.334      1.257     180   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 4.551\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -2.92263    0.01101  -265.5   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 2.564\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.18024    0.04599  -3.919 9.93e-05 ***\n---\nSmooth terms:\n      s(x)\nedf 1.0015\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   2.6547     0.0144   184.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n      s(x)\nedf 1.0004\n*--------\nn = 610 df =  13.12 res.df =  596.88\nDeviance = 4770.1566 Null Dev. Red. = 33.39%\nAIC = 4796.3906 elapsed =  0.86sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4789.3844 eps = 0.556049     \nGAMLSS-RS iteration  2: Global Deviance = 4775.2264 eps = 0.002956     \nGAMLSS-RS iteration  3: Global Deviance = 4772.53 eps = 0.000564     \nGAMLSS-RS iteration  4: Global Deviance = 4770.7437 eps = 0.000374     \nGAMLSS-RS iteration  5: Global Deviance = 4769.9311 eps = 0.000170     \nGAMLSS-RS iteration  6: Global Deviance = 4769.9052 eps = 0.000005     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 4799.4176 eps = 0.555119     \nGAMLSS-RS iteration  2: Global Deviance = 4795.2801 eps = 0.000862     \nGAMLSS-RS iteration  3: Global Deviance = 4795.2666 eps = 0.000002     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.349307           -2.922923            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4902.0842 eps = 0.372275     \nGAMLSS-RS iteration  2: Global Deviance = 4775.4005 eps = 0.025842     \nGAMLSS-RS iteration  3: Global Deviance = 4774.5559 eps = 0.000176     \nGAMLSS-RS iteration  4: Global Deviance = 4774.5318 eps = 0.000005     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4529 eps = 0.534347     \nGAMLSS-RS iteration  2: Global Deviance = 4770.23 eps = 0.000884     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1675 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1566 eps = 0.000002",
    "crumbs": [
      "Reference",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html",
    "href": "man/HarzTraffic.html",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de, https://www.bast.de/DE/Verkehrstechnik/Fachthemen/v2-verkehrszaehlung/Verkehrszaehlung.html\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.082 eps = 0.148402     \nGAMLSS-RS iteration  2: Global Deviance = 10151.144 eps = 0.001174     \nGAMLSS-RS iteration  3: Global Deviance = 10151.1409 eps = 0.000000     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\npar &lt;- predict(m, newdata = nd)\n\n## corresponding quantiles\np &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(m)$q(q, par))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "href": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de, https://www.bast.de/DE/Verkehrstechnik/Fachthemen/v2-verkehrszaehlung/Verkehrszaehlung.html\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.082 eps = 0.148402     \nGAMLSS-RS iteration  2: Global Deviance = 10151.144 eps = 0.001174     \nGAMLSS-RS iteration  3: Global Deviance = 10151.1409 eps = 0.000000     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\npar &lt;- predict(m, newdata = nd)\n\n## corresponding quantiles\np &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(m)$q(q, par))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/fake_formula.html",
    "href": "man/fake_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Reference",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "href": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Reference",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/glmnet.html",
    "href": "man/glmnet.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\nlasso(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”).\n\n\n\nThe lasso() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Reference",
      "glmnet"
    ]
  },
  {
    "objectID": "man/glmnet.html#lasso-with-glmnet",
    "href": "man/glmnet.html#lasso-with-glmnet",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\nlasso(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”).\n\n\n\nThe lasso() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Reference",
      "glmnet"
    ]
  },
  {
    "objectID": "man/plots.html",
    "href": "man/plots.html",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Reference",
      "plots"
    ]
  },
  {
    "objectID": "man/plots.html#plotting-gamlss",
    "href": "man/plots.html#plotting-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Reference",
      "plots"
    ]
  },
  {
    "objectID": "man/modelstats.html",
    "href": "man/modelstats.html",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 406.747 eps = 0.297097     \nGAMLSS-RS iteration  2: Global Deviance = 374.1346 eps = 0.080178     \nGAMLSS-RS iteration  3: Global Deviance = 364.2545 eps = 0.026407     \nGAMLSS-RS iteration  4: Global Deviance = 363.228 eps = 0.002817     \nGAMLSS-RS iteration  5: Global Deviance = 363.1599 eps = 0.000187     \nGAMLSS-RS iteration  6: Global Deviance = 363.154 eps = 0.000016     \nGAMLSS-RS iteration  7: Global Deviance = 363.1529 eps = 0.000003     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9892836 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 388.9822 12.91461\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 388.9822 12.91461\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 412.3145 12.91461\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Reference",
      "modelstats"
    ]
  },
  {
    "objectID": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "href": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 406.747 eps = 0.297097     \nGAMLSS-RS iteration  2: Global Deviance = 374.1346 eps = 0.080178     \nGAMLSS-RS iteration  3: Global Deviance = 364.2545 eps = 0.026407     \nGAMLSS-RS iteration  4: Global Deviance = 363.228 eps = 0.002817     \nGAMLSS-RS iteration  5: Global Deviance = 363.1599 eps = 0.000187     \nGAMLSS-RS iteration  6: Global Deviance = 363.154 eps = 0.000016     \nGAMLSS-RS iteration  7: Global Deviance = 363.1529 eps = 0.000003     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9892836 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 388.9822 12.91461\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 388.9822 12.91461\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 412.3145 12.91461\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Reference",
      "modelstats"
    ]
  },
  {
    "objectID": "man/lasso.html",
    "href": "man/lasso.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “nominal” the nominal fusion penalty and type = 4 or type = “ordinal” the ordinal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” for shrinkage parameter selection, arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the Bayesian Information Criterion (BIC).\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nAndreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in the framework of generalized additive models for location, scale and shape. Computational Statistics & Data Analysis. doi:10.1016/j.csda.2019.06.005\nOelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of penalties in generalized structured models. Adv Data Anal Classif. doi:10.1007/s11634-015-0205-y\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) |\n  la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) |\n  la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 5)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"sigma.la(Ac\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), main = \"Fused Lasso\")\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X \nsigma &lt;- exp(-1 + X \n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=3) | la(X,type=3)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\",\n  zoom = c(8, 9))\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\n## true positive rate\ntp &lt;- mean(c(cb_mu[beta$mu &gt; 0] &gt; 0,\n  cb_sigma[beta$sigma &gt; 0] &gt; 0))\n\n## false positive rate, needs threshold\nthres &lt;- 0.01\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))",
    "crumbs": [
      "Reference",
      "lasso"
    ]
  },
  {
    "objectID": "man/lasso.html#lasso-model-terms",
    "href": "man/lasso.html#lasso-model-terms",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “nominal” the nominal fusion penalty and type = 4 or type = “ordinal” the ordinal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” for shrinkage parameter selection, arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the Bayesian Information Criterion (BIC).\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nAndreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in the framework of generalized additive models for location, scale and shape. Computational Statistics & Data Analysis. doi:10.1016/j.csda.2019.06.005\nOelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of penalties in generalized structured models. Adv Data Anal Classif. doi:10.1007/s11634-015-0205-y\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) |\n  la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) |\n  la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 5)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"sigma.la(Ac\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), main = \"Fused Lasso\")\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X \nsigma &lt;- exp(-1 + X \n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=3) | la(X,type=3)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\",\n  zoom = c(8, 9))\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\n## true positive rate\ntp &lt;- mean(c(cb_mu[beta$mu &gt; 0] &gt; 0,\n  cb_sigma[beta$sigma &gt; 0] &gt; 0))\n\n## false positive rate, needs threshold\nthres &lt;- 0.01\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))",
    "crumbs": [
      "Reference",
      "lasso"
    ]
  },
  {
    "objectID": "man/random.html",
    "href": "man/random.html",
    "title": "gamlss2",
    "section": "",
    "text": "There are two ways of fitting a random effect within gamlss2. The first, using s(), is for a simple random effect, that is, when only one factor is entered the model as a smoother. This method uses the function s() of the package mgcv with argument bs = “re”. For example, if area is factor with several levels, s(area, bs = “re”) will sringh the levels of area towards their mean level. The second, more general way, allows to fit more complicated random effect models using the function re(). The function re() is an interface connecting gamlss2 with the specialised package for random effects nlme.\nHere we document only the re() function only but we also give examples using s(…, bs = “re”).\n\n\n\nre(fixed =~ 1, random = NULL, ...)\n\n\n\n\n\n\n\nfixed\n\n\nA formula that specifies the fixed effects of the nlme{lme} model. In most cases, this can also be included in the gamlss2 parameter formula.\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the nlme{lme()} function.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the nlme{lme} function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor\nb &lt;- gamlss2(distance ~ s(age,k=3) + re(random =~ age11 | Subject),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6569 eps = 0.392363     \nGAMLSS-RS iteration  2: Global Deviance = 326.0931 eps = 0.001726     \nGAMLSS-RS iteration  3: Global Deviance = 326.0758 eps = 0.000053     \nGAMLSS-RS iteration  4: Global Deviance = 326.0754 eps = 0.000001     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", elements = \"model\")\nsummary(st)\n\n                             Length Class  Mode\nmu.s(age)                     9     -none- list\nmu.re(random=~age11|Subject) 19     lme    list\n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4036 eps = 0.133550     \nGAMLSS-RS iteration  3: Global Deviance = 359.232 eps = 0.030160     \nGAMLSS-RS iteration  4: Global Deviance = 334.3919 eps = 0.069147     \nGAMLSS-RS iteration  5: Global Deviance = 322.9054 eps = 0.034350     \nGAMLSS-RS iteration  6: Global Deviance = 318.0482 eps = 0.015042     \nGAMLSS-RS iteration  7: Global Deviance = 316.2218 eps = 0.005742     \nGAMLSS-RS iteration  8: Global Deviance = 315.5587 eps = 0.002096     \nGAMLSS-RS iteration  9: Global Deviance = 315.3218 eps = 0.000750     \nGAMLSS-RS iteration 10: Global Deviance = 315.2367 eps = 0.000269     \nGAMLSS-RS iteration 11: Global Deviance = 315.2063 eps = 0.000096     \nGAMLSS-RS iteration 12: Global Deviance = 315.1955 eps = 0.000034     \nGAMLSS-RS iteration 13: Global Deviance = 315.1917 eps = 0.000012     \nGAMLSS-RS iteration 14: Global Deviance = 315.1906 eps = 0.000003     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ s(Time) + re(random =~ sin1 | Mare,\n  correlation = corARMA(q = 2), control = lmeControl(maxIter = 100))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1560.1178 eps = 0.165409     \nGAMLSS-RS iteration  2: Global Deviance = 1551.3069 eps = 0.005647     \nGAMLSS-RS iteration  3: Global Deviance = 1551.1747 eps = 0.000085     \nGAMLSS-RS iteration  4: Global Deviance = 1551.1728 eps = 0.000001     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.4785 eps = 0.056256     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6643 eps = 0.006832     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7728 eps = 0.000624     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6942 eps = 0.000055     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6873 eps = 0.000004     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n }",
    "crumbs": [
      "Reference",
      "random"
    ]
  },
  {
    "objectID": "man/random.html#random-effects",
    "href": "man/random.html#random-effects",
    "title": "gamlss2",
    "section": "",
    "text": "There are two ways of fitting a random effect within gamlss2. The first, using s(), is for a simple random effect, that is, when only one factor is entered the model as a smoother. This method uses the function s() of the package mgcv with argument bs = “re”. For example, if area is factor with several levels, s(area, bs = “re”) will sringh the levels of area towards their mean level. The second, more general way, allows to fit more complicated random effect models using the function re(). The function re() is an interface connecting gamlss2 with the specialised package for random effects nlme.\nHere we document only the re() function only but we also give examples using s(…, bs = “re”).\n\n\n\nre(fixed =~ 1, random = NULL, ...)\n\n\n\n\n\n\n\nfixed\n\n\nA formula that specifies the fixed effects of the nlme{lme} model. In most cases, this can also be included in the gamlss2 parameter formula.\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the nlme{lme()} function.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the nlme{lme} function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor\nb &lt;- gamlss2(distance ~ s(age,k=3) + re(random =~ age11 | Subject),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6569 eps = 0.392363     \nGAMLSS-RS iteration  2: Global Deviance = 326.0931 eps = 0.001726     \nGAMLSS-RS iteration  3: Global Deviance = 326.0758 eps = 0.000053     \nGAMLSS-RS iteration  4: Global Deviance = 326.0754 eps = 0.000001     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", elements = \"model\")\nsummary(st)\n\n                             Length Class  Mode\nmu.s(age)                     9     -none- list\nmu.re(random=~age11|Subject) 19     lme    list\n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4036 eps = 0.133550     \nGAMLSS-RS iteration  3: Global Deviance = 359.232 eps = 0.030160     \nGAMLSS-RS iteration  4: Global Deviance = 334.3919 eps = 0.069147     \nGAMLSS-RS iteration  5: Global Deviance = 322.9054 eps = 0.034350     \nGAMLSS-RS iteration  6: Global Deviance = 318.0482 eps = 0.015042     \nGAMLSS-RS iteration  7: Global Deviance = 316.2218 eps = 0.005742     \nGAMLSS-RS iteration  8: Global Deviance = 315.5587 eps = 0.002096     \nGAMLSS-RS iteration  9: Global Deviance = 315.3218 eps = 0.000750     \nGAMLSS-RS iteration 10: Global Deviance = 315.2367 eps = 0.000269     \nGAMLSS-RS iteration 11: Global Deviance = 315.2063 eps = 0.000096     \nGAMLSS-RS iteration 12: Global Deviance = 315.1955 eps = 0.000034     \nGAMLSS-RS iteration 13: Global Deviance = 315.1917 eps = 0.000012     \nGAMLSS-RS iteration 14: Global Deviance = 315.1906 eps = 0.000003     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ s(Time) + re(random =~ sin1 | Mare,\n  correlation = corARMA(q = 2), control = lmeControl(maxIter = 100))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1560.1178 eps = 0.165409     \nGAMLSS-RS iteration  2: Global Deviance = 1551.3069 eps = 0.005647     \nGAMLSS-RS iteration  3: Global Deviance = 1551.1747 eps = 0.000085     \nGAMLSS-RS iteration  4: Global Deviance = 1551.1728 eps = 0.000001     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.4785 eps = 0.056256     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6643 eps = 0.006832     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7728 eps = 0.000624     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6942 eps = 0.000055     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6873 eps = 0.000004     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n }",
    "crumbs": [
      "Reference",
      "random"
    ]
  },
  {
    "objectID": "man/discretize.html",
    "href": "man/discretize.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Simulate count data using the Poisson distribution.\nset.seed(111)\ny &lt;- rpois(1000, lambda = 10)\n\n## Create a discretized family using the BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model using the discretized family.\nfit_family(y, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = 5272.794 eps = 0.498257     \nGAMLSS-RS iteration  2: Global Deviance = 5182.6372 eps = 0.017098     \nGAMLSS-RS iteration  3: Global Deviance = 5169.4641 eps = 0.002541     \nGAMLSS-RS iteration  4: Global Deviance = 5163.3648 eps = 0.001179     \nGAMLSS-RS iteration  5: Global Deviance = 5126.7215 eps = 0.007096     \nGAMLSS-RS iteration  6: Global Deviance = 5123.1815 eps = 0.000690     \nGAMLSS-RS iteration  7: Global Deviance = 5121.8092 eps = 0.000267     \nGAMLSS-RS iteration  8: Global Deviance = 5121.3062 eps = 0.000098     \nGAMLSS-RS iteration  9: Global Deviance = 5121.1198 eps = 0.000036     \nGAMLSS-RS iteration 10: Global Deviance = 5121.0522 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 5121.0119 eps = 0.000007",
    "crumbs": [
      "Reference",
      "discretize"
    ]
  },
  {
    "objectID": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "href": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Simulate count data using the Poisson distribution.\nset.seed(111)\ny &lt;- rpois(1000, lambda = 10)\n\n## Create a discretized family using the BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model using the discretized family.\nfit_family(y, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = 5272.794 eps = 0.498257     \nGAMLSS-RS iteration  2: Global Deviance = 5182.6372 eps = 0.017098     \nGAMLSS-RS iteration  3: Global Deviance = 5169.4641 eps = 0.002541     \nGAMLSS-RS iteration  4: Global Deviance = 5163.3648 eps = 0.001179     \nGAMLSS-RS iteration  5: Global Deviance = 5126.7215 eps = 0.007096     \nGAMLSS-RS iteration  6: Global Deviance = 5123.1815 eps = 0.000690     \nGAMLSS-RS iteration  7: Global Deviance = 5121.8092 eps = 0.000267     \nGAMLSS-RS iteration  8: Global Deviance = 5121.3062 eps = 0.000098     \nGAMLSS-RS iteration  9: Global Deviance = 5121.1198 eps = 0.000036     \nGAMLSS-RS iteration 10: Global Deviance = 5121.0522 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 5121.0119 eps = 0.000007",
    "crumbs": [
      "Reference",
      "discretize"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html",
    "href": "man/predict.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? (not implemented yet).\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1777 eps = 0.002913     \nGAMLSS-RS iteration  3: Global Deviance = 405.8035 eps = 0.000921     \nGAMLSS-RS iteration  4: Global Deviance = 405.7928 eps = 0.000026     \nGAMLSS-RS iteration  5: Global Deviance = 405.7928 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.12533 10.04622\n2 58.79229 18.57125\n3 95.49447 34.32080\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.12533 10.04622\n2 58.79229 18.57125\n3 95.49447 34.32080\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.04622 18.57125 34.32080 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.04622\n2 18.57125\n3 34.32080\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1     2.63899 -0.3317927\n2     2.63899  0.2826252\n3     2.63899  0.8967621\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3317927\n2  0.2826252\n3  0.8967621",
    "crumbs": [
      "Reference",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "href": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? (not implemented yet).\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1777 eps = 0.002913     \nGAMLSS-RS iteration  3: Global Deviance = 405.8035 eps = 0.000921     \nGAMLSS-RS iteration  4: Global Deviance = 405.7928 eps = 0.000026     \nGAMLSS-RS iteration  5: Global Deviance = 405.7928 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.12533 10.04622\n2 58.79229 18.57125\n3 95.49447 34.32080\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.12533 58.79229 95.49447 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.12533 10.04622\n2 58.79229 18.57125\n3 95.49447 34.32080\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.04622 18.57125 34.32080 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.04622\n2 18.57125\n3 34.32080\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1     2.63899 -0.3317927\n2     2.63899  0.2826252\n3     2.63899  0.8967621\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3317927\n2  0.2826252\n3  0.8967621",
    "crumbs": [
      "Reference",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/RS_CG.html",
    "href": "man/RS_CG.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Reference",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "href": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Reference",
      "RS_CG"
    ]
  },
  {
    "objectID": "vignettes/families.html",
    "href": "vignettes/families.html",
    "title": "Family Objects",
    "section": "",
    "text": "All family objects of the gamlss.dist package, see Rigby et al. (2019), can be used for modelling in gamlss2. However, for users wanting to specify their own (new) distribution model, this document provides a guide on how to define custom family objects within the gamlss2 framework.\nFamily objects in the gamlss2 package play an essential role in defining the models used for fitting data to distributions. These objects encapsulate the necessary details about the distribution and the parameters, such as:\nThis document provides an overview of how to construct and use family objects within gamlss2. By the end, you should have a good understanding of how to implement a custom family for use in statistical models.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#defining-family-objects",
    "href": "vignettes/families.html#defining-family-objects",
    "title": "Family Objects",
    "section": "1 Defining Family Objects",
    "text": "1 Defining Family Objects\nA family object in gamlss2 is a list that must meet the following minimum criteria:\n\nFamily Name: The object must contain the family name as a character string.\nParameters: The object must list the parameters of the distribution (e.g., \"mu\" and \"sigma\" for a normal distribution).\nLink Functions: It must specify the link functions associated with each parameter.\nDensity Function: A d() function must be provided to evaluate the (log-)density of the distribution.\n\nOptionally, a family object can include functions to calculate the log-likelihood, random number generation, cumulative distribution function (CDF), and quantile function.\nHere’s an example of a minimal family object for the normal distribution.\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, par$mu, par$sigma, log = log)\n    }\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIn this example, we define a normal distribution with two parameters: \"mu\" (mean) and \"sigma\" (standard deviation). The link function for \"mu\" is the identity, and for \"sigma\", it is the log function. The density function uses the standard dnorm() function from to calculate the normal density.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#density-function",
    "href": "vignettes/families.html#density-function",
    "title": "Family Objects",
    "section": "2 Density Function",
    "text": "2 Density Function\nThe density function must accept the following arguments:\n\nd(y, par, log = FALSE, ...)\n\n\ny: The response variable.\npar: A named list of parameters (e.g., \"mu\", \"sigma\" for the normal distribution).\nlog: A logical value indicating whether to return the log-density.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#optional-derivatives",
    "href": "vignettes/families.html#optional-derivatives",
    "title": "Family Objects",
    "section": "3 Optional Derivatives",
    "text": "3 Optional Derivatives\nFamily objects can optionally include functions to compute the first and second derivatives of the log-likelihood with respect to the predictors (or its expectations). These derivatives are used for optimization during model fitting.\nThe derivative functions follow the form:\n\nfunction(y, par, ...)\n\nThe derivate functions of first order must be provided as a named list, one list element for each parameter of the distribution, and is named \"score\". The second order derivative list is named \"hess\". Note that these functions must return the derivative w.r.t. predictor and the \"hess\" functions must return the negative (expected) second derivatives\nAn example of setting up first and second order derivatives for the normal is provided in the following code:\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, par$mu, par$sigma, log = log)\n    },\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIf no derivatives are provided, numerical approximations will be used by the package.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#additional-functions",
    "href": "vignettes/families.html#additional-functions",
    "title": "Family Objects",
    "section": "4 Additional Functions",
    "text": "4 Additional Functions\nFamily objects can also include other functions such as:\n\nCumulative distribution function (p()).\nQuantile function (q()).\nRandom number generation (r()).\n\nThese functions should adhere to the same structure as the density function, taking the response (y), parameters (par), and other relevant arguments.\n\n\n\n\n\n\nNote\n\n\n\nNote that the CDF p() function is needed it for computing the quantile residuals.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#flexible-links",
    "href": "vignettes/families.html#flexible-links",
    "title": "Family Objects",
    "section": "5 Flexible Links",
    "text": "5 Flexible Links\nNote that the example above used static link functions to define the family object. However, users can easily create families with flexible link functions as well. A helpful example of how to implement such flexibility can be found in the Kumaraswamy distribution implementation, which provides a clear template for setting up families with customizable link functions.\nThe Kumaraswamy distribution is a continuous distribution defined on the interval \\((0, 1)\\). It is similar to the Beta distribution but has simpler forms for its cumulative distribution and inverse cumulative distribution functions, making it more computationally efficient for certain applications. Unfortunately the Kumaraswamy distribution parameters do not conform with the distribution regression principal that parameters should have a clear interpretation in terms of location and scale. For example, the mean and variance of the distribution are a rather complicated functions of the parameters a and b, nevertheless the distribution is a good example of two parameter distribution in which the parameters are not named as mu and sigma as in all distributions defined in Rigby et al. (2019).\nThe probability density function (PDF) of the Kumaraswamy distribution is:\n\\[\nf(y; a, b) = aby^{a-1}(1 - y^a)^{b-1}\n\\]\nwhere \\(y \\in (0, 1)\\) is the response, and \\(a\\) and \\(b\\) are non-negative parameters that determine the shape of the distribution. The complete implementation, including flexible link functions is provided in the Kumaraswamy() family.\nIn the following example, we will create the family object for the Kumaraswamy distribution using the Kumaraswamy() function and estimate a model using this distribution. In detail, we will:\n\nDefine the Kumaraswamy family object.\nSimulate data based on this distribution.\nEstimate the model and plot the results.\n\n\n## Define the Kumaraswamy family object with specific link functions.\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## Set seed for reproducibility.\nset.seed(123)\n\n## Simulate data for 1000 observations.\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## Specify the true parameters.\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,  # Parameter 'a' depends on 'x'\n  \"b\" = 1  # Parameter 'b' is constant\n)\n\n## Sample response values using the family object.\nd$y &lt;- fam$r(1, par)\n\n## Estimate a model using the Kumaraswamy family.\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## Plot the estimated effect.\nplot(b)\n\n\n\n\n\n\n\n## Plot residual diagnostics.\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n\nIn this example, we simulated a dataset where the parameter a of the Kumaraswamy distribution varies with x following a sinusoidal pattern. We then used the gamlss2() function to fit a smooth model that estimates this relationship. The effect of x on y is plotted, followed by a diagnostic plot to assess residuals.\nThe Kumaraswamy() family in gamlss2 is flexible, allowing the user to specify different link functions for its parameters, such as the default shiftlog link function for parameter a, which ensures non-negative values.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/families.html#summary",
    "href": "vignettes/families.html#summary",
    "title": "Family Objects",
    "section": "6 Summary",
    "text": "6 Summary\nFamily objects in the gamlss2 package are a fundamental component for defining flexible, distribution-based regression models, and beyond. By encapsulating the necessary elements, such as parameters, link functions, and density functions, they provide a powerful framework for customizing models to fit specific data. The flexibility to define custom families, as demonstrated with the Kumaraswamy() distribution, enables users to extend the package beyond its default families, making it adaptable to a wide range of modeling scenarios. Furthermore, the ability to define both static and dynamic link functions enhances the versatility of gamlss2 for distributional regression, empowering users to tailor models to their unique data and research needs.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  }
]