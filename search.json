[
  {
    "objectID": "CITATION.html",
    "href": "CITATION.html",
    "title": "Citation",
    "section": "",
    "text": "Citation\nTo cite this package in publications use:\n\nRigby R, Stasinopoulos D (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x.\n\n\nUmlauf N, Klein N, Zeileis A (2018). “BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond).” Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325."
  },
  {
    "objectID": "man/random.html",
    "href": "man/random.html",
    "title": "gamlss2",
    "section": "",
    "text": "Random effects can be included in gamlss2 models in two ways.\nThe first uses s() with bs = “re” for simple random effects, i.e., when a single factor is entered into the model as a smoother. This approach relies on the s() function from the mgcv package. For example, if area is a factor with several levels, then s(area, bs = “re”) shrinks the level-specific effects of area towards their overall mean.\nThe second, more general approach uses the model term constructor re(), which provides an interface to the specialised random-effects functionality in the nlme package. This allows fitting more complex random-effects structures.\nThis documentation focuses on the re() function, but we also provide examples using s(…, bs = “re”).\n\n\n\nre(random, correlation = NULL, ...)\n\n\n\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the lme function.\n\n\n\n\ncorrelation\n\n\nAn optional correlation object, see lme.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the lme function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor,\n## setup formula first\nf &lt;- distance ~ age11 + re(~age11|Subject)\n\n## estimate model\nb &lt;- gamlss2(f, data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6623 eps = 0.392353     \nGAMLSS-RS iteration  2: Global Deviance = 326.6623 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", term = \"age11\", elements = \"model\")\nsummary(st)\n\nLinear mixed-effects model fit by maximum likelihood\n  Data: structure(list(age11 = c(-3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3), Subject = structure(c(15L, 15L,  15L, 15L, 3L, 3L, 3L, 3L, 7L, 7L, 7L, 7L, 14L, 14L, 14L, 14L,  2L, 2L, 2L, 2L, 13L, 13L, 13L, 13L, 5L, 5L, 5L, 5L, 6L, 6L, 6L,  6L, 11L, 11L, 11L, 11L, 16L, 16L, 16L, 16L, 4L, 4L, 4L, 4L, 8L,  8L, 8L, 8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 12L, 12L, 12L,  12L, 1L, 1L, 1L, 1L, 20L, 20L, 20L, 20L, 23L, 23L, 23L, 23L,  25L, 25L, 25L, 25L, 26L, 26L, 26L, 26L, 21L, 21L, 21L, 21L, 19L,  19L, 19L, 19L, 22L, 22L, 22L, 22L, 24L, 24L, 24L, 24L, 18L, 18L,  18L, 18L, 17L, 17L, 17L, 17L, 27L, 27L, 27L, 27L), levels = c(\"M16\",  \"M05\", \"M02\", \"M11\", \"M07\", \"M08\", \"M03\", \"M12\", \"M13\", \"M14\",  \"M09\", \"M15\", \"M06\", \"M04\", \"M01\", \"M10\", \"F10\", \"F09\", \"F06\",  \"F01\", \"F05\", \"F07\", \"F02\", \"F08\", \"F03\", \"F04\", \"F11\"), class = c(\"ordered\",  \"factor\")), response_z = c(3.95740740740771, 1.63703703703704,  4.31666666666667, 4.9962962962963, -0.542592592592602, -0.862962962962968,  -1.68333333333333, 0.496296296296297, 0.957407407407398, -0.862962962962968,  -0.683333333333334, 1.4962962962963, 3.4574074074074, 4.13703703703703,  1.81666666666666, 0.996296296296297, -2.0425925925926, 0.137037037037032,  -2.18333333333333, -0.00370370370369955, 2.4574074074074, 2.13703703703704,  2.31666666666666, 2.4962962962963, -0.0425925925926016, -1.36296296296297,  -0.183333333333334, 0.496296296296297, 1.9574074074074, -1.86296296296297,  -0.183333333333334, -0.5037037037037, 0.957407407407398, -2.86296296296297,  6.31666666666666, -0.00370370370369955, 5.45740740740739, 4.63703703703703,  6.31666666666666, 5.49629629629629, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -1.0037037037037, -0.542592592592602, 0.137037037037032,  -0.683333333333334, 1.9962962962963, -5.0425925925926, 1.13703703703703,  1.31666666666667, 3.4962962962963, 0.457407407407402, 2.13703703703704,  0.81666666666667, -0.00370370370369955, 0.957407407407402, 1.13703703703703,  1.31666666666667, 3.9962962962963, -0.0425925925926016, -1.86296296296297,  -1.18333333333333, -1.0037037037037, -1.0425925925926, -3.36296296296297,  -3.18333333333333, -3.0037037037037, -1.0425925925926, -1.86296296296297,  -0.683333333333334, -0.5037037037037, -1.5425925925926, 0.637037037037032,  -0.183333333333334, -0.00370370370369955, 1.4574074074074, 1.13703703703703,  0.316666666666666, 0.496296296296297, -0.542592592592602, -0.362962962962968,  -2.18333333333333, -2.5037037037037, -2.0425925925926, -2.36296296296297,  -3.68333333333334, -3.5037037037037, -0.542592592592602, -0.862962962962968,  -1.68333333333333, -1.0037037037037, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -2.0037037037037, -2.04259259259261, -2.36296296296297,  -2.68333333333333, -4.5037037037037, -5.5425925925926, -4.36296296296297,  -5.68333333333334, -6.5037037037037, 2.4574074074074, 1.63703703703704,  3.31666666666666, 1.9962962962963), weights_w = c(0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369)), terms = ~age11 +      Subject, row.names = c(NA, 108L), class = \"data.frame\") \n       AIC      BIC    logLik\n  449.2116 462.6223 -219.6058\n\nRandom effects:\n Formula: ~age11 | Subject\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 2.0906352 (Intr)\nage11       0.2149235 0.521 \nResidual    3.8365552       \n\nVariance function:\n Structure: fixed weights\n Formula: ~weights_w \nFixed effects:  response_z ~ 1 \n                   Value Std.Error DF      t-value p-value\n(Intercept) 6.064444e-16 0.4048917 81 1.497794e-15       1\n\nStandardized Within-Group Residuals:\n         Min           Q1          Med           Q3          Max \n-3.305976369 -0.487428882  0.007598099  0.482237876  3.922787577 \n\nNumber of Observations: 108\nNumber of Groups: 27 \n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4092 eps = 0.133537     \nGAMLSS-RS iteration  3: Global Deviance = 340.4591 eps = 0.080856     \nGAMLSS-RS iteration  4: Global Deviance = 325.4834 eps = 0.043986     \nGAMLSS-RS iteration  5: Global Deviance = 319.1487 eps = 0.019462     \nGAMLSS-RS iteration  6: Global Deviance = 316.6824 eps = 0.007727     \nGAMLSS-RS iteration  7: Global Deviance = 315.7553 eps = 0.002927     \nGAMLSS-RS iteration  8: Global Deviance = 315.4122 eps = 0.001086     \nGAMLSS-RS iteration  9: Global Deviance = 315.2857 eps = 0.000401     \nGAMLSS-RS iteration 10: Global Deviance = 315.2397 eps = 0.000145     \nGAMLSS-RS iteration 11: Global Deviance = 315.2211 eps = 0.000059     \nGAMLSS-RS iteration 12: Global Deviance = 315.2141 eps = 0.000022     \nGAMLSS-RS iteration 13: Global Deviance = 315.2112 eps = 0.000009     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ sin1 + cos1 +\n  re(~ 1 | Mare) +\n  re(~ sin1 - 1 | Mare, correlation = corARMA(q = 2))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1561.4397 eps = 0.164702     \nGAMLSS-RS iteration  2: Global Deviance = 1561.3891 eps = 0.000032     \nGAMLSS-RS iteration  3: Global Deviance = 1561.3816 eps = 0.000004     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.5015 eps = 0.056241     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6605 eps = 0.006850     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7658 eps = 0.000627     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6839 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6744 eps = 0.000006     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n}\n\n## simulated data\nset.seed(1328)\n\nn &lt;- 10000\nk &lt;- 500\n\n## generate random effects\nf &lt;- as.factor(sample(1:k, size = n, replace = TRUE))\nref &lt;- rnorm(k, sd = 0.6)\n\n## random effects only for sigma\ny &lt;- rBCT(n, mu = 10, sigma = exp(-1 + ref[f]), tau = 10)\n\n## estimate model\nb &lt;- gamlss2(y ~ 1 | re(~ 1 | f), family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 54284.8778 eps = 0.443825     \nGAMLSS-RS iteration  2: Global Deviance = 53798.1163 eps = 0.008966     \nGAMLSS-RS iteration  3: Global Deviance = 53767.8702 eps = 0.000562     \nGAMLSS-RS iteration  4: Global Deviance = 53761.3751 eps = 0.000120     \nGAMLSS-RS iteration  5: Global Deviance = 53758.2934 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 53757.5692 eps = 0.000013     \nGAMLSS-RS iteration  7: Global Deviance = 53756.9982 eps = 0.000010     \nGAMLSS-RS iteration  8: Global Deviance = 53756.5246 eps = 0.000008     \n\n## extract fitted random effects\ncb &lt;- coef(b, full = TRUE)\ncb &lt;- cb[grepl(\"re\", names(cb), fixed = TRUE)]\n\n## compare\nplot(cb, ref, main = round(mean((cb - ref)^2), 2))\nabline(0, 1, lwd = 2, col = 4)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "random"
    ]
  },
  {
    "objectID": "man/random.html#random-effects",
    "href": "man/random.html#random-effects",
    "title": "gamlss2",
    "section": "",
    "text": "Random effects can be included in gamlss2 models in two ways.\nThe first uses s() with bs = “re” for simple random effects, i.e., when a single factor is entered into the model as a smoother. This approach relies on the s() function from the mgcv package. For example, if area is a factor with several levels, then s(area, bs = “re”) shrinks the level-specific effects of area towards their overall mean.\nThe second, more general approach uses the model term constructor re(), which provides an interface to the specialised random-effects functionality in the nlme package. This allows fitting more complex random-effects structures.\nThis documentation focuses on the re() function, but we also provide examples using s(…, bs = “re”).\n\n\n\nre(random, correlation = NULL, ...)\n\n\n\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the lme function.\n\n\n\n\ncorrelation\n\n\nAn optional correlation object, see lme.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the lme function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor,\n## setup formula first\nf &lt;- distance ~ age11 + re(~age11|Subject)\n\n## estimate model\nb &lt;- gamlss2(f, data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6623 eps = 0.392353     \nGAMLSS-RS iteration  2: Global Deviance = 326.6623 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", term = \"age11\", elements = \"model\")\nsummary(st)\n\nLinear mixed-effects model fit by maximum likelihood\n  Data: structure(list(age11 = c(-3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3), Subject = structure(c(15L, 15L,  15L, 15L, 3L, 3L, 3L, 3L, 7L, 7L, 7L, 7L, 14L, 14L, 14L, 14L,  2L, 2L, 2L, 2L, 13L, 13L, 13L, 13L, 5L, 5L, 5L, 5L, 6L, 6L, 6L,  6L, 11L, 11L, 11L, 11L, 16L, 16L, 16L, 16L, 4L, 4L, 4L, 4L, 8L,  8L, 8L, 8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 12L, 12L, 12L,  12L, 1L, 1L, 1L, 1L, 20L, 20L, 20L, 20L, 23L, 23L, 23L, 23L,  25L, 25L, 25L, 25L, 26L, 26L, 26L, 26L, 21L, 21L, 21L, 21L, 19L,  19L, 19L, 19L, 22L, 22L, 22L, 22L, 24L, 24L, 24L, 24L, 18L, 18L,  18L, 18L, 17L, 17L, 17L, 17L, 27L, 27L, 27L, 27L), levels = c(\"M16\",  \"M05\", \"M02\", \"M11\", \"M07\", \"M08\", \"M03\", \"M12\", \"M13\", \"M14\",  \"M09\", \"M15\", \"M06\", \"M04\", \"M01\", \"M10\", \"F10\", \"F09\", \"F06\",  \"F01\", \"F05\", \"F07\", \"F02\", \"F08\", \"F03\", \"F04\", \"F11\"), class = c(\"ordered\",  \"factor\")), response_z = c(3.95740740740771, 1.63703703703704,  4.31666666666667, 4.9962962962963, -0.542592592592602, -0.862962962962968,  -1.68333333333333, 0.496296296296297, 0.957407407407398, -0.862962962962968,  -0.683333333333334, 1.4962962962963, 3.4574074074074, 4.13703703703703,  1.81666666666666, 0.996296296296297, -2.0425925925926, 0.137037037037032,  -2.18333333333333, -0.00370370370369955, 2.4574074074074, 2.13703703703704,  2.31666666666666, 2.4962962962963, -0.0425925925926016, -1.36296296296297,  -0.183333333333334, 0.496296296296297, 1.9574074074074, -1.86296296296297,  -0.183333333333334, -0.5037037037037, 0.957407407407398, -2.86296296296297,  6.31666666666666, -0.00370370370369955, 5.45740740740739, 4.63703703703703,  6.31666666666666, 5.49629629629629, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -1.0037037037037, -0.542592592592602, 0.137037037037032,  -0.683333333333334, 1.9962962962963, -5.0425925925926, 1.13703703703703,  1.31666666666667, 3.4962962962963, 0.457407407407402, 2.13703703703704,  0.81666666666667, -0.00370370370369955, 0.957407407407402, 1.13703703703703,  1.31666666666667, 3.9962962962963, -0.0425925925926016, -1.86296296296297,  -1.18333333333333, -1.0037037037037, -1.0425925925926, -3.36296296296297,  -3.18333333333333, -3.0037037037037, -1.0425925925926, -1.86296296296297,  -0.683333333333334, -0.5037037037037, -1.5425925925926, 0.637037037037032,  -0.183333333333334, -0.00370370370369955, 1.4574074074074, 1.13703703703703,  0.316666666666666, 0.496296296296297, -0.542592592592602, -0.362962962962968,  -2.18333333333333, -2.5037037037037, -2.0425925925926, -2.36296296296297,  -3.68333333333334, -3.5037037037037, -0.542592592592602, -0.862962962962968,  -1.68333333333333, -1.0037037037037, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -2.0037037037037, -2.04259259259261, -2.36296296296297,  -2.68333333333333, -4.5037037037037, -5.5425925925926, -4.36296296296297,  -5.68333333333334, -6.5037037037037, 2.4574074074074, 1.63703703703704,  3.31666666666666, 1.9962962962963), weights_w = c(0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369)), terms = ~age11 +      Subject, row.names = c(NA, 108L), class = \"data.frame\") \n       AIC      BIC    logLik\n  449.2116 462.6223 -219.6058\n\nRandom effects:\n Formula: ~age11 | Subject\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 2.0906352 (Intr)\nage11       0.2149235 0.521 \nResidual    3.8365552       \n\nVariance function:\n Structure: fixed weights\n Formula: ~weights_w \nFixed effects:  response_z ~ 1 \n                   Value Std.Error DF      t-value p-value\n(Intercept) 6.064444e-16 0.4048917 81 1.497794e-15       1\n\nStandardized Within-Group Residuals:\n         Min           Q1          Med           Q3          Max \n-3.305976369 -0.487428882  0.007598099  0.482237876  3.922787577 \n\nNumber of Observations: 108\nNumber of Groups: 27 \n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4092 eps = 0.133537     \nGAMLSS-RS iteration  3: Global Deviance = 340.4591 eps = 0.080856     \nGAMLSS-RS iteration  4: Global Deviance = 325.4834 eps = 0.043986     \nGAMLSS-RS iteration  5: Global Deviance = 319.1487 eps = 0.019462     \nGAMLSS-RS iteration  6: Global Deviance = 316.6824 eps = 0.007727     \nGAMLSS-RS iteration  7: Global Deviance = 315.7553 eps = 0.002927     \nGAMLSS-RS iteration  8: Global Deviance = 315.4122 eps = 0.001086     \nGAMLSS-RS iteration  9: Global Deviance = 315.2857 eps = 0.000401     \nGAMLSS-RS iteration 10: Global Deviance = 315.2397 eps = 0.000145     \nGAMLSS-RS iteration 11: Global Deviance = 315.2211 eps = 0.000059     \nGAMLSS-RS iteration 12: Global Deviance = 315.2141 eps = 0.000022     \nGAMLSS-RS iteration 13: Global Deviance = 315.2112 eps = 0.000009     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ sin1 + cos1 +\n  re(~ 1 | Mare) +\n  re(~ sin1 - 1 | Mare, correlation = corARMA(q = 2))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1561.4397 eps = 0.164702     \nGAMLSS-RS iteration  2: Global Deviance = 1561.3891 eps = 0.000032     \nGAMLSS-RS iteration  3: Global Deviance = 1561.3816 eps = 0.000004     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.5015 eps = 0.056241     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6605 eps = 0.006850     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7658 eps = 0.000627     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6839 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6744 eps = 0.000006     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n}\n\n## simulated data\nset.seed(1328)\n\nn &lt;- 10000\nk &lt;- 500\n\n## generate random effects\nf &lt;- as.factor(sample(1:k, size = n, replace = TRUE))\nref &lt;- rnorm(k, sd = 0.6)\n\n## random effects only for sigma\ny &lt;- rBCT(n, mu = 10, sigma = exp(-1 + ref[f]), tau = 10)\n\n## estimate model\nb &lt;- gamlss2(y ~ 1 | re(~ 1 | f), family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 54284.8778 eps = 0.443825     \nGAMLSS-RS iteration  2: Global Deviance = 53798.1163 eps = 0.008966     \nGAMLSS-RS iteration  3: Global Deviance = 53767.8702 eps = 0.000562     \nGAMLSS-RS iteration  4: Global Deviance = 53761.3751 eps = 0.000120     \nGAMLSS-RS iteration  5: Global Deviance = 53758.2934 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 53757.5692 eps = 0.000013     \nGAMLSS-RS iteration  7: Global Deviance = 53756.9982 eps = 0.000010     \nGAMLSS-RS iteration  8: Global Deviance = 53756.5246 eps = 0.000008     \n\n## extract fitted random effects\ncb &lt;- coef(b, full = TRUE)\ncb &lt;- cb[grepl(\"re\", names(cb), fixed = TRUE)]\n\n## compare\nplot(cb, ref, main = round(mean((cb - ref)^2), 2))\nabline(0, 1, lwd = 2, col = 4)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "random"
    ]
  },
  {
    "objectID": "man/calibration.html",
    "href": "man/calibration.html",
    "title": "gamlss2",
    "section": "",
    "text": "Compute and plot calibration curves for models with 0/1 responses. The function can handle one or several fitted gamlss2 models and compares their calibration in a single plot.\n\n\n\ncalibration(..., newdata = NULL,\n  y = NULL, model = NULL, breaks = seq(0, 1, by = 0.1),\n  minn = 20, main = \"Calibration plot\",\n  xlab = \"Predicted probability\",\n  ylab = \"Observed proportion\", plot = TRUE,\n  add_loess = TRUE, smooth_n = 200,\n  col = NULL, lty = NULL, legend = TRUE, pos = \"topleft\",\n  xlim = NULL, ylim = NULL)\n\n\n\n\n\n\n\n…\n\n\nOne or several fitted gamlss2 model objects to be assessed.\n\n\n\n\nnewdata\n\n\nOptional data frame for out-of-sample calibration. If supplied, predictions and (optionally) the response y are evaluated on newdata.\n\n\n\n\ny\n\n\nOptional numeric or factor vector with the binary response (coded as 0/1 or a two-level factor). If omitted, the response is extracted from the first model.\n\n\n\n\nmodel\n\n\nCharacter, which parameter should be used for prediction. Typically “mu” for binary models.\n\n\n\n\nbreaks\n\n\nNumeric vector of break points used to construct bins for the predicted probabilities. The range of breaks must cover the interval [0, 1].\n\n\n\n\nminn\n\n\nInteger, the minimum number of observations required in each bin. Bins with fewer observations are dropped from the calibration curve.\n\n\n\n\nmain\n\n\nCharacter, main title for the plot.\n\n\n\n\nxlab\n\n\nCharacter, label for the x-axis (predicted probabilities).\n\n\n\n\nylab\n\n\nCharacter, label for the y-axis (observed proportions).\n\n\n\n\nplot\n\n\nLogical, should a calibration plot be produced? If FALSE, only the aggregated calibration data are returned.\n\n\n\n\nadd_loess\n\n\nLogical, should a loess smooth be added for each model?\n\n\n\n\nsmooth_n\n\n\nInteger, number of evaluation points for the loess curve.\n\n\n\n\ncol\n\n\nEither NULL, a function, or a vector of colors. If NULL, distinct colors are generated via colorspace::qualitative_hcl(). If a function, it is called with the number of models to generate colors. Otherwise, a vector of colors is recycled to the number of models.\n\n\n\n\nlty\n\n\nInteger vector of line types used for the loess curves. If NULL, different line types are used for each model and recycled if necessary.\n\n\n\n\nlegend\n\n\nLogical, should a legend be added when more than one model is supplied?\n\n\n\n\npos\n\n\nCharacter, the position of the legend passed to legend.\n\n\n\n\nxlim\n\n\nThe x limits of the plot.\n\n\n\n\nylim\n\n\nThe y limits of the plot.\n\n\n\n\n\n\nFor each fitted model, predicted probabilities for \\(P(Y = 1 | X)\\) are obtained via predict with type = “parameter” and the requested model argument, if supplied. If the corresponding gamlss2.family object provides a probabilities method, this is used to transform the parameter vector into class probabilities. For families with more than two outcome categories, the first column is taken as the probability of the event.\nThe predicted probabilities are then grouped into bins defined by breaks. Within each bin, the mean predicted probability and the observed proportion of 1s are computed, together with the number of observations in the bin. Bins with fewer than minn observations are dropped. The resulting points are plotted with size proportional to the square root of the bin size, and a reference line with slope 1 and intercept 0 is added for perfect calibration. Optionally, a loess smooth is fitted to the binned data for each model and added as a calibration curve.\nIf multiple models are supplied, the binned calibration points and loess curves of all models are shown in the same plot, with different colors and line types. This allows a direct visual comparison of calibration across competing gamlss2 specifications.\n\n\n\nInvisibly returns a data frame with the following columns:\n\n\ninterval: Factor with the probability intervals.\n\n\nprobs: Mean predicted probability in each bin.\n\n\ny: Observed proportion of 1s in each bin.\n\n\nn: Number of observations in each bin.\n\n\nmodel: Character, model label. For a single model this column is dropped from the returned data frame.\n\n\nIf plot = FALSE, the same data frame is returned without producing a plot.\n\n\n\nVan Calster B, McLernon DJ, van Smeden M, Wynants L, Steyerberg EW (2019). Calibration: the Achilles heel of predictive analytics. BMC Medicine, 17, 230. doi:10.1186/s12916-019-1466-7\nSteyerberg EW (2019). Clinical Prediction Models: A Practical Approach to Development, Validation, and Updating. 2nd edition. Springer, New York.\n\n\n\ngamlss2, predict, legend.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## and compare two models\nset.seed(123)\nn &lt;- 1000\nx1 &lt;- runif(n, -3, 3)\nx2 &lt;- runif(n, -3, 3)\neta &lt;- sin(x1) + 0.5 * x2\np &lt;- plogis(eta)\ny &lt;- rbinom(n, size = 1, prob = p)\nd &lt;- data.frame(y = y, x1 = x1, x2 = x2)\n\n## fit three competing models\nm1 &lt;- gamlss2(y ~ x1, family = BI, data = d)\nm2 &lt;- gamlss2(y ~ s(x1), family = BI, data = d)\nm3 &lt;- gamlss2(y ~ s(x1) + x2, family = BI, data = d)\n\n## calibration on the training data\ncalibration(m1, m2, m3)\n\n## extract calibration data without plotting\ncal_tab &lt;- calibration(m1, m2, m3, plot = FALSE)\nhead(cal_tab)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "calibration"
    ]
  },
  {
    "objectID": "man/calibration.html#calibration-plots-for-binary-responses",
    "href": "man/calibration.html#calibration-plots-for-binary-responses",
    "title": "gamlss2",
    "section": "",
    "text": "Compute and plot calibration curves for models with 0/1 responses. The function can handle one or several fitted gamlss2 models and compares their calibration in a single plot.\n\n\n\ncalibration(..., newdata = NULL,\n  y = NULL, model = NULL, breaks = seq(0, 1, by = 0.1),\n  minn = 20, main = \"Calibration plot\",\n  xlab = \"Predicted probability\",\n  ylab = \"Observed proportion\", plot = TRUE,\n  add_loess = TRUE, smooth_n = 200,\n  col = NULL, lty = NULL, legend = TRUE, pos = \"topleft\",\n  xlim = NULL, ylim = NULL)\n\n\n\n\n\n\n\n…\n\n\nOne or several fitted gamlss2 model objects to be assessed.\n\n\n\n\nnewdata\n\n\nOptional data frame for out-of-sample calibration. If supplied, predictions and (optionally) the response y are evaluated on newdata.\n\n\n\n\ny\n\n\nOptional numeric or factor vector with the binary response (coded as 0/1 or a two-level factor). If omitted, the response is extracted from the first model.\n\n\n\n\nmodel\n\n\nCharacter, which parameter should be used for prediction. Typically “mu” for binary models.\n\n\n\n\nbreaks\n\n\nNumeric vector of break points used to construct bins for the predicted probabilities. The range of breaks must cover the interval [0, 1].\n\n\n\n\nminn\n\n\nInteger, the minimum number of observations required in each bin. Bins with fewer observations are dropped from the calibration curve.\n\n\n\n\nmain\n\n\nCharacter, main title for the plot.\n\n\n\n\nxlab\n\n\nCharacter, label for the x-axis (predicted probabilities).\n\n\n\n\nylab\n\n\nCharacter, label for the y-axis (observed proportions).\n\n\n\n\nplot\n\n\nLogical, should a calibration plot be produced? If FALSE, only the aggregated calibration data are returned.\n\n\n\n\nadd_loess\n\n\nLogical, should a loess smooth be added for each model?\n\n\n\n\nsmooth_n\n\n\nInteger, number of evaluation points for the loess curve.\n\n\n\n\ncol\n\n\nEither NULL, a function, or a vector of colors. If NULL, distinct colors are generated via colorspace::qualitative_hcl(). If a function, it is called with the number of models to generate colors. Otherwise, a vector of colors is recycled to the number of models.\n\n\n\n\nlty\n\n\nInteger vector of line types used for the loess curves. If NULL, different line types are used for each model and recycled if necessary.\n\n\n\n\nlegend\n\n\nLogical, should a legend be added when more than one model is supplied?\n\n\n\n\npos\n\n\nCharacter, the position of the legend passed to legend.\n\n\n\n\nxlim\n\n\nThe x limits of the plot.\n\n\n\n\nylim\n\n\nThe y limits of the plot.\n\n\n\n\n\n\nFor each fitted model, predicted probabilities for \\(P(Y = 1 | X)\\) are obtained via predict with type = “parameter” and the requested model argument, if supplied. If the corresponding gamlss2.family object provides a probabilities method, this is used to transform the parameter vector into class probabilities. For families with more than two outcome categories, the first column is taken as the probability of the event.\nThe predicted probabilities are then grouped into bins defined by breaks. Within each bin, the mean predicted probability and the observed proportion of 1s are computed, together with the number of observations in the bin. Bins with fewer than minn observations are dropped. The resulting points are plotted with size proportional to the square root of the bin size, and a reference line with slope 1 and intercept 0 is added for perfect calibration. Optionally, a loess smooth is fitted to the binned data for each model and added as a calibration curve.\nIf multiple models are supplied, the binned calibration points and loess curves of all models are shown in the same plot, with different colors and line types. This allows a direct visual comparison of calibration across competing gamlss2 specifications.\n\n\n\nInvisibly returns a data frame with the following columns:\n\n\ninterval: Factor with the probability intervals.\n\n\nprobs: Mean predicted probability in each bin.\n\n\ny: Observed proportion of 1s in each bin.\n\n\nn: Number of observations in each bin.\n\n\nmodel: Character, model label. For a single model this column is dropped from the returned data frame.\n\n\nIf plot = FALSE, the same data frame is returned without producing a plot.\n\n\n\nVan Calster B, McLernon DJ, van Smeden M, Wynants L, Steyerberg EW (2019). Calibration: the Achilles heel of predictive analytics. BMC Medicine, 17, 230. doi:10.1186/s12916-019-1466-7\nSteyerberg EW (2019). Clinical Prediction Models: A Practical Approach to Development, Validation, and Updating. 2nd edition. Springer, New York.\n\n\n\ngamlss2, predict, legend.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## and compare two models\nset.seed(123)\nn &lt;- 1000\nx1 &lt;- runif(n, -3, 3)\nx2 &lt;- runif(n, -3, 3)\neta &lt;- sin(x1) + 0.5 * x2\np &lt;- plogis(eta)\ny &lt;- rbinom(n, size = 1, prob = p)\nd &lt;- data.frame(y = y, x1 = x1, x2 = x2)\n\n## fit three competing models\nm1 &lt;- gamlss2(y ~ x1, family = BI, data = d)\nm2 &lt;- gamlss2(y ~ s(x1), family = BI, data = d)\nm3 &lt;- gamlss2(y ~ s(x1) + x2, family = BI, data = d)\n\n## calibration on the training data\ncalibration(m1, m2, m3)\n\n## extract calibration data without plotting\ncal_tab &lt;- calibration(m1, m2, m3, plot = FALSE)\nhead(cal_tab)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "calibration"
    ]
  },
  {
    "objectID": "man/modelstats.html",
    "href": "man/modelstats.html",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nWhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, or “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple”, the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above by\n\n\\(1 - L(0)^{2/n}\\)\nNote that GAIC() function is fully represented by the AIC and BIC functions. We only included GAIC() because of the previous package so users who relied on this function would still have the option.\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 408.2379 eps = 0.294520     \nGAMLSS-RS iteration  2: Global Deviance = 377.3934 eps = 0.075555     \nGAMLSS-RS iteration  3: Global Deviance = 374.3484 eps = 0.008068     \nGAMLSS-RS iteration  4: Global Deviance = 374.1042 eps = 0.000652     \nGAMLSS-RS iteration  5: Global Deviance = 374.1005 eps = 0.000009     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9863321 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 398.7415 12.32052\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 398.7415 12.32052\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        BIC       df\nb2 421.0005 12.32052\nb1 515.4773  6.00000",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "modelstats"
    ]
  },
  {
    "objectID": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "href": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nWhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, or “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple”, the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above by\n\n\\(1 - L(0)^{2/n}\\)\nNote that GAIC() function is fully represented by the AIC and BIC functions. We only included GAIC() because of the previous package so users who relied on this function would still have the option.\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 408.2379 eps = 0.294520     \nGAMLSS-RS iteration  2: Global Deviance = 377.3934 eps = 0.075555     \nGAMLSS-RS iteration  3: Global Deviance = 374.3484 eps = 0.008068     \nGAMLSS-RS iteration  4: Global Deviance = 374.1042 eps = 0.000652     \nGAMLSS-RS iteration  5: Global Deviance = 374.1005 eps = 0.000009     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9863321 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 398.7415 12.32052\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 398.7415 12.32052\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        BIC       df\nb2 421.0005 12.32052\nb1 515.4773  6.00000",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "modelstats"
    ]
  },
  {
    "objectID": "man/quantiles.html",
    "href": "man/quantiles.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "quantiles"
    ]
  },
  {
    "objectID": "man/quantiles.html#quantiles-for-gamlss",
    "href": "man/quantiles.html#quantiles-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "quantiles"
    ]
  },
  {
    "objectID": "man/SpirometryUS.html",
    "href": "man/SpirometryUS.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various spirometry measurements from the National Health and Nutrition Examination Survey (NHANES) 2007–2012 along with covariates providing demographics and basic body measurements.\n\n\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\n\n\n\nA data frame containing 16596 observations on 13 variables.\n\n\nfvc\n\n\nNumeric. Forced vital capacity (FVC) in liters, i.e., the volume of air that can forcibly be blown out after full inspiration.\n\n\nfev1\n\n\nNumeric. Forced expiratory volume in 1 second (FEV1) in liters, i.e., the volume of air that can forcibly be blown out in the first second, after full inspiration.\n\n\nratio\n\n\nNumeric. Ratio of FEV1 to FVC.\n\n\npef\n\n\nNumeric, peak expiratory flow (PEF) in liters per second, i.e., the maximal flow (or speed) achieved during the maximally forced expiration initiated at full inspiration.\n\n\nfef\n\n\nNumeric. Forced expiratory flow (FEF) in liters per second, i.e., the flow (or speed) of air coming out of the lung during the middle portion (25% to 75%) of a forced expiration.\n\n\nvolume\n\n\nNumeric. Extrapolated volume.\n\n\nfet\n\n\nNumeric. Forced expiratory time (FET) in seconds, i.e., the length of the expiration.\n\n\ngender\n\n\nFactor. Binary gender information with levels female and male.\n\n\nage\n\n\nNumeric. Age in years (rounded to quarters).\n\n\nweight\n\n\nNumeric. Body weight in kilograms.\n\n\nheight\n\n\nNumeric. Body height in centimeters.\n\n\nbmi\n\n\nNumeric. Body mass index in kilograms per meter-squared, rounded to 2 decimal places.\n\n\nethnicity\n\n\nFactor. Self-reported race and ethnicity information with levels white, black, mexican American, other hispanic, and other (including multi-racial).\n\n\nsurveyweight\n\n\nNumeric. Full sample two-year exam survey weight.\n\n\n\n\n\nIn order to establish lung function reference equations, Zavorsky (2025) studies the dependence of three spirometry measurements (FVC, FEV1, and the FEV1/FVC ratio) on age, adjusted for height and weight and separately for females and males. He intends to show that a simple normally-distributed model with (piecewise) linear mean equation and (piecewise) constant variance suffices for obtaining an adequate distributional fit from which the 5% quantile can be obtained as the so-called lower limit of normal (LLN). Actually, his comparison with GAMLSS – using flexible predictors for both mean and variance along with a Box-Cox-transformed normal distribution – shows that GAMLSS leads to a similar fit for the mean but a much better fit for the LLN.\nZavorsky’s (2025) analyses are based on a data set that he derived from the National Health and Nutrition Examination Survey (NHANES) in the United States 2007–2012. From the entire available data from https://wwwn.cdc.gov/nchs/nhanes/ he included those observations which met or exceeded the technical acceptability of the measurements for forced expiratory volume in 1 second (FEV1) and forced vital capacity (FVC). The data are described in a short communication published in the Data in Brief journal and the accompanying spreadsheet in CSV format (comma-separated values) is available from Mendeley Data.\nThe data comprises observations from NHANES’ “Examination Data”, in particular in “Spirometry – Pre and Post-Bronchodilator” and “Body Measures”, plus accompanying “Demographics Data”. Respondent sequence numbers are stored as row names. See the variable descriptions above for more details. Basic information about spirometry can be found for example in the Wikipedia at https://en.wikipedia.org/wiki/Spirometry.\n\n\n\nZavorsky GS (2024). “Refined NHANES 2007–2012 Spirometry Dataset for the Comparison of Segmented (Piecewise) Linear Models to That of GAMLSS”, Mendeley Data, V1. doi:10.17632/dwjykg3xww.1\n\n\n\nZavorsky GS (2024). “A Refined Spirometry Dataset for Comparing Segmented (Piecewise) Linear Models to that of GAMLSS”. Data in Brief, 57, 111062. doi:10.1016/j.dib.2024.111062\nZavorsky GS (2025). “Debunking the GAMLSS Myth: Simplicity Reigns in Pulmonary Function Diagnostics”. Respiratory Medicine, 236, 107836. doi:10.1016/j.rmed.2024.107836\n\n\n\n\nlibrary(\"gamlss2\")\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\nsummary(SpirometryUS)\n\n      fvc             fev1           ratio             pef        \n Min.   :0.704   Min.   :0.476   Min.   :0.2913   Min.   : 0.901  \n 1st Qu.:2.815   1st Qu.:2.224   1st Qu.:0.7604   1st Qu.: 5.816  \n Median :3.630   Median :2.910   Median :0.8147   Median : 7.418  \n Mean   :3.676   Mean   :2.948   Mean   :0.8064   Mean   : 7.506  \n 3rd Qu.:4.480   3rd Qu.:3.598   3rd Qu.:0.8620   3rd Qu.: 9.150  \n Max.   :9.361   Max.   :6.923   Max.   :1.0000   Max.   :19.024  \n      fef            volume            fet            gender    \n Min.   :0.010   Min.   :  0.00   Min.   : 1.200   Male  :8293  \n 1st Qu.:1.986   1st Qu.: 52.00   1st Qu.: 7.700   Female:8303  \n Median :2.832   Median : 69.00   Median : 9.000                \n Mean   :2.942   Mean   : 76.18   Mean   : 9.693                \n 3rd Qu.:3.774   3rd Qu.: 93.00   3rd Qu.:11.500                \n Max.   :9.280   Max.   :321.00   Max.   :32.800                \n      age            weight           height         ethnicity   \n Min.   : 6.00   Min.   : 16.40   Min.   :104.6   white   :6607  \n 1st Qu.:17.00   1st Qu.: 57.20   1st Qu.:155.9   black   :3598  \n Median :34.00   Median : 72.30   Median :164.8   mexican :3068  \n Mean   :35.89   Mean   : 72.97   Mean   :162.9   hispanic:1825  \n 3rd Qu.:53.00   3rd Qu.: 88.20   3rd Qu.:173.2   other   :1498  \n Max.   :80.00   Max.   :218.20   Max.   :203.8                  \n      bmi         surveyweight   \n Min.   :12.50   Min.   :  3723  \n 1st Qu.:21.67   1st Qu.: 14356  \n Median :26.06   Median : 23317  \n Mean   :26.82   Mean   : 36368  \n 3rd Qu.:30.90   3rd Qu.: 48387  \n Max.   :84.87   Max.   :222580",
    "crumbs": [
      "Documentation",
      "Data",
      "SpirometryUS"
    ]
  },
  {
    "objectID": "man/SpirometryUS.html#spirometry-measurements-from-nhanes-20072012",
    "href": "man/SpirometryUS.html#spirometry-measurements-from-nhanes-20072012",
    "title": "gamlss2",
    "section": "",
    "text": "Various spirometry measurements from the National Health and Nutrition Examination Survey (NHANES) 2007–2012 along with covariates providing demographics and basic body measurements.\n\n\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\n\n\n\nA data frame containing 16596 observations on 13 variables.\n\n\nfvc\n\n\nNumeric. Forced vital capacity (FVC) in liters, i.e., the volume of air that can forcibly be blown out after full inspiration.\n\n\nfev1\n\n\nNumeric. Forced expiratory volume in 1 second (FEV1) in liters, i.e., the volume of air that can forcibly be blown out in the first second, after full inspiration.\n\n\nratio\n\n\nNumeric. Ratio of FEV1 to FVC.\n\n\npef\n\n\nNumeric, peak expiratory flow (PEF) in liters per second, i.e., the maximal flow (or speed) achieved during the maximally forced expiration initiated at full inspiration.\n\n\nfef\n\n\nNumeric. Forced expiratory flow (FEF) in liters per second, i.e., the flow (or speed) of air coming out of the lung during the middle portion (25% to 75%) of a forced expiration.\n\n\nvolume\n\n\nNumeric. Extrapolated volume.\n\n\nfet\n\n\nNumeric. Forced expiratory time (FET) in seconds, i.e., the length of the expiration.\n\n\ngender\n\n\nFactor. Binary gender information with levels female and male.\n\n\nage\n\n\nNumeric. Age in years (rounded to quarters).\n\n\nweight\n\n\nNumeric. Body weight in kilograms.\n\n\nheight\n\n\nNumeric. Body height in centimeters.\n\n\nbmi\n\n\nNumeric. Body mass index in kilograms per meter-squared, rounded to 2 decimal places.\n\n\nethnicity\n\n\nFactor. Self-reported race and ethnicity information with levels white, black, mexican American, other hispanic, and other (including multi-racial).\n\n\nsurveyweight\n\n\nNumeric. Full sample two-year exam survey weight.\n\n\n\n\n\nIn order to establish lung function reference equations, Zavorsky (2025) studies the dependence of three spirometry measurements (FVC, FEV1, and the FEV1/FVC ratio) on age, adjusted for height and weight and separately for females and males. He intends to show that a simple normally-distributed model with (piecewise) linear mean equation and (piecewise) constant variance suffices for obtaining an adequate distributional fit from which the 5% quantile can be obtained as the so-called lower limit of normal (LLN). Actually, his comparison with GAMLSS – using flexible predictors for both mean and variance along with a Box-Cox-transformed normal distribution – shows that GAMLSS leads to a similar fit for the mean but a much better fit for the LLN.\nZavorsky’s (2025) analyses are based on a data set that he derived from the National Health and Nutrition Examination Survey (NHANES) in the United States 2007–2012. From the entire available data from https://wwwn.cdc.gov/nchs/nhanes/ he included those observations which met or exceeded the technical acceptability of the measurements for forced expiratory volume in 1 second (FEV1) and forced vital capacity (FVC). The data are described in a short communication published in the Data in Brief journal and the accompanying spreadsheet in CSV format (comma-separated values) is available from Mendeley Data.\nThe data comprises observations from NHANES’ “Examination Data”, in particular in “Spirometry – Pre and Post-Bronchodilator” and “Body Measures”, plus accompanying “Demographics Data”. Respondent sequence numbers are stored as row names. See the variable descriptions above for more details. Basic information about spirometry can be found for example in the Wikipedia at https://en.wikipedia.org/wiki/Spirometry.\n\n\n\nZavorsky GS (2024). “Refined NHANES 2007–2012 Spirometry Dataset for the Comparison of Segmented (Piecewise) Linear Models to That of GAMLSS”, Mendeley Data, V1. doi:10.17632/dwjykg3xww.1\n\n\n\nZavorsky GS (2024). “A Refined Spirometry Dataset for Comparing Segmented (Piecewise) Linear Models to that of GAMLSS”. Data in Brief, 57, 111062. doi:10.1016/j.dib.2024.111062\nZavorsky GS (2025). “Debunking the GAMLSS Myth: Simplicity Reigns in Pulmonary Function Diagnostics”. Respiratory Medicine, 236, 107836. doi:10.1016/j.rmed.2024.107836\n\n\n\n\nlibrary(\"gamlss2\")\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\nsummary(SpirometryUS)\n\n      fvc             fev1           ratio             pef        \n Min.   :0.704   Min.   :0.476   Min.   :0.2913   Min.   : 0.901  \n 1st Qu.:2.815   1st Qu.:2.224   1st Qu.:0.7604   1st Qu.: 5.816  \n Median :3.630   Median :2.910   Median :0.8147   Median : 7.418  \n Mean   :3.676   Mean   :2.948   Mean   :0.8064   Mean   : 7.506  \n 3rd Qu.:4.480   3rd Qu.:3.598   3rd Qu.:0.8620   3rd Qu.: 9.150  \n Max.   :9.361   Max.   :6.923   Max.   :1.0000   Max.   :19.024  \n      fef            volume            fet            gender    \n Min.   :0.010   Min.   :  0.00   Min.   : 1.200   Male  :8293  \n 1st Qu.:1.986   1st Qu.: 52.00   1st Qu.: 7.700   Female:8303  \n Median :2.832   Median : 69.00   Median : 9.000                \n Mean   :2.942   Mean   : 76.18   Mean   : 9.693                \n 3rd Qu.:3.774   3rd Qu.: 93.00   3rd Qu.:11.500                \n Max.   :9.280   Max.   :321.00   Max.   :32.800                \n      age            weight           height         ethnicity   \n Min.   : 6.00   Min.   : 16.40   Min.   :104.6   white   :6607  \n 1st Qu.:17.00   1st Qu.: 57.20   1st Qu.:155.9   black   :3598  \n Median :34.00   Median : 72.30   Median :164.8   mexican :3068  \n Mean   :35.89   Mean   : 72.97   Mean   :162.9   hispanic:1825  \n 3rd Qu.:53.00   3rd Qu.: 88.20   3rd Qu.:173.2   other   :1498  \n Max.   :80.00   Max.   :218.20   Max.   :203.8                  \n      bmi         surveyweight   \n Min.   :12.50   Min.   :  3723  \n 1st Qu.:21.67   1st Qu.: 14356  \n Median :26.06   Median : 23317  \n Mean   :26.82   Mean   : 36368  \n 3rd Qu.:30.90   3rd Qu.: 48387  \n Max.   :84.87   Max.   :222580",
    "crumbs": [
      "Documentation",
      "Data",
      "SpirometryUS"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html",
    "href": "man/HarzTraffic.html",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.1249 eps = 0.148398     \nGAMLSS-RS iteration  2: Global Deviance = 10151.6273 eps = 0.001131     \nGAMLSS-RS iteration  3: Global Deviance = 10151.3662 eps = 0.000025     \nGAMLSS-RS iteration  4: Global Deviance = 10151.2887 eps = 0.000007     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\n\n## corresponding quantiles\np &lt;- quantile(m, newdata = nd, probs = c(0.05, 0.5, 0.95))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Data",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "href": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.1249 eps = 0.148398     \nGAMLSS-RS iteration  2: Global Deviance = 10151.6273 eps = 0.001131     \nGAMLSS-RS iteration  3: Global Deviance = 10151.3662 eps = 0.000025     \nGAMLSS-RS iteration  4: Global Deviance = 10151.2887 eps = 0.000007     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\n\n## corresponding quantiles\np &lt;- quantile(m, newdata = nd, probs = c(0.05, 0.5, 0.95))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Data",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/cv_gamlss2.html",
    "href": "man/cv_gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "cv_gamlss2() implements K-fold cross validation for models fitted with gamlss2. Different scoring rules can be supplied via the metric argument. Convenience metric functions (log_pdf_metric(), rqres_metric(), mse_metric()) are provided.\n\n\n\n## K-fold cross-validation\ncv_gamlss2(..., data, folds = 5,\n  metric = log_pdf_metric, parallel = FALSE, simplify = TRUE)\n\n## log-pdf for each observation\nlog_pdf_metric(model, data)\n\n## randomized quantile residuals\nrqres_metric(model, data)\n\n## mean squared error\nmse_metric(model, data)\n\n\n\n\n\n\n\n…\n\n\nmodel specification passed to gamlss2 such as formula, family, etc.\n\n\n\n\ndata\n\n\na data.frame containing the variables in the model. For functions supplied to argument metric, a data.frame for evaluating predictions or residuals.\n\n\n\n\nfolds\n\n\neither an integer specifying the number of folds, or a list, matrix, or data frame of index sets for test folds. Defaults to 5.\n\n\n\n\nmetric\n\n\na function of the form metric(model, data) returning a score for the given fitted model and test data. Defaults to log_pdf_metric.\n\n\n\n\nparallel\n\n\nlogical. If TRUE, computation is carried out in parallel using future.apply.\n\n\n\n\nsimplify\n\n\nlogical. If TRUE, results are returned in a simplified vector or data frame depending on the metric output.\n\n\n\n\nmodel\n\n\na fitted gamlss2 model.\n\n\n\n\n\n\ncv_gamlss2() splits the data into training and test folds. For each fold the model is fitted on the training data, and the chosen metric is evaluated on the held-out test data. By default, the scoring rule is the log predictive density (log_pdf_metric), but other metrics can be used, such as randomized quantile residuals (rqres_metric) or mean squared error of the conditional mean (mse_metric).\nThe function returns either a list of fold-wise results or, if simplify = TRUE, a named vector or data frame aligned with the original observations.\n\n\n\nIf simplify = TRUE and the metric returns scalars, a named numeric vector of fold scores is returned. Otherwise a data frame with fold membership and scores per observation is returned.\nThe convenience metrics return a numeric vector of scores or residuals.\n\n\n\ngamlss2, log_pdf\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## cross-validation using the NO distribution\n## only model the mean with s(x)\ncv1 &lt;- cv_gamlss2(y ~ s(x), data = abdom, family = NO)\n\n## now, also model the standard deviation with s(x)\ncv2 &lt;- cv_gamlss2(y ~ s(x) | s(x), data = abdom, family = BCT)\n\n## evaluate log-likelihood\nsum(cv1$score)\nsum(cv2$score)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "cv_gamlss2"
    ]
  },
  {
    "objectID": "man/cv_gamlss2.html#cross-validation-for-gamlss2-models",
    "href": "man/cv_gamlss2.html#cross-validation-for-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "cv_gamlss2() implements K-fold cross validation for models fitted with gamlss2. Different scoring rules can be supplied via the metric argument. Convenience metric functions (log_pdf_metric(), rqres_metric(), mse_metric()) are provided.\n\n\n\n## K-fold cross-validation\ncv_gamlss2(..., data, folds = 5,\n  metric = log_pdf_metric, parallel = FALSE, simplify = TRUE)\n\n## log-pdf for each observation\nlog_pdf_metric(model, data)\n\n## randomized quantile residuals\nrqres_metric(model, data)\n\n## mean squared error\nmse_metric(model, data)\n\n\n\n\n\n\n\n…\n\n\nmodel specification passed to gamlss2 such as formula, family, etc.\n\n\n\n\ndata\n\n\na data.frame containing the variables in the model. For functions supplied to argument metric, a data.frame for evaluating predictions or residuals.\n\n\n\n\nfolds\n\n\neither an integer specifying the number of folds, or a list, matrix, or data frame of index sets for test folds. Defaults to 5.\n\n\n\n\nmetric\n\n\na function of the form metric(model, data) returning a score for the given fitted model and test data. Defaults to log_pdf_metric.\n\n\n\n\nparallel\n\n\nlogical. If TRUE, computation is carried out in parallel using future.apply.\n\n\n\n\nsimplify\n\n\nlogical. If TRUE, results are returned in a simplified vector or data frame depending on the metric output.\n\n\n\n\nmodel\n\n\na fitted gamlss2 model.\n\n\n\n\n\n\ncv_gamlss2() splits the data into training and test folds. For each fold the model is fitted on the training data, and the chosen metric is evaluated on the held-out test data. By default, the scoring rule is the log predictive density (log_pdf_metric), but other metrics can be used, such as randomized quantile residuals (rqres_metric) or mean squared error of the conditional mean (mse_metric).\nThe function returns either a list of fold-wise results or, if simplify = TRUE, a named vector or data frame aligned with the original observations.\n\n\n\nIf simplify = TRUE and the metric returns scalars, a named numeric vector of fold scores is returned. Otherwise a data frame with fold membership and scores per observation is returned.\nThe convenience metrics return a numeric vector of scores or residuals.\n\n\n\ngamlss2, log_pdf\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## cross-validation using the NO distribution\n## only model the mean with s(x)\ncv1 &lt;- cv_gamlss2(y ~ s(x), data = abdom, family = NO)\n\n## now, also model the standard deviation with s(x)\ncv2 &lt;- cv_gamlss2(y ~ s(x) | s(x), data = abdom, family = BCT)\n\n## evaluate log-likelihood\nsum(cv1$score)\nsum(cv2$score)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "cv_gamlss2"
    ]
  },
  {
    "objectID": "man/plots.html",
    "href": "man/plots.html",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object). If MCMC samples are available from mcmc, bamlss2 or BS which = “samples” shows traceplots and autocorrelation plots of parameter samples.\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "plots"
    ]
  },
  {
    "objectID": "man/plots.html#plotting-gamlss",
    "href": "man/plots.html#plotting-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object). If MCMC samples are available from mcmc, bamlss2 or BS which = “samples” shows traceplots and autocorrelation plots of parameter samples.\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "plots"
    ]
  },
  {
    "objectID": "man/gamlss2.html",
    "href": "man/gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  knots = NULL, control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\nknots\n\n\nAn optional list of user specified knots, see smoothCon.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink functions: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \nmu.(Intercept)    226.33309    1.25941  179.71  &lt; 2e-16 ***\nsigma.(Intercept)  -2.92261    0.01104 -264.67  &lt; 2e-16 ***\nnu.(Intercept)     -0.18026    0.04611   -3.91 0.000103 ***\ntau.(Intercept)     2.65014    0.01440  183.98  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    mu.s(x) sigma.s(x) nu.s(x) tau.s(x)\nedf  4.5505     2.5450  1.0015   1.0004\n*--------\nn = 610 df =  13.1 res.df =  596.9\nDeviance = 4770.1544 Null Dev. Red. = 33.39%\nAIC = 4796.3494 elapsed =  0.90sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 5038.2528 eps = 0.532980     \nGAMLSS-RS iteration  2: Global Deviance = 4778.2534 eps = 0.051605     \nGAMLSS-RS iteration  3: Global Deviance = 4775.2426 eps = 0.000630     \nGAMLSS-RS iteration  4: Global Deviance = 4775.1428 eps = 0.000020     \nGAMLSS-RS iteration  5: Global Deviance = 4775.0855 eps = 0.000012     \nGAMLSS-RS iteration  6: Global Deviance = 4775.053 eps = 0.000006     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 5076.3585 eps = 0.529448     \nGAMLSS-RS iteration  2: Global Deviance = 5076.3565 eps = 0.000000     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.358483           -2.302585            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4816.1239 eps = 0.540554     \nGAMLSS-RS iteration  2: Global Deviance = -7383.8761 eps = 2.533157     \nGAMLSS-RS iteration  3: Global Deviance = -19583.8761 eps = 1.652248     \nGAMLSS-RS iteration  4: Global Deviance = -31783.8761 eps = 0.622961     \nGAMLSS-RS iteration  5: Global Deviance = -36347.9794 eps = 0.143598     \nGAMLSS-RS iteration  6: Global Deviance = -36347.9794 eps = 0.000000     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = -36347.9794 eps = 0.000000",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "href": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  knots = NULL, control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\nknots\n\n\nAn optional list of user specified knots, see smoothCon.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink functions: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \nmu.(Intercept)    226.33309    1.25941  179.71  &lt; 2e-16 ***\nsigma.(Intercept)  -2.92261    0.01104 -264.67  &lt; 2e-16 ***\nnu.(Intercept)     -0.18026    0.04611   -3.91 0.000103 ***\ntau.(Intercept)     2.65014    0.01440  183.98  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    mu.s(x) sigma.s(x) nu.s(x) tau.s(x)\nedf  4.5505     2.5450  1.0015   1.0004\n*--------\nn = 610 df =  13.1 res.df =  596.9\nDeviance = 4770.1544 Null Dev. Red. = 33.39%\nAIC = 4796.3494 elapsed =  0.90sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 5038.2528 eps = 0.532980     \nGAMLSS-RS iteration  2: Global Deviance = 4778.2534 eps = 0.051605     \nGAMLSS-RS iteration  3: Global Deviance = 4775.2426 eps = 0.000630     \nGAMLSS-RS iteration  4: Global Deviance = 4775.1428 eps = 0.000020     \nGAMLSS-RS iteration  5: Global Deviance = 4775.0855 eps = 0.000012     \nGAMLSS-RS iteration  6: Global Deviance = 4775.053 eps = 0.000006     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 5076.3585 eps = 0.529448     \nGAMLSS-RS iteration  2: Global Deviance = 5076.3565 eps = 0.000000     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.358483           -2.302585            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4816.1239 eps = 0.540554     \nGAMLSS-RS iteration  2: Global Deviance = -7383.8761 eps = 2.533157     \nGAMLSS-RS iteration  3: Global Deviance = -19583.8761 eps = 1.652248     \nGAMLSS-RS iteration  4: Global Deviance = -31783.8761 eps = 0.622961     \nGAMLSS-RS iteration  5: Global Deviance = -36347.9794 eps = 0.143598     \nGAMLSS-RS iteration  6: Global Deviance = -36347.9794 eps = 0.000000     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = -36347.9794 eps = 0.000000",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/mcmc.html",
    "href": "man/mcmc.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function mcmc() runs MCMC sampling for a fitted gamlss2 model. It reuses the fitted model object and merges the MCMC output back into the original object such that standard methods (e.g., summary and plot) work as expected.\n\n\n\nmcmc(object, n.iter = 1200, burnin = 200, thin = 1)\n\n\n\n\n\n\n\nobject\n\n\nAn object of class “gamlss2” (or “bamlss2”) as returned by gamlss2.\n\n\n\n\nn.iter\n\n\nInteger, the total number of MCMC iterations.\n\n\n\n\nburnin\n\n\nInteger, the burn-in period.\n\n\n\n\nthin\n\n\nInteger, thinning parameter for saved samples.\n\n\n\n\n\n\nThe function sets n.iter, burnin, and thin in the model control list and obtains starting values from the fitted object (including smoothing parameters). The MCMC sampler BS is then called and the resulting samples and posterior summaries are merged into the original model object. This approach ensures that the result retains terms, call, and related components required by extractor and plotting functions.\nThe function is designed to behave in line with gamlss2() interfaces with respect to weights and offset handling. If the fitted model object does not contain the required design information for MCMC sampling (e.g., if the model was fitted using a reduced control setting that drops smooth design matrices), sampling cannot be performed.\n\n\n\nA model object inheriting from “gamlss2” containing posterior samples and summary information. The object also contains:\n\n\nsamples: Posterior draws for coefficients and smoothing variances.\n\n\nresults: Model results derived from posterior means.\n\n\nelapsed: Elapsed sampling time.\n\n\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, bamlss2, BS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using backfitting\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## run MCMC sampling\nset.seed(1328)\na &lt;- mcmc(b)\n\n## generate more samples\na &lt;- mcmc(a)\n\n## posterior summary\nsummary(a)\n\n## plot estimated effects\nplot(a)\n\n## plot samples\nplot(a, which = \"samples\")\nplot(a, which = \"samples\", ask = TRUE)\nplot(a, which = \"samples\", ask = TRUE,\n  model = \"mu\", lag.max = 120, term = \"s(x)\", )\n\n## samples can be extracted for\n## furher inspection\nprint(head(a$samples))\n\n## compare estimated mean effects\nplot(c(b, a))\n\n## predict parameters using samples\npm &lt;- predict(b, FUN = mean)\nprint(head(pm))\npsd &lt;- predict(b, FUN = sd)\nprint(head(psd))",
    "crumbs": [
      "Documentation",
      "Regression models",
      "mcmc"
    ]
  },
  {
    "objectID": "man/mcmc.html#run-mcmc-sampling-for-a-fitted-gamlss2-model",
    "href": "man/mcmc.html#run-mcmc-sampling-for-a-fitted-gamlss2-model",
    "title": "gamlss2",
    "section": "",
    "text": "The function mcmc() runs MCMC sampling for a fitted gamlss2 model. It reuses the fitted model object and merges the MCMC output back into the original object such that standard methods (e.g., summary and plot) work as expected.\n\n\n\nmcmc(object, n.iter = 1200, burnin = 200, thin = 1)\n\n\n\n\n\n\n\nobject\n\n\nAn object of class “gamlss2” (or “bamlss2”) as returned by gamlss2.\n\n\n\n\nn.iter\n\n\nInteger, the total number of MCMC iterations.\n\n\n\n\nburnin\n\n\nInteger, the burn-in period.\n\n\n\n\nthin\n\n\nInteger, thinning parameter for saved samples.\n\n\n\n\n\n\nThe function sets n.iter, burnin, and thin in the model control list and obtains starting values from the fitted object (including smoothing parameters). The MCMC sampler BS is then called and the resulting samples and posterior summaries are merged into the original model object. This approach ensures that the result retains terms, call, and related components required by extractor and plotting functions.\nThe function is designed to behave in line with gamlss2() interfaces with respect to weights and offset handling. If the fitted model object does not contain the required design information for MCMC sampling (e.g., if the model was fitted using a reduced control setting that drops smooth design matrices), sampling cannot be performed.\n\n\n\nA model object inheriting from “gamlss2” containing posterior samples and summary information. The object also contains:\n\n\nsamples: Posterior draws for coefficients and smoothing variances.\n\n\nresults: Model results derived from posterior means.\n\n\nelapsed: Elapsed sampling time.\n\n\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, bamlss2, BS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using backfitting\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## run MCMC sampling\nset.seed(1328)\na &lt;- mcmc(b)\n\n## generate more samples\na &lt;- mcmc(a)\n\n## posterior summary\nsummary(a)\n\n## plot estimated effects\nplot(a)\n\n## plot samples\nplot(a, which = \"samples\")\nplot(a, which = \"samples\", ask = TRUE)\nplot(a, which = \"samples\", ask = TRUE,\n  model = \"mu\", lag.max = 120, term = \"s(x)\", )\n\n## samples can be extracted for\n## furher inspection\nprint(head(a$samples))\n\n## compare estimated mean effects\nplot(c(b, a))\n\n## predict parameters using samples\npm &lt;- predict(b, FUN = mean)\nprint(head(pm))\npsd &lt;- predict(b, FUN = sd)\nprint(head(psd))",
    "crumbs": [
      "Documentation",
      "Regression models",
      "mcmc"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html",
    "href": "man/predict.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, exclude = NULL, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? Standard errors are computed by simulating from the approximate multivariate normal distribution of the maximum likelihood estimates. The number of simulations is controlled by the argument R, which defaults to R = 200, and can be passed via ….\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\nexclude\n\n\ncharacter. Any terms named in this vector will be set to zero.\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1879 eps = 0.002888     \nGAMLSS-RS iteration  3: Global Deviance = 405.7966 eps = 0.000963     \nGAMLSS-RS iteration  4: Global Deviance = 405.7908 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 405.7908 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.11757 10.05004\n2 58.82097 18.56457\n3 95.57069 34.28308\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.11757 10.05004\n2 58.82097 18.56457\n3 95.57069 34.28308\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.05004 18.56457 34.28308 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.05004\n2 18.56457\n3 34.28308\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1     2.63897 -0.3313934\n2     2.63897  0.2822851\n3     2.63897  0.8956823\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3313934\n2  0.2822851\n3  0.8956823\n\n## standard errors\npredict(m, newdata = nd, se.fit = TRUE, R = 200)\n\n    mu.fit     mu.se    sigma.fit     sigma.se\n1 23.11757  4.936673 1.094468e+01 4.725302e+00\n2 58.82097 12.621997 2.381664e+01 1.813702e+01\n3 95.57069 98.059417 1.209940e+10 1.711069e+11",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "href": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, exclude = NULL, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? Standard errors are computed by simulating from the approximate multivariate normal distribution of the maximum likelihood estimates. The number of simulations is controlled by the argument R, which defaults to R = 200, and can be passed via ….\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\nexclude\n\n\ncharacter. Any terms named in this vector will be set to zero.\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1879 eps = 0.002888     \nGAMLSS-RS iteration  3: Global Deviance = 405.7966 eps = 0.000963     \nGAMLSS-RS iteration  4: Global Deviance = 405.7908 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 405.7908 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.11757 10.05004\n2 58.82097 18.56457\n3 95.57069 34.28308\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.11757 10.05004\n2 58.82097 18.56457\n3 95.57069 34.28308\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.05004 18.56457 34.28308 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.05004\n2 18.56457\n3 34.28308\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1     2.63897 -0.3313934\n2     2.63897  0.2822851\n3     2.63897  0.8956823\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3313934\n2  0.2822851\n3  0.8956823\n\n## standard errors\npredict(m, newdata = nd, se.fit = TRUE, R = 200)\n\n    mu.fit     mu.se    sigma.fit     sigma.se\n1 23.11757  4.936673 1.094468e+01 4.725302e+00\n2 58.82097 12.621997 2.381664e+01 1.813702e+01\n3 95.57069 98.059417 1.209940e+10 1.711069e+11",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html",
    "href": "man/gamlss2-package.html",
    "title": "gamlss2",
    "section": "",
    "text": "Next generation infrastructure for generalized additive models for location, scale, and shape (GAMLSS) and general distributional regression models. The package provides a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.\n\n\n\nThe primary purpose of this package is to facilitate the creation of advanced infrastructure designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various estimation algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Documentation",
      "Package overview",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "href": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "title": "gamlss2",
    "section": "",
    "text": "Next generation infrastructure for generalized additive models for location, scale, and shape (GAMLSS) and general distributional regression models. The package provides a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.\n\n\n\nThe primary purpose of this package is to facilitate the creation of advanced infrastructure designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various estimation algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Documentation",
      "Package overview",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html",
    "href": "man/gamlss2_control.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html#control-parameters",
    "href": "man/gamlss2_control.html#control-parameters",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/BS.html",
    "href": "man/BS.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function BS() implements an MCMC sampler for generalized additive models for location, scale and shape (GAMLSS) as fitted by gamlss2. The sampler uses a Metropolis-Hastings update for regression coefficients of linear and smooth terms. Smoothing variances are updated using univariate slice sampling or conjugate updates, depending on the structure of the penalty matrices.\n\n\n\n## Bayesian sampler.\nBS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset. See gamlss2 for details on the offset interface.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\nstart\n\n\nStarting values for the parameters of the response distribution. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunction BS() is typically called via mcmc or via wrapper function bamlss2. It implements a blocked Metropolis-Hastings sampler using working responses and working weights. Smooth terms are updated using penalized weighted least squares proposals and their smoothing variances are sampled using univariate slice sampling.\nThe function uses the following control arguments:\n\n\nn.iter: Integer, the total number of MCMC iterations.\n\n\nburnin: Integer, the burn-in period.\n\n\nthin: Integer, thinning parameter for saved samples.\n\n\ntrace: Logical, should information be printed while the sampler is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nnullmodel: Logical, should an intercept-only null model be evaluated to compute a null deviance and deviance reduction?\n\n\nbinning: Logical, should binning be used for smooth terms if available (unique observations for building \\(X^{\\top}WX\\) and related quantities)?\n\n\nThe returned object contains posterior samples for all model components. In addition, DIC and related quantities may be computed from saved log-likelihood values if enabled.\n\n\n\nThe function returns a fitted model object containing posterior samples and summary information. The exact structure is determined by the sampler implementation, but typically includes:\n\n\nsamples: A matrix of posterior draws for coefficients and smoothing variances.\n\n\ncoefficients: Posterior means of coefficients.\n\n\nfitted.values: Posterior mean fitted values for each distributional parameter.\n\n\nedf: Estimated degrees of freedom for smooth terms.\n\n\nlogLik: Log-likelihood at the posterior mean predictor.\n\n\ndic: DIC-related quantities (if computed).\n\n\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, RS, CG, mcmc, bamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## see ?mcmc",
    "crumbs": [
      "Documentation",
      "Regression models",
      "BS"
    ]
  },
  {
    "objectID": "man/BS.html#bayesian-sampler-bs-for-gamlss-models",
    "href": "man/BS.html#bayesian-sampler-bs-for-gamlss-models",
    "title": "gamlss2",
    "section": "",
    "text": "The function BS() implements an MCMC sampler for generalized additive models for location, scale and shape (GAMLSS) as fitted by gamlss2. The sampler uses a Metropolis-Hastings update for regression coefficients of linear and smooth terms. Smoothing variances are updated using univariate slice sampling or conjugate updates, depending on the structure of the penalty matrices.\n\n\n\n## Bayesian sampler.\nBS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset. See gamlss2 for details on the offset interface.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\nstart\n\n\nStarting values for the parameters of the response distribution. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunction BS() is typically called via mcmc or via wrapper function bamlss2. It implements a blocked Metropolis-Hastings sampler using working responses and working weights. Smooth terms are updated using penalized weighted least squares proposals and their smoothing variances are sampled using univariate slice sampling.\nThe function uses the following control arguments:\n\n\nn.iter: Integer, the total number of MCMC iterations.\n\n\nburnin: Integer, the burn-in period.\n\n\nthin: Integer, thinning parameter for saved samples.\n\n\ntrace: Logical, should information be printed while the sampler is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nnullmodel: Logical, should an intercept-only null model be evaluated to compute a null deviance and deviance reduction?\n\n\nbinning: Logical, should binning be used for smooth terms if available (unique observations for building \\(X^{\\top}WX\\) and related quantities)?\n\n\nThe returned object contains posterior samples for all model components. In addition, DIC and related quantities may be computed from saved log-likelihood values if enabled.\n\n\n\nThe function returns a fitted model object containing posterior samples and summary information. The exact structure is determined by the sampler implementation, but typically includes:\n\n\nsamples: A matrix of posterior draws for coefficients and smoothing variances.\n\n\ncoefficients: Posterior means of coefficients.\n\n\nfitted.values: Posterior mean fitted values for each distributional parameter.\n\n\nedf: Estimated degrees of freedom for smooth terms.\n\n\nlogLik: Log-likelihood at the posterior mean predictor.\n\n\ndic: DIC-related quantities (if computed).\n\n\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, RS, CG, mcmc, bamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## see ?mcmc",
    "crumbs": [
      "Documentation",
      "Regression models",
      "BS"
    ]
  },
  {
    "objectID": "man/make.link2.html",
    "href": "man/make.link2.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list of class “link_gamlss2” containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"",
    "crumbs": [
      "Documentation",
      "Families and links",
      "make.link2"
    ]
  },
  {
    "objectID": "man/make.link2.html#create-a-link-for-families",
    "href": "man/make.link2.html#create-a-link-for-families",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list of class “link_gamlss2” containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"",
    "crumbs": [
      "Documentation",
      "Families and links",
      "make.link2"
    ]
  },
  {
    "objectID": "man/softplus.html",
    "href": "man/softplus.html",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "softplus"
    ]
  },
  {
    "objectID": "man/softplus.html#softplus-link-object",
    "href": "man/softplus.html#softplus-link-object",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "softplus"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html",
    "href": "man/prodist.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1879 eps = 0.002888     \nGAMLSS-RS iteration  3: Global Deviance = 405.7966 eps = 0.000963     \nGAMLSS-RS iteration  4: Global Deviance = 405.7908 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 405.7908 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                  1                                   2 \n\"GDF NO(mu = 23.12, sigma = 10.05)\" \"GDF NO(mu = 58.82, sigma = 18.56)\" \n                                  3 \n\"GDF NO(mu = 95.57, sigma = 34.28)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.586727 23.11757  39.64840\n2 28.284971 58.82097  89.35696\n3 39.180036 95.57069 151.96134\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.586727  58.820966 151.961337 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\nvariance(d)\n\n        1         2         3 \n 101.0032  344.6431 1175.3296 \n\n## simulate random numbers\nrandom(d, 5)\n\n        r_1       r_2       r_3        r_4      r_5\n1  31.50495  31.87026  12.72626   6.870816 40.26022\n2  69.91424  66.53247  53.57387  66.491048 25.57663\n3 136.65927 131.08731 139.63629 109.292630 96.91414\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.024798e-34 1.273422e-13 0.0028169995 0.001109383 7.777801e-15\n2 2.750602e-18 7.430283e-10 0.0001419917 0.019195539 1.835767e-03\n3 9.985419e-10 1.414926e-06 0.0002389622 0.004810090 1.153999e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 8.352306e-35 1.727573e-13 0.0107171145 0.99626197 1.0000000\n2 5.890414e-18 2.289984e-09 0.0007662613 0.31733979 0.9867278\n3 5.831408e-09 1.087434e-05 0.0026542456 0.09188323 0.5513996\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                   1 \n\"GDF PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "href": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 406.1879 eps = 0.002888     \nGAMLSS-RS iteration  3: Global Deviance = 405.7966 eps = 0.000963     \nGAMLSS-RS iteration  4: Global Deviance = 405.7908 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 405.7908 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                  1                                   2 \n\"GDF NO(mu = 23.12, sigma = 10.05)\" \"GDF NO(mu = 58.82, sigma = 18.56)\" \n                                  3 \n\"GDF NO(mu = 95.57, sigma = 34.28)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.586727 23.11757  39.64840\n2 28.284971 58.82097  89.35696\n3 39.180036 95.57069 151.96134\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.586727  58.820966 151.961337 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.11757 58.82097 95.57069 \n\nvariance(d)\n\n        1         2         3 \n 101.0032  344.6431 1175.3296 \n\n## simulate random numbers\nrandom(d, 5)\n\n        r_1       r_2       r_3        r_4      r_5\n1  31.50495  31.87026  12.72626   6.870816 40.26022\n2  69.91424  66.53247  53.57387  66.491048 25.57663\n3 136.65927 131.08731 139.63629 109.292630 96.91414\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.024798e-34 1.273422e-13 0.0028169995 0.001109383 7.777801e-15\n2 2.750602e-18 7.430283e-10 0.0001419917 0.019195539 1.835767e-03\n3 9.985419e-10 1.414926e-06 0.0002389622 0.004810090 1.153999e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 8.352306e-35 1.727573e-13 0.0107171145 0.99626197 1.0000000\n2 5.890414e-18 2.289984e-09 0.0007662613 0.31733979 0.9867278\n3 5.831408e-09 1.087434e-05 0.0026542456 0.09188323 0.5513996\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                   1 \n\"GDF PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "gamlss2 0.1-0",
    "section": "",
    "text": "gamlss2 0.1-0\n\nFirst version of ‘gamlss2’ providing a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models."
  },
  {
    "objectID": "vignettes/topmodels.html#probabilistic-model-infrastructure",
    "href": "vignettes/topmodels.html#probabilistic-model-infrastructure",
    "title": "Forecasting and Assessment with topmodels",
    "section": "1 Probabilistic model infrastructure",
    "text": "1 Probabilistic model infrastructure\nIntroduction on how to use the topmodels package (topmodels?) with gamlss2.\nCurrently not on CRAN, yet, so install from R-universe (if not done already).\n\nif(!(\"topmodels\" %in% installed.packages())) {\n  install.packages(\"topmodels\", repos = \"https://zeileis.R-universe.dev\")\n}\nif(packageVersion(\"gamlss.dist\") &lt; \"6.1-3\") {\n  install.packages(\"gamlss.dist\", repos = \"https://gamlss-dev.R-universe.dev\")\n}\n\nOn GitHub, unfortunately, in the GitHub Action the gamlss.dist package is always taken from CRAN (via r-cran-gamlss.dist apparently).\n\npackageVersion(\"gamlss.dist\")\n\n[1] '6.1.1'"
  },
  {
    "objectID": "vignettes/topmodels.html#data-and-models",
    "href": "vignettes/topmodels.html#data-and-models",
    "title": "Forecasting and Assessment with topmodels",
    "section": "2 Data and models",
    "text": "2 Data and models\n\nlibrary(\"gamlss2\")\ndata(\"HarzTraffic\", package = \"gamlss2\")\nm1 &lt;- lm(log(cars) ~ poly(yday, 3), data = HarzTraffic)\nm2 &lt;- gamlss2(log(cars) ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"), data = HarzTraffic, family = SN2)"
  },
  {
    "objectID": "vignettes/topmodels.html#probabilistic-forecasting",
    "href": "vignettes/topmodels.html#probabilistic-forecasting",
    "title": "Forecasting and Assessment with topmodels",
    "section": "3 Probabilistic forecasting",
    "text": "3 Probabilistic forecasting\n\nlibrary(\"topmodels\")\nnd &lt;- data.frame(yday = 1:365)\nnd &lt;- cbind(nd,\n  procast(m1, newdata = nd, type = \"quantile\", at = c(0.025, 0.5, 0.975)),\n  procast(m2, newdata = nd, type = \"quantile\", at = c(0.025, 0.5, 0.975)))\nplot(log(cars) ~ yday, data = HarzTraffic, type = \"n\")\npolygon(c(nd[[1]], rev(nd[[1]])), c(nd[[2]], rev(nd[[4]])),\n  col = adjustcolor(2, alpha.f = 0.4), border = \"transparent\")\npolygon(c(nd[[1]], rev(nd[[1]])), c(nd[[5]], rev(nd[[7]])),\n  col = adjustcolor(4, alpha.f = 0.4), border = \"transparent\")\npoints(log(cars) ~ yday, data = HarzTraffic)\nlines(nd[[1]], nd[[3]], col = 2, lwd = 2)\nlines(nd[[1]], nd[[6]], col = 4, lwd = 2)"
  },
  {
    "objectID": "vignettes/topmodels.html#graphical-model-assessment",
    "href": "vignettes/topmodels.html#graphical-model-assessment",
    "title": "Forecasting and Assessment with topmodels",
    "section": "4 Graphical model assessment",
    "text": "4 Graphical model assessment\n\n4.1 Within model diagnostics\n\npar(mfrow = c(2, 2))\nrootogram(m1)\npithist(m1)\nqqrplot(m1)\nwormplot(m1)\n\n\n\n\n\n\n\n\n\npar(mfrow = c(2, 2))\nrootogram(m2)\npithist(m2)\nqqrplot(m2)\nwormplot(m2)\n\n\n\n\n\n\n\n\n\n\n4.2 Between Models diagnostics\n\npar(mfrow = c(1, 2))\np1 &lt;- pithist(m1, plot = FALSE)\np2 &lt;- pithist(m2, plot = FALSE)\nplot(c(p1, p2), col = c(2, 4), single_graph = TRUE, style = \"line\")\nw1 &lt;- wormplot(m1, plot = FALSE)\nw2 &lt;- wormplot(m2, plot = FALSE)\nplot(c(w1, w2), col = c(2, 4), single_graph = TRUE)"
  },
  {
    "objectID": "vignettes/topmodels.html#scoring-rules",
    "href": "vignettes/topmodels.html#scoring-rules",
    "title": "Forecasting and Assessment with topmodels",
    "section": "5 Scoring rules",
    "text": "5 Scoring rules\n\nm &lt;- list(lm = m1, gamlss2 = m2)\nsapply(m, proscore, type = c(\"logs\", \"crps\", \"mae\", \"mse\", \"dss\"))\n\nLoading required namespace: scoringRules\n\n\n     lm         gamlss2   \nlogs 0.1806799  0.03691156\ncrps 0.1580683  0.1471254 \nmae  0.2191784  0.2081393 \nmse  0.08403538 0.07790537\ndss  -1.476517  -1.741182"
  },
  {
    "objectID": "vignettes/families.html",
    "href": "vignettes/families.html",
    "title": "Family Objects",
    "section": "",
    "text": "All family objects of the gamlss.dist package, see Rigby et al. (2019), can be used for modelling in gamlss2. However, for users wanting to specify their own (new) distribution model, this document provides a guide on how to define custom family objects within the gamlss2 framework.\nFamily objects in the gamlss2 package play an essential role in defining the models used for fitting data to distributions. These objects encapsulate the necessary details about the distribution and the parameters, such as:\nThis document provides an overview of how to construct and use family objects within gamlss2. By the end, you should have a good understanding of how to implement a custom family for use in statistical models."
  },
  {
    "objectID": "vignettes/families.html#defining-family-objects",
    "href": "vignettes/families.html#defining-family-objects",
    "title": "Family Objects",
    "section": "1 Defining Family Objects",
    "text": "1 Defining Family Objects\nA family object in gamlss2 is a list that must meet the following minimum criteria:\n\nFamily Name: The object must contain the family name as a character string.\nParameters: The object must list the parameters of the distribution (e.g., \"mu\" and \"sigma\" for a normal distribution).\nLink Functions: It must specify the link functions associated with each parameter.\nProbability Density Function: A pdf() function must be provided to evaluate the (log-)density of the distribution.\n\nOptionally, a family object can include functions to calculate the log-likelihood, random number generation, cumulative distribution function (CDF), and quantile function.\nHere’s an example of a minimal family object for the normal distribution.\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\"\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIn this example, we define a normal distribution with two parameters: \"mu\" (mean) and \"sigma\" (standard deviation). The link function for \"mu\" is the identity, and for \"sigma\", it is the log function. The probability density function (pdf()) must accept the following arguments:\n\npdf(y, par, log = FALSE, ...)\n\n\ny: The response variable.\npar: A named list of parameters (e.g., \"mu\", \"sigma\" for the normal distribution).\nlog: A logical value indicating whether to return the log-density.\n\nHere, the pdf() function uses the standard dnorm() function to calculate the normal density."
  },
  {
    "objectID": "vignettes/families.html#optional-derivatives",
    "href": "vignettes/families.html#optional-derivatives",
    "title": "Family Objects",
    "section": "2 Optional Derivatives",
    "text": "2 Optional Derivatives\nFamily objects can optionally include functions to compute the first and second derivatives of the log-likelihood with respect to the predictors (or the expected values of those derivatives). These functions are used during model fitting to improve optimization efficiency and accuracy.\nAll derivative functions must follow the structure:\nfunction(y, par, ...)\nFirst-order derivatives must be provided as a named list called \"score\", with one function per distribution parameter. Second-order derivatives must be provided in a list named \"hess\". Each function in \"hess\" must return the negative (expected) second derivative with respect to the predictor.\nThe following code illustrates how to provide both \"score\" and \"hess\" functions for a normal distribution:\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\",\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y)) ## example cross-derivative\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\nIf no derivative functions are provided, all necessary derivatives will be approximated numerically. In addition to derivatives with respect to single parameters, cross-derivatives (i.e., second-order derivatives involving two different parameters) can also be specified. These should be added to the \"hess\" list and named using the format \"param1.param2\", for example \"mu.sigma\". They must use the same function arguments as the other derivative functions.\nCross-derivatives can be beneficial when using second-order optimization algorithms such as Cole and Green (CG) flavor implemented in the default backfitting algorithm RS in gamlss2. Supplying analytical expressions for these derivatives can significantly improve convergence speed and numerical stability in such settings.\nNote that the family object may also include a list of initialization functions for the model parameters. Providing suitable starting values can significantly improve the stability and speed of the estimation process."
  },
  {
    "objectID": "vignettes/families.html#additional-functions",
    "href": "vignettes/families.html#additional-functions",
    "title": "Family Objects",
    "section": "3 Additional Functions",
    "text": "3 Additional Functions\nFamily objects can also include other functions such as\n\ncdf(y, par, ...): Cumulative distribution function.\nquantile(p, par, ...): Quantile function with probability vector p.\nrandom(n, par, ...): Random number generation with number of samples n.\nmean(par, ...): Mean function.\nvariance(par, ...): Variance function.\nskewness(par, ...): Skewness function.\nkurtosis(par, ...): Kurtosis function.\nvalid.response(y): Function to check the values of the response.\n\nNote that the cdf() function is needed it for computing the quantile residuals.\nA complete version of the Normal() family is given below:\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"mean\" = function(par) { par$mu },\n    \"variance\"  = function(par) { par$sigma^2 },\n    \"skewness\" = function(par) { rep(0, length(par$mu)) },\n    \"kurtosis\" = function(par) { rep(3, length(par$mu)) },\n    \"type\" = \"continuous\",\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"valid.response\" = function(y) {\n      if(is.factor(y) | is.character(y))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    },\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y)) ## example cross-derivative\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}"
  },
  {
    "objectID": "vignettes/families.html#flexible-links",
    "href": "vignettes/families.html#flexible-links",
    "title": "Family Objects",
    "section": "4 Flexible Links",
    "text": "4 Flexible Links\nThe example above used static link functions to define the family object. However, gamlss2 also allows users to define families with flexible link functions. To support this, the helper function make.link2() is used. The only nontrivial part is adapting the score and hess functions to work on the linear predictor scale. This is not done automatically in gamlss2 for performance reasons - users may even write these functions in C for speed. Below is a minimal example of implementing the Normal family with flexible link functions:\n\nNormal &lt;- function(mu.link = \"identity\", sigma.link = \"log\", ...) {\n  mu.link &lt;- make.link2(mu.link)\n  sigma.link &lt;- make.link2(sigma.link)\n\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = mu.link, \"sigma\" = sigma.link),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\"\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nNote that the score and hess elements are omitted and approximated numerically during estimation.\nThe following is a small example using the new Normal family with different link functions. We now compare two models, one using an identity link (default) and one using a flexible softplus link.\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n     \n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n     \n## estimate models\nm1 &lt;- gamlss2(f, data = abdom, family = Normal(mu.link = \"identity\"))\n\nGAMLSS-RS iteration  1: Global Deviance = 4785.931 eps = 0.999867     \nGAMLSS-RS iteration  2: Global Deviance = 4785.931 eps = 0.000000     \n\nm2 &lt;- gamlss2(f, data = abdom, family = Normal(mu.link = softplus))\n\nGAMLSS-RS iteration  1: Global Deviance = 4787.4409 eps = 0.999866     \nGAMLSS-RS iteration  2: Global Deviance = 4785.3442 eps = 0.000437     \nGAMLSS-RS iteration  3: Global Deviance = 4785.3442 eps = 0.000000     \n\n\nThe fitted means are visualized with\n\npar(mar = c(4, 4, 1, 1))\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nlines(abdom$x, mean(m1), col = 2, lwd = 5)\nlines(abdom$x, mean(m2), col = 4, lwd = 2)\nlegend(\"topleft\",\n  legend = c(\"Identity\", \"Softplus\"),\n  col = c(2, 4), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nBoth models yield identical fits in this case, however, in practice, flexible links can help stabilize estimation or improve fit in more complex scenarios."
  },
  {
    "objectID": "vignettes/families.html#summary",
    "href": "vignettes/families.html#summary",
    "title": "Family Objects",
    "section": "5 Summary",
    "text": "5 Summary\nFamily objects in the gamlss2 package are a fundamental component for defining flexible, distributional regression models, and beyond. By encapsulating the necessary elements, such as parameters, link functions, and probability density functions, they provide a powerful framework for customizing models to fit specific data. The flexibility to define custom families, as demonstrated with the Normal() distribution, enables users to extend the package beyond its default families, making it adaptable to a wide range of modeling scenarios."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Overview",
    "text": "Overview\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Installation",
    "text": "Installation\nThe development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Licence",
    "text": "Licence\nThe package is available under the General Public License version 3 or version 2"
  },
  {
    "objectID": "index.html#vignettes",
    "href": "index.html#vignettes",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Vignettes",
    "text": "Vignettes\n\nThe basic workflow is illustrated in the vignette First Steps.\nTo learn about distribution families in gamlss2, see the vignette Families, which provides an overview and examples on how to implement custom families.\nFor information on using and setting up new special model terms (e.g., neural networks), the vignette Specials provides a concise introduction.\nModel assessment and calibration using the topmodels package are discussed in the Topmodels vignette."
  },
  {
    "objectID": "vignettes/specials.html",
    "href": "vignettes/specials.html",
    "title": "Special Model Terms",
    "section": "",
    "text": "Special model terms in gamlss2 can be virtually any kind of model specification. For example, gamlss2 supports all smooth terms from the mgcv package, including s(), te(), and others. Another example is the la() constructor, which provides Lasso-penalized model terms.\nDefining new special model terms in gamlss2 is relatively straightforward. To implement a new model term, the following three functions need to be provided:\nAs a demonstration, we show how to incorporate local polynomial regression () via loess() (Cleveland, Grosse, and Shyu 1993). Since loess() supports a weights argument, it integrates naturally into the gamlss2 framework, like many other fitting functions that accept weights."
  },
  {
    "objectID": "vignettes/specials.html#the-special-model-term-constructor",
    "href": "vignettes/specials.html#the-special-model-term-constructor",
    "title": "Special Model Terms",
    "section": "1 The special model term constructor",
    "text": "1 The special model term constructor\nAny special model term constructor must be registered in the fake_formula() function, which is called internally by gamlss2(). If a constructor is not yet registered, the user can either:\n\nprovide the new special term name via the specials argument of fake_formula(), or\nuse the reserved constructor name \"user\", which is already recognized by fake_formula().\n\nTo implement a local polynomial smoothing term via loess(), we define a new constructor function called lo() (registered in fake_formula()). This function can accept all relevant arguments from both loess() and loess.control(), which are passed on to the fitting function.\n\nlo &lt;- function(formula, ...) \n{\n  ## ensure it's a formula\n  if(!inherits(formula, \"formula\")) {\n    formula &lt;- as.character(substitute(formula))\n    formula &lt;- as.formula(paste(\"~\", formula))\n    environment(formula) &lt;- sys.frame(-1)\n  }\n\n  ## list for setting up the special model term \n  st &lt;- list()\n\n  ## control arguments\n  st$control &lt;- list(...)\n\n  ## variables, label and data\n  st$term &lt;- all.vars(formula) \n  st$label &lt;- paste0(\"lo(\", paste0(gsub(\" \", \"\",\n    as.character(formula)), collapse = \"\"), \")\") \n  st$data &lt;- model.frame(formula)\n\n  ## per default scale the data\n  if(is.null(st$control$scale))\n    st$control$scale &lt;- TRUE\n  if(isTRUE(st$control$scale)) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      sx[[j]] &lt;- c(\"mean\" = mean(st$data[[j]]), \"sd\" = sd(st$data[[j]]))\n      st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][\"mean\"]) / sx[[j]][\"sd\"]\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## New model formula used for fitting.\n  st$formula &lt;- update(formula, response_z ~ .)\n\n  ## Assign the \"special\" class and the new class \"n\".\n  class(st) &lt;- c(\"special\", \"lo\")\n\n  return(st) \n}\n\nNote that the data to be used in model fitting is evaluated directly within the constructor function and is scaled per default. The returned list must contain all relevant information required for both estimation and prediction. The return value must be of class \"special\" and \"lo\" in this case."
  },
  {
    "objectID": "vignettes/specials.html#the-fitting-function",
    "href": "vignettes/specials.html#the-fitting-function",
    "title": "Special Model Terms",
    "section": "2 The fitting function",
    "text": "2 The fitting function\nFor estimation within gamlss2(), the generic special_fit() function is used. To support the loess model term, a method special_fit.lo() must be provided.\nThe fitting function takes the list x of class \"lo\" (as returned by the constructor lo()), the current working response z, the current working weights w, and a list of control parameters (which are passed through the dots argument in the gamlss2() call). Estimation is carried out via loess(), where z and w are inserted into the data stored in the x\n\nspecial_fit.lo &lt;- function(x, z, w, control, ...)\n{\n  ## assign current working response and weights\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## set up loess call\n  call &lt;- \"loess(formula = x$formula, data = x$data, weights = weights_w\"\n\n  ## add optional control parameters\n  if(!is.null(x$control)) {\n    for(j in names(x$control))\n      call &lt;- paste0(call, \", \", j, \"= x$control$\", j)\n  }\n  call &lt;- paste0(call, \")\")\n\n  ## estimate model\n  rval &lt;- list(\"model\" = eval(parse(text = call)))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- fitted(rval$model) \n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;-  rval$model$trace.hat\n\n  ## pass scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method \n  class(rval) &lt;- \"lo.fitted\" \n\n  return(rval) \n}\n\nThe returned object must be a list containing a \"model\" element that holds the fitted loess() object. Additionally:\n\n\"fitted.values\" must contain the centered fitted values to ensure identifiability in the backfitting algorithm,\n\"edf\" must specify the effective degrees of freedom used in the smoother, and\nthe returned object must be of class \"lo.fitted\" so that special_predict() can dispatch the appropriate prediction method.\n\nThis setup integrates seamlessly with the iterative estimation algorithm implemented in RS()."
  },
  {
    "objectID": "vignettes/specials.html#the-predict-function",
    "href": "vignettes/specials.html#the-predict-function",
    "title": "Special Model Terms",
    "section": "3 The predict function",
    "text": "3 The predict function\nThe prediction function defines how fitted values are obtained from a model term of class \"lo.fitted\". This method is called by special_predict() during model evaluation and prediction.\n\nspecial_predict.lo.fitted &lt;- function(x, data, se.fit = FALSE, ...) \n{\n  ## scaling\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][\"mean\"]) / x$scalex[[j]][\"sd\"]\n    }\n  }\n\n  ## compute predicted values from the loess model\n  p &lt;- as.numeric(predict(x$model, newdata = data))\n\n  ## apply centering shift\n  p &lt;- p - x$shift\n\n  ## wrap in a data frame if se.fit = TRUE,\n  ## mandatory\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n\n  return(p)\n}\n\nThis function must return a numeric vector (or data frame if se.fit = TRUE) containing the predicted values for the given data. The shift value, computed during model fitting, is subtracted to maintain identifiability of the additive predictor.\nThe argument se.fit is included for compatibility and can be extended in the future to return standard errors."
  },
  {
    "objectID": "vignettes/specials.html#example-munich-rent-data",
    "href": "vignettes/specials.html#example-munich-rent-data",
    "title": "Special Model Terms",
    "section": "4 Example: Munich rent data",
    "text": "4 Example: Munich rent data\nWe use the rent dataset from the gamlss.data package to demonstrate the use of custom model terms based on local polynomial smoothing via loess().\n\n## load the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\nWe first estimate a model using the custom lo() constructor for univariate smoothers on floor size (Fl) and year of construction (A).\n\n## define model formula with univariate smoothers\nf1 &lt;- R ~ lo(~Fl) + lo(~A) + loc + B + H + L | . | . | .\n\n## estimate the model using the BCT distribution\nb1 &lt;- gamlss2(f1, data = rent, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 27582.0017 eps = 0.293228     \nGAMLSS-RS iteration  2: Global Deviance = 27543.3096 eps = 0.001402     \nGAMLSS-RS iteration  3: Global Deviance = 27541.3529 eps = 0.000071     \nGAMLSS-RS iteration  4: Global Deviance = 27541.0354 eps = 0.000011     \nGAMLSS-RS iteration  5: Global Deviance = 27540.9221 eps = 0.000004     \n\n\nNext, we include a bivariate loess smoother for Fl and A to allow for interaction.\n\n## define model formula with bivariate smoother\nf2 &lt;- R ~ lo(~Fl*A) + loc + B + H + L | . | . | .\n\n## estimate the alternative model\nb2 &lt;- gamlss2(f2, data = rent, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 27570.2133 eps = 0.293530     \nGAMLSS-RS iteration  2: Global Deviance = 27520.8741 eps = 0.001789     \nGAMLSS-RS iteration  3: Global Deviance = 27518.9667 eps = 0.000069     \nGAMLSS-RS iteration  4: Global Deviance = 27518.5501 eps = 0.000015     \nGAMLSS-RS iteration  5: Global Deviance = 27518.2997 eps = 0.000009     \n\n\nWe can compare the models using the AIC().\n\nAIC(b1, b2)\n\n        AIC       df\nb2 27659.73 70.71661\nb1 27671.02 65.04671\n\n\nFinally, we visualize the estimated effects from the second model.\n\npar(mfrow = c(2, 2))\nplot(b2, spar = FALSE)\n\n\n\n\n\n\n\n\nThis example illustrates how easy it is to integrate loess smoothers into gamlss2 using the custom model term interface."
  },
  {
    "objectID": "vignettes/gamlss2.html#overview",
    "href": "vignettes/gamlss2.html#overview",
    "title": "Overview",
    "section": "1.1 Overview",
    "text": "1.1 Overview\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "vignettes/gamlss2.html#installation",
    "href": "vignettes/gamlss2.html#installation",
    "title": "Overview",
    "section": "1.2 Installation",
    "text": "1.2 Installation\nThe development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "vignettes/gamlss2.html#licence",
    "href": "vignettes/gamlss2.html#licence",
    "title": "Overview",
    "section": "1.3 Licence",
    "text": "1.3 Licence\nThe package is available under the General Public License version 3 or version 2"
  },
  {
    "objectID": "vignettes/firststeps.html",
    "href": "vignettes/firststeps.html",
    "title": "First Steps",
    "section": "",
    "text": "The package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nWe illustrate how gamlss2 builds on the established gamlss framework by modeling daily maximum temperature (Tmax) at Munich Airport (MUC) to estimate the probability of “heat days” (Tmax \\(\\geq 30^\\circ\\text{C}\\)). Heat days can have serious impacts by stressing highways and railways, increasing the load on healthcare facilities, and affecting airport operations. Using 30 years of historical Tmax data, we fit a flexible distributional regression model that captures the full conditional distribution of daily temperatures. By evaluating this fitted distribution at the \\(30^\\circ\\text{C}\\) threshold, we obtain heat-day probabilities. Required packages can be loaded by\n\nif(!(\"gamlss\" %in% installed.packages())) {\n  install.packages(\"gamlss\")\n}\nlibrary(\"gamlss\")\nlibrary(\"gamlss2\")\n\nThe data comes from the same R-universe as gamlss2 and is loaded with\n\nif(!(\"WeatherGermany\" %in% installed.packages())) {\n  install.packages('WeatherGermany',\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\n\nInstalling package into '/usr/local/lib/R/site-library'\n(as 'lib' is unspecified)\n\ndata(\"WeatherGermany\", package = \"WeatherGermany\")\nMUC &lt;- subset(WeatherGermany, id == 1262)\n\nWe find that the four-parameter SEP family fits the marginal distribution of Tmax quite well. To estimate a full distributional model, we specify the following additive predictor\n\\(\\eta = \\beta_0 + f_1(\\texttt{year}) + f_2(\\texttt{yday}) + f_3(\\texttt{year}, \\texttt{yday})\\)\nfor each parameter. Here, \\(f_1( \\cdot )\\) captures the long-term trend, \\(f_2( \\cdot )\\) models seasonal variation, and \\(f_3( \\cdot, \\cdot )\\) represents a time-varying seasonal effect. The required variables can be added to the data by\n\nMUC$year &lt;- as.POSIXlt(MUC$date)$year + 1900\nMUC$yday &lt;- as.POSIXlt(MUC$date)$yday\n\nIn gamlss, model estimation is performed via\n\nif(!(\"gamlss.add\" %in% installed.packages())) {\n  install.packages(\"gamlss.add\",\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\nlibrary(\"gamlss.add\")\n\n\nf1 &lt;- Tmax ~ ga(~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")))\nb1 &lt;- gamlss(f1, family = SEP,\n  data = MUC[, c(\"Tmax\", \"year\", \"yday\")])\n\nGAMLSS-RS iteration 1: Global Deviance = 65081.31 \nGAMLSS-RS iteration 2: Global Deviance = 64953.19 \nGAMLSS-RS iteration 3: Global Deviance = 64893.26 \nGAMLSS-RS iteration 4: Global Deviance = 64869.21 \nGAMLSS-RS iteration 5: Global Deviance = 64859.01 \nGAMLSS-RS iteration 6: Global Deviance = 64854.42 \nGAMLSS-RS iteration 7: Global Deviance = 64852.19 \nGAMLSS-RS iteration 8: Global Deviance = 64850.94 \nGAMLSS-RS iteration 9: Global Deviance = 64850.14 \nGAMLSS-RS iteration 10: Global Deviance = 64849.54 \nGAMLSS-RS iteration 11: Global Deviance = 64849.04 \nGAMLSS-RS iteration 12: Global Deviance = 64848.58 \nGAMLSS-RS iteration 13: Global Deviance = 64848.13 \nGAMLSS-RS iteration 14: Global Deviance = 64847.73 \nGAMLSS-RS iteration 15: Global Deviance = 64847.33 \nGAMLSS-RS iteration 16: Global Deviance = 64846.94 \nGAMLSS-RS iteration 17: Global Deviance = 64846.56 \nGAMLSS-RS iteration 18: Global Deviance = 64846.19 \nGAMLSS-RS iteration 19: Global Deviance = 64845.83 \nGAMLSS-RS iteration 20: Global Deviance = 64845.48 \n\n\nWarning in RS(): Algorithm RS has not yet converged\n\n\nThis setup requires loading the gamlss.add package to access mgcv-based smooth terms. Estimation takes 20 iterations of the backfitting algorithm (without full convergence) and about 44 seconds on a 64-bit Linux system. Moreover, gamlss() requires that the input data contains no NA values. In gamlss2 the model can be specified directly, following mgcv syntax\n\nf2 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\"))\nb2 &lt;- gamlss2(f2, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 65324.7244 eps = 0.572868     \nGAMLSS-RS iteration  2: Global Deviance = 65122.8497 eps = 0.003090     \nGAMLSS-RS iteration  3: Global Deviance = 64958.3544 eps = 0.002525     \nGAMLSS-RS iteration  4: Global Deviance = 64895.5748 eps = 0.000966     \nGAMLSS-RS iteration  5: Global Deviance = 64870.287 eps = 0.000389     \nGAMLSS-RS iteration  6: Global Deviance = 64859.484 eps = 0.000166     \nGAMLSS-RS iteration  7: Global Deviance = 64854.7149 eps = 0.000073     \nGAMLSS-RS iteration  8: Global Deviance = 64852.3536 eps = 0.000036     \nGAMLSS-RS iteration  9: Global Deviance = 64851.0278 eps = 0.000020     \nGAMLSS-RS iteration 10: Global Deviance = 64850.1599 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 64849.5251 eps = 0.000009     \n\n\nThis model converges in 11 iterations and requires only about 2 seconds of computation time, yielding a similar deviance (small differences arise due to differences in smoothing parameter optimization). In many applications, it is desirable to use the same predictor structure for all distribution parameters. In gamlss, this requires specifying identical formulas separately via sigma.formula, nu.formula, and tau.formula, which can be tedious. In gamlss2, this is simplified using “.”\n\nf3 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")) | . | . | .\nb3 &lt;- gamlss2(f3, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 64918.7898 eps = 0.575522     \nGAMLSS-RS iteration  2: Global Deviance = 64723.5807 eps = 0.003006     \nGAMLSS-RS iteration  3: Global Deviance = 64650.3597 eps = 0.001131     \nGAMLSS-RS iteration  4: Global Deviance = 64620.0646 eps = 0.000468     \nGAMLSS-RS iteration  5: Global Deviance = 64605.8345 eps = 0.000220     \nGAMLSS-RS iteration  6: Global Deviance = 64598.9285 eps = 0.000106     \nGAMLSS-RS iteration  7: Global Deviance = 64595.2314 eps = 0.000057     \nGAMLSS-RS iteration  8: Global Deviance = 64592.905 eps = 0.000036     \nGAMLSS-RS iteration  9: Global Deviance = 64591.4207 eps = 0.000022     \nGAMLSS-RS iteration 10: Global Deviance = 64590.236 eps = 0.000018     \nGAMLSS-RS iteration 11: Global Deviance = 64589.3208 eps = 0.000014     \nGAMLSS-RS iteration 12: Global Deviance = 64588.5401 eps = 0.000012     \nGAMLSS-RS iteration 13: Global Deviance = 64587.8382 eps = 0.000010     \nGAMLSS-RS iteration 14: Global Deviance = 64587.1904 eps = 0.000010     \nGAMLSS-RS iteration 15: Global Deviance = 64586.5839 eps = 0.000009     \n\n\nThis model converges in 20 iterations in about 30 seconds. After estimation, results can be inspected using the summary() method for both packages. Using plot() in gamlss produces standard residual diagnostic plots, whereas in gamlss2\n\nplot(b3)\n\n\n\n\n\n\n\n\ndisplays all estimated covariate effects. For residual diagnostics, gamlss2 leverages the topmodels package, which provides infrastructures for probabilistic model assessment. E.g., a PIT histogram can be created by\n\nif(!(\"topmodels\" %in% installed.packages())) {\n  install.packages(\"topmodels\", repos = \"https://zeileis.R-universe.dev\")\n}\nlibrary(\"topmodels\")\n\npithist(b3)\n\n\n\n\n\n\n\n\nshowing good model calibration. Finally, we compute the probability of a heat day for 2025. First, the procast() function from `topmodels predicts the fitted distributions\n\nnd &lt;- data.frame(\"year\" = 2025, \"yday\" = 0:365)\npf &lt;- procast(b3, newdata = nd, drop = TRUE)\n\nThis yields a distribution vector pf using the infrastructure from the distributions3 package. Probabilities of a heat day can then be calculated with the corresponding cdf() method.\n\nif(!(\"distributions3\" %in% installed.packages())) {\n  install.packages(\"distributions3\")\n}\nlibrary(\"distributions3\")\nprobs &lt;- 1 - cdf(pf, 30)\n\nand visualized, for example, by\n\npar(mar = c(4, 4, 1, 1))\nplot(probs, type = \"l\", xlab = \"Day of Year\",\n  ylab = \"Prob(Tmax &gt; 30)\")\n\n\n\n\n\n\n\n\nNote that a predict() method is available for both gamlss and gamlss2, allowing direct prediction of distribution parameters. However, in gamlss, predict() may not fully support new data in all cases.\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society C 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x."
  },
  {
    "objectID": "man/GDF.html",
    "href": "man/GDF.html",
    "title": "gamlss2",
    "section": "",
    "text": "The GDF (gamlss2 Distribution Family) is a unified class with corresponding methods that represent all distributional families supported by the gamlss2 package. It enables seamless integration with the distributions3 workflow and provides a consistent interface for model fitting and distributional computations.\n\n\n\nGDF(family, parameters)\n\n\n\n\n\n\n\nfamily\n\n\ncharacter. Name of a gamlss2.family or a family provided by the gamlss.dist package, e.g, NO or BI for the normal or binomial distribution, respectively.\n\n\n\n\nparameters\n\n\nnumeric, matrix, list or data frame, see the examples.\n\n\n\n\n\n\nThe S3 class GDF is a slightly more general implementation of the S3 class GAMLSS tailored for gamlss2. For details please see the documentation of GAMLSS\n\n\n\nA GDF object, inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\ngamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## package and random seed\nlibrary(\"distributions3\")\nset.seed(6020)\n\n## one normal distribution\nX &lt;- GDF(\"NO\", c(mu = 1, sigma = 2))\nX\n\n[1] \"GDF NO(mu = 1, sigma = 2)\"\n\n## two normal distributions\nX &lt;- GDF(\"NO\", cbind(c(1, 1.5), c(0.6, 1.2)))\nX\n\n[1] \"GDF NO(mu = 1.0, sigma = 0.6)\" \"GDF NO(mu = 1.5, sigma = 1.2)\"\n\n## three Weibull distributions\nX &lt;- GDF(\"WEI\", list(mu = c(1, 1, 2), sigma = c(1, 2, 2)))\nX\n\n[1] \"GDF WEI(mu = 1, sigma = 1)\" \"GDF WEI(mu = 1, sigma = 2)\"\n[3] \"GDF WEI(mu = 2, sigma = 2)\"\n\n## see ?gamlss.dist::GAMLSS for the remainder of this example\n\n## example using gamlss2\ndata(\"abdom\", package = \"gamlss.data\")\n\n## estimate model\nb &lt;- gamlss2(y ~ s(x) | . | . | ., data = abdom, family = GA)\n\nGAMLSS-RS iteration  1: Global Deviance = 5039.2922 eps = 0.356998     \nGAMLSS-RS iteration  2: Global Deviance = 4802.238 eps = 0.047041     \nGAMLSS-RS iteration  3: Global Deviance = 4800.5126 eps = 0.000359     \nGAMLSS-RS iteration  4: Global Deviance = 4800.4943 eps = 0.000003     \n\n## extract, also works with newdata\nd &lt;- data.frame(\n  \"mean\" = mean(b),\n  \"median\" = median(b),\n  \"q95\" = quantile(b, probs = 0.95),\n  \"variance\" = variance(b),\n  \"pdf\" = pdf(b),\n  \"cdf\" = cdf(b)\n)\nprint(head(d))\n\n      mean   median      q95 variance        pdf        cdf\n1 63.03104 62.92909 70.42364 19.28276 0.06246974 0.18010635\n2 63.03104 62.92909 70.42364 19.28276 0.08730887 0.59589436\n3 63.03104 62.92909 70.42364 19.28276 0.02556281 0.05035205\n4 64.38740 64.28355 71.92811 20.06443 0.06986751 0.22764748\n5 67.18717 67.07943 75.03293 21.72338 0.02854450 0.92478019\n6 67.18717 67.07943 75.03293 21.72338 0.02660748 0.05735297",
    "crumbs": [
      "Documentation",
      "Families and links",
      "GDF"
    ]
  },
  {
    "objectID": "man/GDF.html#create-a-gdf-distribution",
    "href": "man/GDF.html#create-a-gdf-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "The GDF (gamlss2 Distribution Family) is a unified class with corresponding methods that represent all distributional families supported by the gamlss2 package. It enables seamless integration with the distributions3 workflow and provides a consistent interface for model fitting and distributional computations.\n\n\n\nGDF(family, parameters)\n\n\n\n\n\n\n\nfamily\n\n\ncharacter. Name of a gamlss2.family or a family provided by the gamlss.dist package, e.g, NO or BI for the normal or binomial distribution, respectively.\n\n\n\n\nparameters\n\n\nnumeric, matrix, list or data frame, see the examples.\n\n\n\n\n\n\nThe S3 class GDF is a slightly more general implementation of the S3 class GAMLSS tailored for gamlss2. For details please see the documentation of GAMLSS\n\n\n\nA GDF object, inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\ngamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## package and random seed\nlibrary(\"distributions3\")\nset.seed(6020)\n\n## one normal distribution\nX &lt;- GDF(\"NO\", c(mu = 1, sigma = 2))\nX\n\n[1] \"GDF NO(mu = 1, sigma = 2)\"\n\n## two normal distributions\nX &lt;- GDF(\"NO\", cbind(c(1, 1.5), c(0.6, 1.2)))\nX\n\n[1] \"GDF NO(mu = 1.0, sigma = 0.6)\" \"GDF NO(mu = 1.5, sigma = 1.2)\"\n\n## three Weibull distributions\nX &lt;- GDF(\"WEI\", list(mu = c(1, 1, 2), sigma = c(1, 2, 2)))\nX\n\n[1] \"GDF WEI(mu = 1, sigma = 1)\" \"GDF WEI(mu = 1, sigma = 2)\"\n[3] \"GDF WEI(mu = 2, sigma = 2)\"\n\n## see ?gamlss.dist::GAMLSS for the remainder of this example\n\n## example using gamlss2\ndata(\"abdom\", package = \"gamlss.data\")\n\n## estimate model\nb &lt;- gamlss2(y ~ s(x) | . | . | ., data = abdom, family = GA)\n\nGAMLSS-RS iteration  1: Global Deviance = 5039.2922 eps = 0.356998     \nGAMLSS-RS iteration  2: Global Deviance = 4802.238 eps = 0.047041     \nGAMLSS-RS iteration  3: Global Deviance = 4800.5126 eps = 0.000359     \nGAMLSS-RS iteration  4: Global Deviance = 4800.4943 eps = 0.000003     \n\n## extract, also works with newdata\nd &lt;- data.frame(\n  \"mean\" = mean(b),\n  \"median\" = median(b),\n  \"q95\" = quantile(b, probs = 0.95),\n  \"variance\" = variance(b),\n  \"pdf\" = pdf(b),\n  \"cdf\" = cdf(b)\n)\nprint(head(d))\n\n      mean   median      q95 variance        pdf        cdf\n1 63.03104 62.92909 70.42364 19.28276 0.06246974 0.18010635\n2 63.03104 62.92909 70.42364 19.28276 0.08730887 0.59589436\n3 63.03104 62.92909 70.42364 19.28276 0.02556281 0.05035205\n4 64.38740 64.28355 71.92811 20.06443 0.06986751 0.22764748\n5 67.18717 67.07943 75.03293 21.72338 0.02854450 0.92478019\n6 67.18717 67.07943 75.03293 21.72338 0.02660748 0.05735297",
    "crumbs": [
      "Documentation",
      "Families and links",
      "GDF"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html",
    "href": "man/Kumaraswamy.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). A Generalized Probability Density Function for Double-Bounded Random Processes. Journal of Hydrology, 46(1), 79-88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\n## with shiftlog and log-link\nb &lt;- gamlss2(y ~ s(x), data = d,\n  family = Kumaraswamy(a.link = shiftlog, b.link = \"log\"))\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "href": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). A Generalized Probability Density Function for Double-Bounded Random Processes. Journal of Hydrology, 46(1), 79-88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\n## with shiftlog and log-link\nb &lt;- gamlss2(y ~ s(x), data = d,\n  family = Kumaraswamy(a.link = shiftlog, b.link = \"log\"))\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html",
    "href": "man/gamlss2.family.html",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nA gamlss2 family object must be a list of class “gamlss2.family”, containing the necessary elements to define the response distribution and how it is handled during model fitting. The minimum requirements are as follows:\n\n\nfamily: the name of the distribution (character string).\n\n\nnames: a character vector of parameter names (e.g., c(“mu”, “sigma”)).\n\n\nlinks: a named character vector specifying the link function for each parameter (e.g., c(mu = “identity”, sigma = “log”)), or a list of link functions, e.g., see softplus.\n\n\npdf(y, par, log = FALSE, …): a function to evaluate the (log-)density.\n\n\nThe pdf() function must accept the response y, a named list par of evaluated parameter values (e.g., par$mu, par$sigma), a logical log, and optional additional arguments.\nOptionally, the family object may include:\n\n\nscore: a named list of functions (one per parameter), each computing the first derivative of the log-likelihood with respect to the linear predictor: score[param].\n\n\nhess: a named list of functions computing second derivatives (negative Hessian). For parameters mu and sigma, this includes: hess[“mu”], hess[“sigma”], and optionally cross derivatives like hess[“mu.sigma”].\n\n\nloglik(y, par, …): a function computing the total log-likelihood.\n\n\ncdf(y, par, …): cumulative distribution function.\n\n\nquantile(p, par, …): quantile function.\n\n\nrandom(n, par, …): random number generator.\n\n\nmean(par, …): mean function.\n\n\nvariance(par, …): variance function.\n\n\nskewness(par, …), kurtosis(par, …): optional higher-order moment functions.\n\n\ninitialize: a named list of initialization functions, one per parameter (e.g., initialize$mu(y, …)), used to generate starting values.\n\n\nvalid.response(x): a function that checks whether the response is valid (e.g., numeric, non-factor).\n\n\noptimizer(): an optional function to define a custom optimization method for use with gamlss2, see also link{RS}.\n\n\nIf the analytical score or Hessian functions are not provided, they will be approximated numerically. If quantile residuals are to be computed, a cdf() function must be provided.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"pdf\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$quantile(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $cdf() and $quantile() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"cdf\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"quantile\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $cdf() and $quantile() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "href": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nA gamlss2 family object must be a list of class “gamlss2.family”, containing the necessary elements to define the response distribution and how it is handled during model fitting. The minimum requirements are as follows:\n\n\nfamily: the name of the distribution (character string).\n\n\nnames: a character vector of parameter names (e.g., c(“mu”, “sigma”)).\n\n\nlinks: a named character vector specifying the link function for each parameter (e.g., c(mu = “identity”, sigma = “log”)), or a list of link functions, e.g., see softplus.\n\n\npdf(y, par, log = FALSE, …): a function to evaluate the (log-)density.\n\n\nThe pdf() function must accept the response y, a named list par of evaluated parameter values (e.g., par$mu, par$sigma), a logical log, and optional additional arguments.\nOptionally, the family object may include:\n\n\nscore: a named list of functions (one per parameter), each computing the first derivative of the log-likelihood with respect to the linear predictor: score[param].\n\n\nhess: a named list of functions computing second derivatives (negative Hessian). For parameters mu and sigma, this includes: hess[“mu”], hess[“sigma”], and optionally cross derivatives like hess[“mu.sigma”].\n\n\nloglik(y, par, …): a function computing the total log-likelihood.\n\n\ncdf(y, par, …): cumulative distribution function.\n\n\nquantile(p, par, …): quantile function.\n\n\nrandom(n, par, …): random number generator.\n\n\nmean(par, …): mean function.\n\n\nvariance(par, …): variance function.\n\n\nskewness(par, …), kurtosis(par, …): optional higher-order moment functions.\n\n\ninitialize: a named list of initialization functions, one per parameter (e.g., initialize$mu(y, …)), used to generate starting values.\n\n\nvalid.response(x): a function that checks whether the response is valid (e.g., numeric, non-factor).\n\n\noptimizer(): an optional function to define a custom optimization method for use with gamlss2, see also link{RS}.\n\n\nIf the analytical score or Hessian functions are not provided, they will be approximated numerically. If quantile residuals are to be computed, a cdf() function must be provided.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"pdf\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$quantile(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $cdf() and $quantile() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"cdf\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"quantile\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $cdf() and $quantile() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html",
    "href": "man/select_gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "href": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/find_family.html",
    "href": "man/find_family.html",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructure for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL, ...)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n## Find gamlss2 model.\nfind_gamlss2(formula, families = NULL, k = 2,\n  select = FALSE, verbose = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA family object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\nformula\n\n\nA model formula, see gamlss2.\n\n\n\n\nselect\n\n\nLogical, if set to select = TRUE, model term selection is enforced using model fitting function select_gamlss2.\n\n\n\n\n…\n\n\nFor function available_families(), arguments passed to the family objects, e.g., for setting link functions mu.link = “log”. Further arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family(). For function find_gamlss(), arguments are passed to available_families() and gamlss2.\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable family to the response using intercept-only models\nic &lt;- find_family(rent$R)\nprint(ic)\nwhich.min(ic)\n\n## fit parameters using the resulting BCCG family and plot the density\nfit_family(rent$R, family = BCCG)\n\n## another example using count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search a suitable discrete distribution / family\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\nwhich.min(ic)\n\n## fit parameters using the ZAPIG family\nfit_family(polio, family = ZAPIG)\n\n## search complete model for continuous response\n## b &lt;- find_gamlss2(R ~ s(Fl) + s(A) | . | . | ., data = rent,\n##   select = TRUE, mu.link = \"log\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "find_family"
    ]
  },
  {
    "objectID": "man/find_family.html#find-suitable-gamlss-families",
    "href": "man/find_family.html#find-suitable-gamlss-families",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructure for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL, ...)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n## Find gamlss2 model.\nfind_gamlss2(formula, families = NULL, k = 2,\n  select = FALSE, verbose = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA family object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\nformula\n\n\nA model formula, see gamlss2.\n\n\n\n\nselect\n\n\nLogical, if set to select = TRUE, model term selection is enforced using model fitting function select_gamlss2.\n\n\n\n\n…\n\n\nFor function available_families(), arguments passed to the family objects, e.g., for setting link functions mu.link = “log”. Further arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family(). For function find_gamlss(), arguments are passed to available_families() and gamlss2.\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable family to the response using intercept-only models\nic &lt;- find_family(rent$R)\nprint(ic)\nwhich.min(ic)\n\n## fit parameters using the resulting BCCG family and plot the density\nfit_family(rent$R, family = BCCG)\n\n## another example using count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search a suitable discrete distribution / family\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\nwhich.min(ic)\n\n## fit parameters using the ZAPIG family\nfit_family(polio, family = ZAPIG)\n\n## search complete model for continuous response\n## b &lt;- find_gamlss2(R ~ s(Fl) + s(A) | . | . | ., data = rent,\n##   select = TRUE, mu.link = \"log\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "find_family"
    ]
  },
  {
    "objectID": "man/new_formula.html",
    "href": "man/new_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "new_formula"
    ]
  },
  {
    "objectID": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "href": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "new_formula"
    ]
  },
  {
    "objectID": "man/misc.html",
    "href": "man/misc.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "misc"
    ]
  },
  {
    "objectID": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "href": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "misc"
    ]
  },
  {
    "objectID": "man/elm.html",
    "href": "man/elm.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for Extreme Learning Machine (ELM) model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nelm(x, k = 50, a = \"tanh\", ...)\n\n\n\n\n\n\n\nx\n\n\nA numeric vector or matrix, a factor, or a formula. If x is a formula, a design matrix is created using model.matrix. See the examples.\n\n\n\n\nk\n\n\nInteger, number of hidden units (random features) used to build the ELM design matrix.\n\n\n\n\na\n\n\nCharacter, activation function for the hidden units. Supported options are “logistic”, “tanh” (default), “relu”, “leaky_relu”, “elu”, “softplus”, “atan”, “softsign”, “gaussian”, “laplace”, “sine”, and “identity”.\n\n\n\n\n…\n\n\nFurther control arguments can be passed: criterion = “bic” (default) for shrinkage parameter selection and scale = TRUE (default) for internal scaling of the design matrix. Further arguments are passed to model.matrix if x is specified using a formula.\n\n\n\n\n\n\nThe ELM term constructs a randomized single-hidden-layer representation of the covariate(s) in x. Internally, a design matrix Z is built (including an intercept column), random weights are sampled, and the linear predictors Z %*% W are transformed through the activation function a to obtain the hidden-layer design matrix X. Columns of X are centered before estimation.\nInternal scaling. For numerical stability and comparability across terms, Z can be scaled internally (scale = TRUE). Intercept columns are left unchanged. If x is a factor, a QR-based group scaling is applied; otherwise, a column-wise center-and-scale normalization is used. The scaling transformation is stored and is reused automatically during prediction.\nActivation functions. The activation is applied element-wise to Z %*% W. For numerical stability, bounded activations are evaluated on clipped inputs (currently \\([-35, 35]\\)).\nReproducibility. Weights are sampled randomly. Use set.seed before calling elm() if you need reproducible results\n\n\n\nAn object representing a specials model term, used internally by gamlss2 during model fitting and prediction.\n\n\n\nHuang GB, Zhu QY, Siew CK (2006). Extreme Learning Machine: Theory and Applications. Neurocomputing, 70(1–3), 489–501. doi:10.1016/j.neucom.2005.12.126\nHuang GB, Zhu QY, Siew CK (2004). Extreme Learning Machine: A New Learning Scheme of Feedforward Neural Networks. In: Proceedings of IJCNN 2004, 2, 985–990. doi:10.1109/IJCNN.2004.1380068\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load data\ndata(\"SpirometryUS\")\n\n## subset for female\nd &lt;- subset(SpirometryUS, gender == \"Female\")\n\n## note, inner weight are sampled, set\n## the seed for reprodicibility\nset.seed(1328)\n\n## formula for all 4 parameters\nf &lt;- fev1 ~ elm(age,k=100,a=\"tanh\") | . | . | .\n\n## estimate model\nm &lt;- gamlss2(f, data = d, family = BCT)\n\n## estimated effects\nplot(m)\n\n## predict quantiles\nqu &lt;- c(0.025, seq(0.1, 0.9, by = 0.1), 0.975)\nfit &lt;- quantile(m, probs = qu)\n\n## plot\nplot(fev1 ~ age, data = d)\ni &lt;- order(d$age)\nmatplot(d$age[i], fit[i, ],\n  type = \"l\", lty = 1, lwd = 2,\n  col = c(2, rep(4, ncol(fit) - 1)),\n  add = TRUE)\n\n## main effects and interactions\nf &lt;- fev1 ~ s(age) + s(height) + s(weight) +\n  elm(~age+height+weight,k=200) | . | . | .\n\nm &lt;- gamlss2(f, data = d, family = BCT)\n\n## summary to inspect effect of interactions\n## of the elm()s\nsummary(m)\n\n## plot main effects\nplot(m)\n\n## quantile residuals\nplot(m, which = \"resid\")\n\n## prediction is handled automatically via\n## the special term interface\nn &lt;- 50\nnd &lt;- with(d, expand.grid(\n  \"age\" = seq(min(age), max(age), length = n),\n  \"weight\" = seq(min(weight), max(height), length = n)\n))\nnd$height &lt;- mean(d$height)\n\n## compute lower 2.5\nnd$fit &lt;- quantile(m, newdata = nd, probs = 0.025)\n\n## visualize\nn &lt;- length(unique(nd$age))\nage &lt;- sort(unique(nd$age))\nweight &lt;- sort(unique(nd$weight))\n\nz &lt;- matrix(nd$fit, n, n)\n\nimage(age, weight, z,\n      col = hcl.colors(100, \"YlOrRd\"),\n      xlab = \"age\", ylab = \"weight\")\ncontour(age, weight, z, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "elm"
    ]
  },
  {
    "objectID": "man/elm.html#extreme-learning-machine-model-terms",
    "href": "man/elm.html#extreme-learning-machine-model-terms",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for Extreme Learning Machine (ELM) model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nelm(x, k = 50, a = \"tanh\", ...)\n\n\n\n\n\n\n\nx\n\n\nA numeric vector or matrix, a factor, or a formula. If x is a formula, a design matrix is created using model.matrix. See the examples.\n\n\n\n\nk\n\n\nInteger, number of hidden units (random features) used to build the ELM design matrix.\n\n\n\n\na\n\n\nCharacter, activation function for the hidden units. Supported options are “logistic”, “tanh” (default), “relu”, “leaky_relu”, “elu”, “softplus”, “atan”, “softsign”, “gaussian”, “laplace”, “sine”, and “identity”.\n\n\n\n\n…\n\n\nFurther control arguments can be passed: criterion = “bic” (default) for shrinkage parameter selection and scale = TRUE (default) for internal scaling of the design matrix. Further arguments are passed to model.matrix if x is specified using a formula.\n\n\n\n\n\n\nThe ELM term constructs a randomized single-hidden-layer representation of the covariate(s) in x. Internally, a design matrix Z is built (including an intercept column), random weights are sampled, and the linear predictors Z %*% W are transformed through the activation function a to obtain the hidden-layer design matrix X. Columns of X are centered before estimation.\nInternal scaling. For numerical stability and comparability across terms, Z can be scaled internally (scale = TRUE). Intercept columns are left unchanged. If x is a factor, a QR-based group scaling is applied; otherwise, a column-wise center-and-scale normalization is used. The scaling transformation is stored and is reused automatically during prediction.\nActivation functions. The activation is applied element-wise to Z %*% W. For numerical stability, bounded activations are evaluated on clipped inputs (currently \\([-35, 35]\\)).\nReproducibility. Weights are sampled randomly. Use set.seed before calling elm() if you need reproducible results\n\n\n\nAn object representing a specials model term, used internally by gamlss2 during model fitting and prediction.\n\n\n\nHuang GB, Zhu QY, Siew CK (2006). Extreme Learning Machine: Theory and Applications. Neurocomputing, 70(1–3), 489–501. doi:10.1016/j.neucom.2005.12.126\nHuang GB, Zhu QY, Siew CK (2004). Extreme Learning Machine: A New Learning Scheme of Feedforward Neural Networks. In: Proceedings of IJCNN 2004, 2, 985–990. doi:10.1109/IJCNN.2004.1380068\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load data\ndata(\"SpirometryUS\")\n\n## subset for female\nd &lt;- subset(SpirometryUS, gender == \"Female\")\n\n## note, inner weight are sampled, set\n## the seed for reprodicibility\nset.seed(1328)\n\n## formula for all 4 parameters\nf &lt;- fev1 ~ elm(age,k=100,a=\"tanh\") | . | . | .\n\n## estimate model\nm &lt;- gamlss2(f, data = d, family = BCT)\n\n## estimated effects\nplot(m)\n\n## predict quantiles\nqu &lt;- c(0.025, seq(0.1, 0.9, by = 0.1), 0.975)\nfit &lt;- quantile(m, probs = qu)\n\n## plot\nplot(fev1 ~ age, data = d)\ni &lt;- order(d$age)\nmatplot(d$age[i], fit[i, ],\n  type = \"l\", lty = 1, lwd = 2,\n  col = c(2, rep(4, ncol(fit) - 1)),\n  add = TRUE)\n\n## main effects and interactions\nf &lt;- fev1 ~ s(age) + s(height) + s(weight) +\n  elm(~age+height+weight,k=200) | . | . | .\n\nm &lt;- gamlss2(f, data = d, family = BCT)\n\n## summary to inspect effect of interactions\n## of the elm()s\nsummary(m)\n\n## plot main effects\nplot(m)\n\n## quantile residuals\nplot(m, which = \"resid\")\n\n## prediction is handled automatically via\n## the special term interface\nn &lt;- 50\nnd &lt;- with(d, expand.grid(\n  \"age\" = seq(min(age), max(age), length = n),\n  \"weight\" = seq(min(weight), max(height), length = n)\n))\nnd$height &lt;- mean(d$height)\n\n## compute lower 2.5\nnd$fit &lt;- quantile(m, newdata = nd, probs = 0.025)\n\n## visualize\nn &lt;- length(unique(nd$age))\nage &lt;- sort(unique(nd$age))\nweight &lt;- sort(unique(nd$weight))\n\nz &lt;- matrix(nd$fit, n, n)\n\nimage(age, weight, z,\n      col = hcl.colors(100, \"YlOrRd\"),\n      xlab = \"age\", ylab = \"weight\")\ncontour(age, weight, z, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "elm"
    ]
  },
  {
    "objectID": "man/pb.html",
    "href": "man/pb.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26379.1781 eps = 0.390130     \nGAMLSS-RS iteration  2: Global Deviance = 26205.4923 eps = 0.006584     \nGAMLSS-RS iteration  3: Global Deviance = 26202.6474 eps = 0.000108     \nGAMLSS-RS iteration  4: Global Deviance = 26202.2604 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 26202.1179 eps = 0.000005     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "pb"
    ]
  },
  {
    "objectID": "man/pb.html#p-splines-for-gamlss",
    "href": "man/pb.html#p-splines-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26379.1781 eps = 0.390130     \nGAMLSS-RS iteration  2: Global Deviance = 26205.4923 eps = 0.006584     \nGAMLSS-RS iteration  3: Global Deviance = 26202.6474 eps = 0.000108     \nGAMLSS-RS iteration  4: Global Deviance = 26202.2604 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 26202.1179 eps = 0.000005     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "pb"
    ]
  },
  {
    "objectID": "man/bamlss2.html",
    "href": "man/bamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function bamlss2() is a convenience wrapper around gamlss2 to fit Bayesian GAMLSS models via MCMC sampling. It sets the optimizer to an MCMC routine and allows to specify n.iter, burnin, and thin directly.\n\n\n\nbamlss2(formula, n.iter = 1200, burnin = 200, thin = 1, maxit = 2, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. The model can include smooth terms as provided by the mgcv package.\n\n\n\n\nn.iter\n\n\nInteger, the total number of MCMC iterations.\n\n\n\n\nburnin\n\n\nInteger, the burn-in period.\n\n\n\n\nthin\n\n\nInteger, thinning parameter for saved samples.\n\n\n\n\nmaxit\n\n\nInteger, number of backfitting iterations to compute starting values before running MCMC. If maxit = 0, sampling starts from default or user-supplied starting values.\n\n\n\n\n…\n\n\nFurther arguments passed to gamlss2 and/or gamlss2_control.\n\n\n\n\n\n\nFunction bamlss2() calls gamlss2 and sets the optimizer to a Bayesian sampler. By default, a small number of backfitting iterations is performed to obtain reasonable starting values for the MCMC sampler.\nThe wrapper is designed to behave in line with gamlss() interfaces, i.e., it supports weights and offset arguments through gamlss2.\n\n\n\nAn object of class “bamlss2” inheriting from “gamlss2” containing the fitted model and posterior samples.\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, mcmc, BS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate Bayesian model\nb &lt;- bamlss2(f, data = abdom, family = BCT)\n\n## posterior summary\nsummary(b)\n\n## plot estimated effects\nplot(b)\n\n## plot samples\nplot(b, which = \"samples\")\n\n## predict parameters using samples\npm &lt;- predict(b, FUN = mean)\nprint(head(pm))\npsd &lt;- predict(b, FUN = sd)\nprint(head(psd))",
    "crumbs": [
      "Documentation",
      "Regression models",
      "bamlss2"
    ]
  },
  {
    "objectID": "man/bamlss2.html#bayesian-gamlss-wrapper",
    "href": "man/bamlss2.html#bayesian-gamlss-wrapper",
    "title": "gamlss2",
    "section": "",
    "text": "The function bamlss2() is a convenience wrapper around gamlss2 to fit Bayesian GAMLSS models via MCMC sampling. It sets the optimizer to an MCMC routine and allows to specify n.iter, burnin, and thin directly.\n\n\n\nbamlss2(formula, n.iter = 1200, burnin = 200, thin = 1, maxit = 2, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. The model can include smooth terms as provided by the mgcv package.\n\n\n\n\nn.iter\n\n\nInteger, the total number of MCMC iterations.\n\n\n\n\nburnin\n\n\nInteger, the burn-in period.\n\n\n\n\nthin\n\n\nInteger, thinning parameter for saved samples.\n\n\n\n\nmaxit\n\n\nInteger, number of backfitting iterations to compute starting values before running MCMC. If maxit = 0, sampling starts from default or user-supplied starting values.\n\n\n\n\n…\n\n\nFurther arguments passed to gamlss2 and/or gamlss2_control.\n\n\n\n\n\n\nFunction bamlss2() calls gamlss2 and sets the optimizer to a Bayesian sampler. By default, a small number of backfitting iterations is performed to obtain reasonable starting values for the MCMC sampler.\nThe wrapper is designed to behave in line with gamlss() interfaces, i.e., it supports weights and offset arguments through gamlss2.\n\n\n\nAn object of class “bamlss2” inheriting from “gamlss2” containing the fitted model and posterior samples.\n\n\n\nUmlauf, N., Klein, N., and Zeileis, A. (2018). BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond). Journal of Computational and Graphical Statistics, 27(3), 612–627. doi:10.1080/10618600.2017.1407325\n\n\n\ngamlss2, mcmc, BS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate Bayesian model\nb &lt;- bamlss2(f, data = abdom, family = BCT)\n\n## posterior summary\nsummary(b)\n\n## plot estimated effects\nplot(b)\n\n## plot samples\nplot(b, which = \"samples\")\n\n## predict parameters using samples\npm &lt;- predict(b, FUN = mean)\nprint(head(pm))\npsd &lt;- predict(b, FUN = sd)\nprint(head(psd))",
    "crumbs": [
      "Documentation",
      "Regression models",
      "bamlss2"
    ]
  },
  {
    "objectID": "man/RS_CG.html",
    "href": "man/RS_CG.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "href": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/gnet.html",
    "href": "man/gnet.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\ngnet(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”), default is “bic”.\nThe gnet() constructor differs from la. While la() implements a general framework for Lasso-type penalties (including group, ordinal, and nominal fusion constraints) and estimates the corresponding penalty matrices internally via iteratively reweighted least squares, gnet() delegates estimation entirely to glmnet. As a consequence, gnet() provides a standard Lasso model term based on a model.matrix representation, but does not support structured fusion penalties or custom penalty matrices. Instead, it offers a fast and robust interface to the glmnet algorithm and automatic selection of the shrinkage parameter using information criteria.\n\n\n\nThe gnet() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\nFriedman J, Tibshirani R, Hastie T (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. doi:10.18637/jss.v033.i01\nTay JK, Narasimhan B, Hastie T (2023). Elastic Net Regularization Paths for All Generalized Linear Models. Journal of Statistical Software, 106(1), 1-31. doi:10.18637/jss.v106.i01\n\n\n\nla, gamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term, note that for parameters nu\n## and tau model terms where not included as\n## the deviance would increase\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "gnet"
    ]
  },
  {
    "objectID": "man/gnet.html#lasso-with-glmnet",
    "href": "man/gnet.html#lasso-with-glmnet",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\ngnet(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”), default is “bic”.\nThe gnet() constructor differs from la. While la() implements a general framework for Lasso-type penalties (including group, ordinal, and nominal fusion constraints) and estimates the corresponding penalty matrices internally via iteratively reweighted least squares, gnet() delegates estimation entirely to glmnet. As a consequence, gnet() provides a standard Lasso model term based on a model.matrix representation, but does not support structured fusion penalties or custom penalty matrices. Instead, it offers a fast and robust interface to the glmnet algorithm and automatic selection of the shrinkage parameter using information criteria.\n\n\n\nThe gnet() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\nFriedman J, Tibshirani R, Hastie T (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22. doi:10.18637/jss.v033.i01\nTay JK, Narasimhan B, Hastie T (2023). Elastic Net Regularization Paths for All Generalized Linear Models. Journal of Statistical Software, 106(1), 1-31. doi:10.18637/jss.v106.i01\n\n\n\nla, gamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc) |\n  gnet(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term, note that for parameters nu\n## and tau model terms where not included as\n## the deviance would increase\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "gnet"
    ]
  },
  {
    "objectID": "man/special_terms.html",
    "href": "man/special_terms.html",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## compute median rent R estimate\nnd$fit &lt;- quantile(b, newdata = nd, probs = 0.5)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Documentation",
      "Model terms",
      "special_terms"
    ]
  },
  {
    "objectID": "man/special_terms.html#special-model-terms-for-gamlss",
    "href": "man/special_terms.html#special-model-terms-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## compute median rent R estimate\nnd$fit &lt;- quantile(b, newdata = nd, probs = 0.5)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Documentation",
      "Model terms",
      "special_terms"
    ]
  },
  {
    "objectID": "man/discretize.html",
    "href": "man/discretize.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(111)\nn &lt;- 1000\ny &lt;- rpois(n, lambda = 10)\n\n## create a discretized family using the\n## BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model\n## using the discretized family.\nfit_family(y, family = fam)\n\n## now with covariates\nx &lt;- runif(n, -3, 3)\ny &lt;- rpois(n, lambda = exp(1 + sin(x)))\n\nb &lt;- gamlss2(y ~ s(x) | s(x) | s(x) | s(x), family = fam)\nplot(b)\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "discretize"
    ]
  },
  {
    "objectID": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "href": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(111)\nn &lt;- 1000\ny &lt;- rpois(n, lambda = 10)\n\n## create a discretized family using the\n## BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model\n## using the discretized family.\nfit_family(y, family = fam)\n\n## now with covariates\nx &lt;- runif(n, -3, 3)\ny &lt;- rpois(n, lambda = exp(1 + sin(x)))\n\nb &lt;- gamlss2(y ~ s(x) | s(x) | s(x) | s(x), family = fam)\nplot(b)\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "discretize"
    ]
  },
  {
    "objectID": "man/stepwise.html",
    "href": "man/stepwise.html",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Documentation",
      "Regression models",
      "stepwise"
    ]
  },
  {
    "objectID": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "href": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Documentation",
      "Regression models",
      "stepwise"
    ]
  },
  {
    "objectID": "man/fake_formula.html",
    "href": "man/fake_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "Create a simplified or \"fake\" version of a model formula for internal use in gamlss2. Many model formulas in gamlss2 may contain complex terms such as smoothing functions, tensor-product interactions, distributional components, or multiple right-hand sides. These extended formulas cannot be passed directly to model.frame, which expects a traditional formula as used in lm or glm.\nfake_formula() therefore \"fakes\" a standard formula by rewriting the original model specification into a form that is acceptable to model.frame, while preserving all variable transformations (e.g., log(), exp(), arithmetic expressions) and extracting any special model terms. These special terms can then be handled separately during model setup and fitting.\nIn summary, the function separates the parsing of model terms from the creation of the data frame: it provides a clean, simplified formula that ensures correct extraction and evaluation of variables.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\nIn some versions of the RStudio IDE, printing or inspecting a fake_formula() object may trigger a message of the form\n‘length = 2’ in coercion to ‘logical(1)’.\nThis is due to the way RStudio internally inspects objects of class Formula, whose length() method returns a two-element vector (reflecting the number of left- and right-hand side components). The message does not indicate a problem with fake_formula(), and the returned object is valid and works correctly with model.frame() and subsequent processing. The message does not appear in a standard R session outside RStudio.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula, log(x3) should be kept\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\n## again, keep log(x3)\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | \n    z2 + x1 + exp(x3) + x10\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "href": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "title": "gamlss2",
    "section": "",
    "text": "Create a simplified or \"fake\" version of a model formula for internal use in gamlss2. Many model formulas in gamlss2 may contain complex terms such as smoothing functions, tensor-product interactions, distributional components, or multiple right-hand sides. These extended formulas cannot be passed directly to model.frame, which expects a traditional formula as used in lm or glm.\nfake_formula() therefore \"fakes\" a standard formula by rewriting the original model specification into a form that is acceptable to model.frame, while preserving all variable transformations (e.g., log(), exp(), arithmetic expressions) and extracting any special model terms. These special terms can then be handled separately during model setup and fitting.\nIn summary, the function separates the parsing of model terms from the creation of the data frame: it provides a clean, simplified formula that ensures correct extraction and evaluation of variables.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\nIn some versions of the RStudio IDE, printing or inspecting a fake_formula() object may trigger a message of the form\n‘length = 2’ in coercion to ‘logical(1)’.\nThis is due to the way RStudio internally inspects objects of class Formula, whose length() method returns a two-element vector (reflecting the number of left- and right-hand side components). The message does not indicate a problem with fake_formula(), and the returned object is valid and works correctly with model.frame() and subsequent processing. The message does not appear in a standard R session outside RStudio.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula, log(x3) should be kept\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\n## again, keep log(x3)\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | \n    z2 + x1 + exp(x3) + x10\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/la.html",
    "href": "man/la.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “ordinal” the ordinal fusion penalty and type = 4 or type = “nominal” the nominal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” (BIC, default) for shrinkage parameter selection (other options are “aic”, “aicc”, “gcv” or “gaic” with default K = 2), arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the corrected Akaike Information Criterion (cAIC).\nla() differs from the model term constructor gnet. While gnet() delegates estimation to glmnet and applies the standard Lasso penalty to a design matrix generated by model.matrix, la() provides a unified framework for several Lasso-type penalties (normal, group, ordinal and nominal fusion). This allows for structured shrinkage, for example by fusing levels of categorical covariates, which is not available in gnet(). In addition, an optional ridge component can be added via add_ridge = TRUE in the gamlss2 call, yielding an elastic-net-type penalty for each la() term.\nFor numerical stability and comparability of shrinkage parameters across different Lasso-type penalties, the design matrix of each la() model term is internally scaled before estimation. The scaling depends on the selected penalty type and is chosen such that it preserves the structural meaning of the penalty.\n\n\ntype = “group”\n\n\nFor group Lasso penalties, factor-specific design matrices are block-standardized using a QR decomposition. The columns within each factor block are transformed to an orthonormal basis (up to a factor \\(\\sqrt{n}\\)), ensuring that the group penalty is invariant to the chosen contrast coding and that groups of different sizes are penalized on a comparable scale. This transformation may mix columns within a block but preserves the column space of the design matrix.\n\n\ntype = “ordinal” and type = “nominal”\n\n\nFor ordinal and nominal fusion penalties, no column mixing is applied. Instead, each factor block is multiplied by a single scalar chosen such that the root mean square column norm equals \\(\\sqrt{n}\\). This scalar scaling preserves the interpretation of adjacent or pairwise differences between factor levels, which form the basis of the fusion penalty.\n\n\ntype = “normal”\n\n\nFor normal Lasso penalties, numeric covariates and matrices are scaled column-wise so that each column has Euclidean norm \\(\\sqrt{n}\\). This corresponds to standard Lasso scaling and ensures that shrinkage is applied uniformly across covariates. If a factor is used with a normal penalty, a single scalar scaling is applied, analogous to the ordinal and nominal cases.\n\n\nThe applied scaling is stored internally and automatically reused during prediction.\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nGroll A, Hambuckers J, Kneib T, Umlauf N (2019). Lasso-Type Penalization in the Framework of Generalized Additive Models for Location, Scale and Shape. Computational Statistics & Data Analysis, 140(12), 59-73. doi:10.1016/j.csda.2019.06.005\nOelker MR, Tutz G (2017). A Uniform Framework for Combination of Penalties in Generalized Structured Models. Advances in Data Analysis and Classification, 11(1), 97-120. doi:10.1007/s11634-015-0205-y\n\n\n\ngnet, gamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 120, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a NO model\nf &lt;- R ~ la(Flc,type=3) + la(Ac,type=3) + la(loc,type=3) | .\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = NO)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 1)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"mu.la(Flc\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = 10, names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = 10, main = \"Fused Lasso\",\n  info = TRUE, cex.info = 0.9)\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X %*% beta$mu\nsigma &lt;- exp(-1 + X %*% beta$sigma)\n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=4) | la(X,type=4)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", zoom = 10)\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\nthres &lt;- 0.01\n\n## true positive rate\ntp &lt;- mean(c(abs(cb_mu[beta$mu &gt; 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma &gt; 0]) &gt; thres))\nprint(tp)\n\n## false positive rate, needs threshold\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))\nprint(fp)\n\n## fused ordinal Lasso P-spline example with\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n## P-spline design matrix\nX &lt;- smooth.construct(s(yday,bs=\"ps\",k=20), data = HarzTraffic, NULL)$X\ni &lt;- order(HarzTraffic$yday)\nwith(HarzTraffic, matplot(yday[i], X[i, ], type = \"l\", lty = 1))\n\n## estimate model\nf &lt;- bikes ~ la(X,type=3,ridge=TRUE) | . | .\nb &lt;- gamlss2(f, data = HarzTraffic, family = SICHEL)\nsummary(b)\nplot(b, which = \"resid\")\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\", zoom = 15)\n\n## plot estimated quantiles\nqu &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\nplot(bikes ~ yday, data = HarzTraffic, col = adjustcolor(1, alpha = 0.3))\nwith(HarzTraffic, matplot(yday[i], qu[i, ],\n  type = \"l\", col = c(3, 1, 2), lty = 1, lwd = 2, add = TRUE))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "la"
    ]
  },
  {
    "objectID": "man/la.html#lasso-model-terms",
    "href": "man/la.html#lasso-model-terms",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “ordinal” the ordinal fusion penalty and type = 4 or type = “nominal” the nominal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” (BIC, default) for shrinkage parameter selection (other options are “aic”, “aicc”, “gcv” or “gaic” with default K = 2), arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the corrected Akaike Information Criterion (cAIC).\nla() differs from the model term constructor gnet. While gnet() delegates estimation to glmnet and applies the standard Lasso penalty to a design matrix generated by model.matrix, la() provides a unified framework for several Lasso-type penalties (normal, group, ordinal and nominal fusion). This allows for structured shrinkage, for example by fusing levels of categorical covariates, which is not available in gnet(). In addition, an optional ridge component can be added via add_ridge = TRUE in the gamlss2 call, yielding an elastic-net-type penalty for each la() term.\nFor numerical stability and comparability of shrinkage parameters across different Lasso-type penalties, the design matrix of each la() model term is internally scaled before estimation. The scaling depends on the selected penalty type and is chosen such that it preserves the structural meaning of the penalty.\n\n\ntype = “group”\n\n\nFor group Lasso penalties, factor-specific design matrices are block-standardized using a QR decomposition. The columns within each factor block are transformed to an orthonormal basis (up to a factor \\(\\sqrt{n}\\)), ensuring that the group penalty is invariant to the chosen contrast coding and that groups of different sizes are penalized on a comparable scale. This transformation may mix columns within a block but preserves the column space of the design matrix.\n\n\ntype = “ordinal” and type = “nominal”\n\n\nFor ordinal and nominal fusion penalties, no column mixing is applied. Instead, each factor block is multiplied by a single scalar chosen such that the root mean square column norm equals \\(\\sqrt{n}\\). This scalar scaling preserves the interpretation of adjacent or pairwise differences between factor levels, which form the basis of the fusion penalty.\n\n\ntype = “normal”\n\n\nFor normal Lasso penalties, numeric covariates and matrices are scaled column-wise so that each column has Euclidean norm \\(\\sqrt{n}\\). This corresponds to standard Lasso scaling and ensures that shrinkage is applied uniformly across covariates. If a factor is used with a normal penalty, a single scalar scaling is applied, analogous to the ordinal and nominal cases.\n\n\nThe applied scaling is stored internally and automatically reused during prediction.\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nGroll A, Hambuckers J, Kneib T, Umlauf N (2019). Lasso-Type Penalization in the Framework of Generalized Additive Models for Location, Scale and Shape. Computational Statistics & Data Analysis, 140(12), 59-73. doi:10.1016/j.csda.2019.06.005\nOelker MR, Tutz G (2017). A Uniform Framework for Combination of Penalties in Generalized Structured Models. Advances in Data Analysis and Classification, 11(1), 97-120. doi:10.1007/s11634-015-0205-y\n\n\n\ngnet, gamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 120, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a NO model\nf &lt;- R ~ la(Flc,type=3) + la(Ac,type=3) + la(loc,type=3) | .\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = NO)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 1)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"mu.la(Flc\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = 10, names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 1,\n  zoom = 10, main = \"Fused Lasso\",\n  info = TRUE, cex.info = 0.9)\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X %*% beta$mu\nsigma &lt;- exp(-1 + X %*% beta$sigma)\n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=4) | la(X,type=4)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", zoom = 10)\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\nthres &lt;- 0.01\n\n## true positive rate\ntp &lt;- mean(c(abs(cb_mu[beta$mu &gt; 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma &gt; 0]) &gt; thres))\nprint(tp)\n\n## false positive rate, needs threshold\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))\nprint(fp)\n\n## fused ordinal Lasso P-spline example with\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n## P-spline design matrix\nX &lt;- smooth.construct(s(yday,bs=\"ps\",k=20), data = HarzTraffic, NULL)$X\ni &lt;- order(HarzTraffic$yday)\nwith(HarzTraffic, matplot(yday[i], X[i, ], type = \"l\", lty = 1))\n\n## estimate model\nf &lt;- bikes ~ la(X,type=3,ridge=TRUE) | . | .\nb &lt;- gamlss2(f, data = HarzTraffic, family = SICHEL)\nsummary(b)\nplot(b, which = \"resid\")\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\", zoom = 15)\n\n## plot estimated quantiles\nqu &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\nplot(bikes ~ yday, data = HarzTraffic, col = adjustcolor(1, alpha = 0.3))\nwith(HarzTraffic, matplot(yday[i], qu[i, ],\n  type = \"l\", col = c(3, 1, 2), lty = 1, lwd = 2, add = TRUE))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "la"
    ]
  },
  {
    "objectID": "man/ologit.html",
    "href": "man/ologit.html",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nOL(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe OL() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = OL(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = OL(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink functions: location = identity, theta1 = identity, delta2 = identity\n*--------\nCoefficients:\n                        Estimate Std. Error t value Pr(&gt;|t|)  \nlocation.(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nlocation.InflMedium       0.5671     0.5367   1.057   0.2947  \nlocation.InflHigh         1.2904     0.5572   2.316   0.0238 *\nlocation.TypeApartment   -0.5731     0.6345  -0.903   0.3698  \nlocation.TypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nlocation.TypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nlocation.ContHigh         0.3607     0.4462   0.808   0.4219  \ntheta1.(Intercept)       -0.6932  3481.4687   0.000   0.9998  \ndelta2.(Intercept)        0.1724     0.2191   0.787   0.4344  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = -2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533"
  },
  {
    "objectID": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "href": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nOL(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe OL() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = OL(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = OL(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink functions: location = identity, theta1 = identity, delta2 = identity\n*--------\nCoefficients:\n                        Estimate Std. Error t value Pr(&gt;|t|)  \nlocation.(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nlocation.InflMedium       0.5671     0.5367   1.057   0.2947  \nlocation.InflHigh         1.2904     0.5572   2.316   0.0238 *\nlocation.TypeApartment   -0.5731     0.6345  -0.903   0.3698  \nlocation.TypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nlocation.TypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nlocation.ContHigh         0.3607     0.4462   0.808   0.4219  \ntheta1.(Intercept)       -0.6932  3481.4687   0.000   0.9998  \ndelta2.(Intercept)        0.1724     0.2191   0.787   0.4344  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = -2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533"
  }
]