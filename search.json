[
  {
    "objectID": "CITATION.html",
    "href": "CITATION.html",
    "title": "Citation",
    "section": "",
    "text": "Citation\nTo cite GAMLSS in publications use:\n\nR.A. Rigby, D.M. Stasinopoulos (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x."
  },
  {
    "objectID": "man/random.html",
    "href": "man/random.html",
    "title": "gamlss2",
    "section": "",
    "text": "Random effects can be included in gamlss2 models in two ways.\nThe first uses s() with bs = “re” for simple random effects, i.e., when a single factor is entered into the model as a smoother. This approach relies on the s() function from the mgcv package. For example, if area is a factor with several levels, then s(area, bs = “re”) shrinks the level-specific effects of area towards their overall mean.\nThe second, more general approach uses the model term constructor re(), which provides an interface to the specialised random-effects functionality in the nlme package. This allows fitting more complex random-effects structures.\nThis documentation focuses on the re() function, but we also provide examples using s(…, bs = “re”).\n\n\n\nre(random, correlation = NULL, ...)\n\n\n\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the lme() function.\n\n\n\n\ncorrelation\n\n\nAn optional correlation object, see lme().\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the lme function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor,\n## setup formula first\nf &lt;- distance ~ age11 + re(~age11|Subject)\n\n## estimate model\nb &lt;- gamlss2(f, data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6623 eps = 0.392353     \nGAMLSS-RS iteration  2: Global Deviance = 326.6623 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", term = \"age11\", elements = \"model\")\nsummary(st)\n\nLinear mixed-effects model fit by maximum likelihood\n  Data: structure(list(age11 = c(-3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3), Subject = structure(c(15L, 15L,  15L, 15L, 3L, 3L, 3L, 3L, 7L, 7L, 7L, 7L, 14L, 14L, 14L, 14L,  2L, 2L, 2L, 2L, 13L, 13L, 13L, 13L, 5L, 5L, 5L, 5L, 6L, 6L, 6L,  6L, 11L, 11L, 11L, 11L, 16L, 16L, 16L, 16L, 4L, 4L, 4L, 4L, 8L,  8L, 8L, 8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 12L, 12L, 12L,  12L, 1L, 1L, 1L, 1L, 20L, 20L, 20L, 20L, 23L, 23L, 23L, 23L,  25L, 25L, 25L, 25L, 26L, 26L, 26L, 26L, 21L, 21L, 21L, 21L, 19L,  19L, 19L, 19L, 22L, 22L, 22L, 22L, 24L, 24L, 24L, 24L, 18L, 18L,  18L, 18L, 17L, 17L, 17L, 17L, 27L, 27L, 27L, 27L), levels = c(\"M16\",  \"M05\", \"M02\", \"M11\", \"M07\", \"M08\", \"M03\", \"M12\", \"M13\", \"M14\",  \"M09\", \"M15\", \"M06\", \"M04\", \"M01\", \"M10\", \"F10\", \"F09\", \"F06\",  \"F01\", \"F05\", \"F07\", \"F02\", \"F08\", \"F03\", \"F04\", \"F11\"), class = c(\"ordered\",  \"factor\")), response_z = c(3.95740740740771, 1.63703703703704,  4.31666666666667, 4.9962962962963, -0.542592592592602, -0.862962962962968,  -1.68333333333333, 0.496296296296297, 0.957407407407398, -0.862962962962968,  -0.683333333333334, 1.4962962962963, 3.4574074074074, 4.13703703703703,  1.81666666666666, 0.996296296296297, -2.0425925925926, 0.137037037037032,  -2.18333333333333, -0.00370370370369955, 2.4574074074074, 2.13703703703704,  2.31666666666666, 2.4962962962963, -0.0425925925926016, -1.36296296296297,  -0.183333333333334, 0.496296296296297, 1.9574074074074, -1.86296296296297,  -0.183333333333334, -0.5037037037037, 0.957407407407398, -2.86296296296297,  6.31666666666666, -0.00370370370369955, 5.45740740740739, 4.63703703703703,  6.31666666666666, 5.49629629629629, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -1.0037037037037, -0.542592592592602, 0.137037037037032,  -0.683333333333334, 1.9962962962963, -5.0425925925926, 1.13703703703703,  1.31666666666667, 3.4962962962963, 0.457407407407402, 2.13703703703704,  0.81666666666667, -0.00370370370369955, 0.957407407407402, 1.13703703703703,  1.31666666666667, 3.9962962962963, -0.0425925925926016, -1.86296296296297,  -1.18333333333333, -1.0037037037037, -1.0425925925926, -3.36296296296297,  -3.18333333333333, -3.0037037037037, -1.0425925925926, -1.86296296296297,  -0.683333333333334, -0.5037037037037, -1.5425925925926, 0.637037037037032,  -0.183333333333334, -0.00370370370369955, 1.4574074074074, 1.13703703703703,  0.316666666666666, 0.496296296296297, -0.542592592592602, -0.362962962962968,  -2.18333333333333, -2.5037037037037, -2.0425925925926, -2.36296296296297,  -3.68333333333334, -3.5037037037037, -0.542592592592602, -0.862962962962968,  -1.68333333333333, -1.0037037037037, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -2.0037037037037, -2.04259259259261, -2.36296296296297,  -2.68333333333333, -4.5037037037037, -5.5425925925926, -4.36296296296297,  -5.68333333333334, -6.5037037037037, 2.4574074074074, 1.63703703703704,  3.31666666666666, 1.9962962962963), weights_w = c(0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369)), terms = ~age11 +      Subject, row.names = c(NA, 108L), class = \"data.frame\") \n       AIC      BIC    logLik\n  449.2116 462.6223 -219.6058\n\nRandom effects:\n Formula: ~age11 | Subject\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 2.0906352 (Intr)\nage11       0.2149235 0.521 \nResidual    3.8365552       \n\nVariance function:\n Structure: fixed weights\n Formula: ~weights_w \nFixed effects:  response_z ~ 1 \n                   Value Std.Error DF      t-value p-value\n(Intercept) 6.064444e-16 0.4048917 81 1.497794e-15       1\n\nStandardized Within-Group Residuals:\n         Min           Q1          Med           Q3          Max \n-3.305976369 -0.487428882  0.007598099  0.482237876  3.922787577 \n\nNumber of Observations: 108\nNumber of Groups: 27 \n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4092 eps = 0.133537     \nGAMLSS-RS iteration  3: Global Deviance = 340.4089 eps = 0.080992     \nGAMLSS-RS iteration  4: Global Deviance = 325.4676 eps = 0.043892     \nGAMLSS-RS iteration  5: Global Deviance = 319.3778 eps = 0.018710     \nGAMLSS-RS iteration  6: Global Deviance = 317.1286 eps = 0.007042     \nGAMLSS-RS iteration  7: Global Deviance = 316.3204 eps = 0.002548     \nGAMLSS-RS iteration  8: Global Deviance = 316.0276 eps = 0.000925     \nGAMLSS-RS iteration  9: Global Deviance = 315.913 eps = 0.000362     \nGAMLSS-RS iteration 10: Global Deviance = 315.865 eps = 0.000151     \nGAMLSS-RS iteration 11: Global Deviance = 315.8413 eps = 0.000075     \nGAMLSS-RS iteration 12: Global Deviance = 315.828 eps = 0.000042     \nGAMLSS-RS iteration 13: Global Deviance = 315.8178 eps = 0.000032     \nGAMLSS-RS iteration 14: Global Deviance = 315.8112 eps = 0.000020     \nGAMLSS-RS iteration 15: Global Deviance = 315.8054 eps = 0.000018     \nGAMLSS-RS iteration 16: Global Deviance = 315.8023 eps = 0.000009     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ sin1 + cos1 +\n  re(~ 1 | Mare) +\n  re(~ sin1 - 1 | Mare, correlation = corARMA(q = 2))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1561.4397 eps = 0.164702     \nGAMLSS-RS iteration  2: Global Deviance = 1561.3891 eps = 0.000032     \nGAMLSS-RS iteration  3: Global Deviance = 1561.3816 eps = 0.000004     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.5015 eps = 0.056241     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6605 eps = 0.006850     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7658 eps = 0.000627     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6839 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6744 eps = 0.000006     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n}\n\n## simulated data\nset.seed(1328)\n\nn &lt;- 10000\nk &lt;- 500\n\n## generate random effects\nf &lt;- as.factor(sample(1:k, size = n, replace = TRUE))\nref &lt;- rnorm(k, sd = 0.6)\n\n## random effects only for sigma\ny &lt;- rBCT(n, mu = 10, sigma = exp(-1 + ref[f]), tau = 10)\n\n## estimate model\nb &lt;- gamlss2(y ~ 1 | re(~ 1 | f), family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 54284.8778 eps = 0.443825     \nGAMLSS-RS iteration  2: Global Deviance = 53798.1163 eps = 0.008966     \nGAMLSS-RS iteration  3: Global Deviance = 53767.8702 eps = 0.000562     \nGAMLSS-RS iteration  4: Global Deviance = 53761.3751 eps = 0.000120     \nGAMLSS-RS iteration  5: Global Deviance = 53758.2934 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 53757.5692 eps = 0.000013     \nGAMLSS-RS iteration  7: Global Deviance = 53756.9982 eps = 0.000010     \nGAMLSS-RS iteration  8: Global Deviance = 53756.5246 eps = 0.000008     \n\n## extract fitted random effects\ncb &lt;- coef(b, full = TRUE)\ncb &lt;- cb[grepl(\"re\", names(cb), fixed = TRUE)]\n\n## compare\nplot(cb, ref, main = round(mean((cb - ref)^2), 2))\nabline(0, 1, lwd = 2, col = 4)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "random"
    ]
  },
  {
    "objectID": "man/random.html#random-effects",
    "href": "man/random.html#random-effects",
    "title": "gamlss2",
    "section": "",
    "text": "Random effects can be included in gamlss2 models in two ways.\nThe first uses s() with bs = “re” for simple random effects, i.e., when a single factor is entered into the model as a smoother. This approach relies on the s() function from the mgcv package. For example, if area is a factor with several levels, then s(area, bs = “re”) shrinks the level-specific effects of area towards their overall mean.\nThe second, more general approach uses the model term constructor re(), which provides an interface to the specialised random-effects functionality in the nlme package. This allows fitting more complex random-effects structures.\nThis documentation focuses on the re() function, but we also provide examples using s(…, bs = “re”).\n\n\n\nre(random, correlation = NULL, ...)\n\n\n\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the lme() function.\n\n\n\n\ncorrelation\n\n\nAn optional correlation object, see lme().\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the lme function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor,\n## setup formula first\nf &lt;- distance ~ age11 + re(~age11|Subject)\n\n## estimate model\nb &lt;- gamlss2(f, data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6623 eps = 0.392353     \nGAMLSS-RS iteration  2: Global Deviance = 326.6623 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", term = \"age11\", elements = \"model\")\nsummary(st)\n\nLinear mixed-effects model fit by maximum likelihood\n  Data: structure(list(age11 = c(-3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1,  1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3, -3, -1, 1, 3,  -3, -1, 1, 3, -3, -1, 1, 3), Subject = structure(c(15L, 15L,  15L, 15L, 3L, 3L, 3L, 3L, 7L, 7L, 7L, 7L, 14L, 14L, 14L, 14L,  2L, 2L, 2L, 2L, 13L, 13L, 13L, 13L, 5L, 5L, 5L, 5L, 6L, 6L, 6L,  6L, 11L, 11L, 11L, 11L, 16L, 16L, 16L, 16L, 4L, 4L, 4L, 4L, 8L,  8L, 8L, 8L, 9L, 9L, 9L, 9L, 10L, 10L, 10L, 10L, 12L, 12L, 12L,  12L, 1L, 1L, 1L, 1L, 20L, 20L, 20L, 20L, 23L, 23L, 23L, 23L,  25L, 25L, 25L, 25L, 26L, 26L, 26L, 26L, 21L, 21L, 21L, 21L, 19L,  19L, 19L, 19L, 22L, 22L, 22L, 22L, 24L, 24L, 24L, 24L, 18L, 18L,  18L, 18L, 17L, 17L, 17L, 17L, 27L, 27L, 27L, 27L), levels = c(\"M16\",  \"M05\", \"M02\", \"M11\", \"M07\", \"M08\", \"M03\", \"M12\", \"M13\", \"M14\",  \"M09\", \"M15\", \"M06\", \"M04\", \"M01\", \"M10\", \"F10\", \"F09\", \"F06\",  \"F01\", \"F05\", \"F07\", \"F02\", \"F08\", \"F03\", \"F04\", \"F11\"), class = c(\"ordered\",  \"factor\")), response_z = c(3.95740740740771, 1.63703703703704,  4.31666666666667, 4.9962962962963, -0.542592592592602, -0.862962962962968,  -1.68333333333333, 0.496296296296297, 0.957407407407398, -0.862962962962968,  -0.683333333333334, 1.4962962962963, 3.4574074074074, 4.13703703703703,  1.81666666666666, 0.996296296296297, -2.0425925925926, 0.137037037037032,  -2.18333333333333, -0.00370370370369955, 2.4574074074074, 2.13703703703704,  2.31666666666666, 2.4962962962963, -0.0425925925926016, -1.36296296296297,  -0.183333333333334, 0.496296296296297, 1.9574074074074, -1.86296296296297,  -0.183333333333334, -0.5037037037037, 0.957407407407398, -2.86296296296297,  6.31666666666666, -0.00370370370369955, 5.45740740740739, 4.63703703703703,  6.31666666666666, 5.49629629629629, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -1.0037037037037, -0.542592592592602, 0.137037037037032,  -0.683333333333334, 1.9962962962963, -5.0425925925926, 1.13703703703703,  1.31666666666667, 3.4962962962963, 0.457407407407402, 2.13703703703704,  0.81666666666667, -0.00370370370369955, 0.957407407407402, 1.13703703703703,  1.31666666666667, 3.9962962962963, -0.0425925925926016, -1.86296296296297,  -1.18333333333333, -1.0037037037037, -1.0425925925926, -3.36296296296297,  -3.18333333333333, -3.0037037037037, -1.0425925925926, -1.86296296296297,  -0.683333333333334, -0.5037037037037, -1.5425925925926, 0.637037037037032,  -0.183333333333334, -0.00370370370369955, 1.4574074074074, 1.13703703703703,  0.316666666666666, 0.496296296296297, -0.542592592592602, -0.362962962962968,  -2.18333333333333, -2.5037037037037, -2.0425925925926, -2.36296296296297,  -3.68333333333334, -3.5037037037037, -0.542592592592602, -0.862962962962968,  -1.68333333333333, -1.0037037037037, 0.957407407407398, -0.362962962962968,  -1.18333333333333, -2.0037037037037, -2.04259259259261, -2.36296296296297,  -2.68333333333333, -4.5037037037037, -5.5425925925926, -4.36296296296297,  -5.68333333333334, -6.5037037037037, 2.4574074074074, 1.63703703703704,  3.31666666666666, 1.9962962962963), weights_w = c(0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369, 0.116596837376369,  0.116596837376369, 0.116596837376369, 0.116596837376369)), terms = ~age11 +      Subject, row.names = c(NA, 108L), class = \"data.frame\") \n       AIC      BIC    logLik\n  449.2116 462.6223 -219.6058\n\nRandom effects:\n Formula: ~age11 | Subject\n Structure: General positive-definite, Log-Cholesky parametrization\n            StdDev    Corr  \n(Intercept) 2.0906352 (Intr)\nage11       0.2149235 0.521 \nResidual    3.8365552       \n\nVariance function:\n Structure: fixed weights\n Formula: ~weights_w \nFixed effects:  response_z ~ 1 \n                   Value Std.Error DF      t-value p-value\n(Intercept) 6.064444e-16 0.4048917 81 1.497794e-15       1\n\nStandardized Within-Group Residuals:\n         Min           Q1          Med           Q3          Max \n-3.305976369 -0.487428882  0.007598099  0.482237876  3.922787577 \n\nNumber of Observations: 108\nNumber of Groups: 27 \n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.4959 eps = 0.204786     \nGAMLSS-RS iteration  2: Global Deviance = 370.4092 eps = 0.133537     \nGAMLSS-RS iteration  3: Global Deviance = 340.4089 eps = 0.080992     \nGAMLSS-RS iteration  4: Global Deviance = 325.4676 eps = 0.043892     \nGAMLSS-RS iteration  5: Global Deviance = 319.3778 eps = 0.018710     \nGAMLSS-RS iteration  6: Global Deviance = 317.1286 eps = 0.007042     \nGAMLSS-RS iteration  7: Global Deviance = 316.3204 eps = 0.002548     \nGAMLSS-RS iteration  8: Global Deviance = 316.0276 eps = 0.000925     \nGAMLSS-RS iteration  9: Global Deviance = 315.913 eps = 0.000362     \nGAMLSS-RS iteration 10: Global Deviance = 315.865 eps = 0.000151     \nGAMLSS-RS iteration 11: Global Deviance = 315.8413 eps = 0.000075     \nGAMLSS-RS iteration 12: Global Deviance = 315.828 eps = 0.000042     \nGAMLSS-RS iteration 13: Global Deviance = 315.8178 eps = 0.000032     \nGAMLSS-RS iteration 14: Global Deviance = 315.8112 eps = 0.000020     \nGAMLSS-RS iteration 15: Global Deviance = 315.8054 eps = 0.000018     \nGAMLSS-RS iteration 16: Global Deviance = 315.8023 eps = 0.000009     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ sin1 + cos1 +\n  re(~ 1 | Mare) +\n  re(~ sin1 - 1 | Mare, correlation = corARMA(q = 2))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1561.4397 eps = 0.164702     \nGAMLSS-RS iteration  2: Global Deviance = 1561.3891 eps = 0.000032     \nGAMLSS-RS iteration  3: Global Deviance = 1561.3816 eps = 0.000004     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1073 eps = 0.185743     \nGAMLSS-RS iteration  2: Global Deviance = 1436.5015 eps = 0.056241     \nGAMLSS-RS iteration  3: Global Deviance = 1426.6605 eps = 0.006850     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7658 eps = 0.000627     \nGAMLSS-RS iteration  5: Global Deviance = 1425.6839 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6744 eps = 0.000006     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n}\n\n## simulated data\nset.seed(1328)\n\nn &lt;- 10000\nk &lt;- 500\n\n## generate random effects\nf &lt;- as.factor(sample(1:k, size = n, replace = TRUE))\nref &lt;- rnorm(k, sd = 0.6)\n\n## random effects only for sigma\ny &lt;- rBCT(n, mu = 10, sigma = exp(-1 + ref[f]), tau = 10)\n\n## estimate model\nb &lt;- gamlss2(y ~ 1 | re(~ 1 | f), family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 54284.8778 eps = 0.443825     \nGAMLSS-RS iteration  2: Global Deviance = 53798.1163 eps = 0.008966     \nGAMLSS-RS iteration  3: Global Deviance = 53767.8702 eps = 0.000562     \nGAMLSS-RS iteration  4: Global Deviance = 53761.3751 eps = 0.000120     \nGAMLSS-RS iteration  5: Global Deviance = 53758.2934 eps = 0.000057     \nGAMLSS-RS iteration  6: Global Deviance = 53757.5692 eps = 0.000013     \nGAMLSS-RS iteration  7: Global Deviance = 53756.9982 eps = 0.000010     \nGAMLSS-RS iteration  8: Global Deviance = 53756.5246 eps = 0.000008     \n\n## extract fitted random effects\ncb &lt;- coef(b, full = TRUE)\ncb &lt;- cb[grepl(\"re\", names(cb), fixed = TRUE)]\n\n## compare\nplot(cb, ref, main = round(mean((cb - ref)^2), 2))\nabline(0, 1, lwd = 2, col = 4)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "random"
    ]
  },
  {
    "objectID": "man/modelstats.html",
    "href": "man/modelstats.html",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 408.2379 eps = 0.294520     \nGAMLSS-RS iteration  2: Global Deviance = 377.4947 eps = 0.075306     \nGAMLSS-RS iteration  3: Global Deviance = 374.3566 eps = 0.008313     \nGAMLSS-RS iteration  4: Global Deviance = 374.1054 eps = 0.000671     \nGAMLSS-RS iteration  5: Global Deviance = 374.0982 eps = 0.000019     \nGAMLSS-RS iteration  6: Global Deviance = 374.0952 eps = 0.000007     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9863337 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 398.7366 12.32071\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 398.7366 12.32071\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 420.9960 12.32071\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "modelstats"
    ]
  },
  {
    "objectID": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "href": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 408.2379 eps = 0.294520     \nGAMLSS-RS iteration  2: Global Deviance = 377.4947 eps = 0.075306     \nGAMLSS-RS iteration  3: Global Deviance = 374.3566 eps = 0.008313     \nGAMLSS-RS iteration  4: Global Deviance = 374.1054 eps = 0.000671     \nGAMLSS-RS iteration  5: Global Deviance = 374.0982 eps = 0.000019     \nGAMLSS-RS iteration  6: Global Deviance = 374.0952 eps = 0.000007     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9863337 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 398.7366 12.32071\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 398.7366 12.32071\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 420.9960 12.32071\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "modelstats"
    ]
  },
  {
    "objectID": "man/quantiles.html",
    "href": "man/quantiles.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "quantiles"
    ]
  },
  {
    "objectID": "man/quantiles.html#quantiles-for-gamlss",
    "href": "man/quantiles.html#quantiles-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "quantiles"
    ]
  },
  {
    "objectID": "man/SpirometryUS.html",
    "href": "man/SpirometryUS.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various spirometry measurements from the National Health and Nutrition Examination Survey (NHANES) 2007–2012 along with covariates providing demographics and basic body measurements.\n\n\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\n\n\n\nA data frame containing 16596 observations on 13 variables.\n\n\nfvc\n\n\nNumeric. Forced vital capacity (FVC) in liters, i.e., the volume of air that can forcibly be blown out after full inspiration.\n\n\nfev1\n\n\nNumeric. Forced expiratory volume in 1 second (FEV1) in liters, i.e., the volume of air that can forcibly be blown out in the first second, after full inspiration.\n\n\nratio\n\n\nNumeric. Ratio of FEV1 to FVC.\n\n\npef\n\n\nNumeric, peak expiratory flow (PEF) in liters per second, i.e., the maximal flow (or speed) achieved during the maximally forced expiration initiated at full inspiration.\n\n\nfef\n\n\nNumeric. Forced expiratory flow (FEF) in liters per second, i.e., the flow (or speed) of air coming out of the lung during the middle portion (25% to 75%) of a forced expiration.\n\n\nvolume\n\n\nNumeric. Extrapolated volume.\n\n\nfet\n\n\nNumeric. Forced expiratory time (FET) in seconds, i.e., the length of the expiration.\n\n\ngender\n\n\nFactor. Binary gender information with levels female and male.\n\n\nage\n\n\nNumeric. Age in years (rounded to quarters).\n\n\nweight\n\n\nNumeric. Body weight in kilograms.\n\n\nheight\n\n\nNumeric. Body height in centimeters.\n\n\nbmi\n\n\nNumeric. Body mass index in kilograms per meter-squared, rounded to 2 decimal places.\n\n\nethnicity\n\n\nFactor. Self-reported race and ethnicity information with levels white, black, mexican American, other hispanic, and other (including multi-racial).\n\n\n\n\n\nIn order to establish lung function reference equations, Zavorsky (2025) studies the dependence of three spirometry measurements (FVC, FEV1, and the FEV1/FVC ratio) on age, adjusted for height and weight and separately for females and males. He intends to show that a simple normally-distributed model with (piecewise) linear mean equation and (piecewise) constant variance suffices for obtaining an adequate distributional fit from which the 5% quantile can be obtained as the so-called lower limit of normal (LLN). Actually, his comparison with GAMLSS – using flexible predictors for both mean and variance along with a Box-Cox-transformed normal distribution – shows that GAMLSS leads to a similar fit for the mean but a much better fit for the LLN.\nZavorsky’s (2025) analyses are based on a data set that he derived from the National Health and Nutrition Examination Survey (NHANES) in the United States 2007–2012. From the entire available data from https://wwwn.cdc.gov/nchs/nhanes/ he included those observations which met or exceeded the technical acceptability of the measurements for forced expiratory volume in 1 second (FEV1) and forced vital capacity (FVC). The data are described in a short communication published in the Data in Brief journal and the accompanying spreadsheet in CSV format (comma-separated values) is available from Mendeley Data.\nThe data comprises observations from NHANES’ “Examination Data”, in particular in “Spirometry – Pre and Post-Bronchodilator” and “Body Measures”, plus accompanying “Demographics Data”. See the variable descriptions above for more details. Basic information about spirometry can be found for example in the Wikipedia at https://en.wikipedia.org/wiki/Spirometry.\n\n\n\nZavorsky GS (2024). “Refined NHANES 2007–2012 Spirometry Dataset for the Comparison of Segmented (Piecewise) Linear Models to That of GAMLSS”, Mendeley Data, V1. doi:10.17632/dwjykg3xww.1\n\n\n\nZavorsky GS (2024). “A Refined Spirometry Dataset for Comparing Segmented (Piecewise) Linear Models to that of GAMLSS”. Data in Brief, 57, 111062. doi:10.1016/j.dib.2024.111062\nZavorsky GS (2025). “Debunking the GAMLSS Myth: Simplicity Reigns in Pulmonary Function Diagnostics”. Respiratory Medicine, 236, 107836. doi:10.1016/j.rmed.2024.107836\n\n\n\n\nlibrary(\"gamlss2\")\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\nsummary(SpirometryUS)\n\n      fvc             fev1           ratio             pef        \n Min.   :0.704   Min.   :0.476   Min.   :0.2913   Min.   : 0.901  \n 1st Qu.:2.815   1st Qu.:2.224   1st Qu.:0.7604   1st Qu.: 5.816  \n Median :3.630   Median :2.910   Median :0.8147   Median : 7.418  \n Mean   :3.676   Mean   :2.948   Mean   :0.8064   Mean   : 7.506  \n 3rd Qu.:4.480   3rd Qu.:3.598   3rd Qu.:0.8620   3rd Qu.: 9.150  \n Max.   :9.361   Max.   :6.923   Max.   :1.0000   Max.   :19.024  \n      fef            volume            fet            gender    \n Min.   :0.010   Min.   :  0.00   Min.   : 1.200   female:8303  \n 1st Qu.:1.986   1st Qu.: 52.00   1st Qu.: 7.700   male  :8293  \n Median :2.832   Median : 69.00   Median : 9.000                \n Mean   :2.942   Mean   : 76.18   Mean   : 9.693                \n 3rd Qu.:3.774   3rd Qu.: 93.00   3rd Qu.:11.500                \n Max.   :9.280   Max.   :321.00   Max.   :32.800                \n      age            weight           height           bmi       \n Min.   : 6.00   Min.   : 16.40   Min.   :104.6   Min.   :12.50  \n 1st Qu.:17.00   1st Qu.: 57.20   1st Qu.:155.9   1st Qu.:21.67  \n Median :34.00   Median : 72.30   Median :164.8   Median :26.06  \n Mean   :35.89   Mean   : 72.97   Mean   :162.9   Mean   :26.82  \n 3rd Qu.:53.00   3rd Qu.: 88.20   3rd Qu.:173.2   3rd Qu.:30.90  \n Max.   :80.00   Max.   :218.20   Max.   :203.8   Max.   :84.87  \n    ethnicity   \n white   :6607  \n black   :3598  \n mexican :3068  \n hispanic:1825  \n other   :1498",
    "crumbs": [
      "Documentation",
      "Data",
      "SpirometryUS"
    ]
  },
  {
    "objectID": "man/SpirometryUS.html#spirometry-measurements-from-nhanes-20072012",
    "href": "man/SpirometryUS.html#spirometry-measurements-from-nhanes-20072012",
    "title": "gamlss2",
    "section": "",
    "text": "Various spirometry measurements from the National Health and Nutrition Examination Survey (NHANES) 2007–2012 along with covariates providing demographics and basic body measurements.\n\n\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\n\n\n\nA data frame containing 16596 observations on 13 variables.\n\n\nfvc\n\n\nNumeric. Forced vital capacity (FVC) in liters, i.e., the volume of air that can forcibly be blown out after full inspiration.\n\n\nfev1\n\n\nNumeric. Forced expiratory volume in 1 second (FEV1) in liters, i.e., the volume of air that can forcibly be blown out in the first second, after full inspiration.\n\n\nratio\n\n\nNumeric. Ratio of FEV1 to FVC.\n\n\npef\n\n\nNumeric, peak expiratory flow (PEF) in liters per second, i.e., the maximal flow (or speed) achieved during the maximally forced expiration initiated at full inspiration.\n\n\nfef\n\n\nNumeric. Forced expiratory flow (FEF) in liters per second, i.e., the flow (or speed) of air coming out of the lung during the middle portion (25% to 75%) of a forced expiration.\n\n\nvolume\n\n\nNumeric. Extrapolated volume.\n\n\nfet\n\n\nNumeric. Forced expiratory time (FET) in seconds, i.e., the length of the expiration.\n\n\ngender\n\n\nFactor. Binary gender information with levels female and male.\n\n\nage\n\n\nNumeric. Age in years (rounded to quarters).\n\n\nweight\n\n\nNumeric. Body weight in kilograms.\n\n\nheight\n\n\nNumeric. Body height in centimeters.\n\n\nbmi\n\n\nNumeric. Body mass index in kilograms per meter-squared, rounded to 2 decimal places.\n\n\nethnicity\n\n\nFactor. Self-reported race and ethnicity information with levels white, black, mexican American, other hispanic, and other (including multi-racial).\n\n\n\n\n\nIn order to establish lung function reference equations, Zavorsky (2025) studies the dependence of three spirometry measurements (FVC, FEV1, and the FEV1/FVC ratio) on age, adjusted for height and weight and separately for females and males. He intends to show that a simple normally-distributed model with (piecewise) linear mean equation and (piecewise) constant variance suffices for obtaining an adequate distributional fit from which the 5% quantile can be obtained as the so-called lower limit of normal (LLN). Actually, his comparison with GAMLSS – using flexible predictors for both mean and variance along with a Box-Cox-transformed normal distribution – shows that GAMLSS leads to a similar fit for the mean but a much better fit for the LLN.\nZavorsky’s (2025) analyses are based on a data set that he derived from the National Health and Nutrition Examination Survey (NHANES) in the United States 2007–2012. From the entire available data from https://wwwn.cdc.gov/nchs/nhanes/ he included those observations which met or exceeded the technical acceptability of the measurements for forced expiratory volume in 1 second (FEV1) and forced vital capacity (FVC). The data are described in a short communication published in the Data in Brief journal and the accompanying spreadsheet in CSV format (comma-separated values) is available from Mendeley Data.\nThe data comprises observations from NHANES’ “Examination Data”, in particular in “Spirometry – Pre and Post-Bronchodilator” and “Body Measures”, plus accompanying “Demographics Data”. See the variable descriptions above for more details. Basic information about spirometry can be found for example in the Wikipedia at https://en.wikipedia.org/wiki/Spirometry.\n\n\n\nZavorsky GS (2024). “Refined NHANES 2007–2012 Spirometry Dataset for the Comparison of Segmented (Piecewise) Linear Models to That of GAMLSS”, Mendeley Data, V1. doi:10.17632/dwjykg3xww.1\n\n\n\nZavorsky GS (2024). “A Refined Spirometry Dataset for Comparing Segmented (Piecewise) Linear Models to that of GAMLSS”. Data in Brief, 57, 111062. doi:10.1016/j.dib.2024.111062\nZavorsky GS (2025). “Debunking the GAMLSS Myth: Simplicity Reigns in Pulmonary Function Diagnostics”. Respiratory Medicine, 236, 107836. doi:10.1016/j.rmed.2024.107836\n\n\n\n\nlibrary(\"gamlss2\")\n\ndata(\"SpirometryUS\", package = \"gamlss2\")\nsummary(SpirometryUS)\n\n      fvc             fev1           ratio             pef        \n Min.   :0.704   Min.   :0.476   Min.   :0.2913   Min.   : 0.901  \n 1st Qu.:2.815   1st Qu.:2.224   1st Qu.:0.7604   1st Qu.: 5.816  \n Median :3.630   Median :2.910   Median :0.8147   Median : 7.418  \n Mean   :3.676   Mean   :2.948   Mean   :0.8064   Mean   : 7.506  \n 3rd Qu.:4.480   3rd Qu.:3.598   3rd Qu.:0.8620   3rd Qu.: 9.150  \n Max.   :9.361   Max.   :6.923   Max.   :1.0000   Max.   :19.024  \n      fef            volume            fet            gender    \n Min.   :0.010   Min.   :  0.00   Min.   : 1.200   female:8303  \n 1st Qu.:1.986   1st Qu.: 52.00   1st Qu.: 7.700   male  :8293  \n Median :2.832   Median : 69.00   Median : 9.000                \n Mean   :2.942   Mean   : 76.18   Mean   : 9.693                \n 3rd Qu.:3.774   3rd Qu.: 93.00   3rd Qu.:11.500                \n Max.   :9.280   Max.   :321.00   Max.   :32.800                \n      age            weight           height           bmi       \n Min.   : 6.00   Min.   : 16.40   Min.   :104.6   Min.   :12.50  \n 1st Qu.:17.00   1st Qu.: 57.20   1st Qu.:155.9   1st Qu.:21.67  \n Median :34.00   Median : 72.30   Median :164.8   Median :26.06  \n Mean   :35.89   Mean   : 72.97   Mean   :162.9   Mean   :26.82  \n 3rd Qu.:53.00   3rd Qu.: 88.20   3rd Qu.:173.2   3rd Qu.:30.90  \n Max.   :80.00   Max.   :218.20   Max.   :203.8   Max.   :84.87  \n    ethnicity   \n white   :6607  \n black   :3598  \n mexican :3068  \n hispanic:1825  \n other   :1498",
    "crumbs": [
      "Documentation",
      "Data",
      "SpirometryUS"
    ]
  },
  {
    "objectID": "man/glmnet.html",
    "href": "man/glmnet.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\nlasso(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”).\n\n\n\nThe lasso() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "glmnet"
    ]
  },
  {
    "objectID": "man/glmnet.html#lasso-with-glmnet",
    "href": "man/glmnet.html#lasso-with-glmnet",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function for estimating Lasso model terms using the glmnet package.\n\n\n\n## Model term constructor function.\nlasso(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA formula specifying the covariates that should be estimated using the Lasso implementation in glmnet.\n\n\n\n\n…\n\n\nControl arguments to be passed to function glmnet.\n\n\n\n\n\n\nThe formula is used to generate a model.matrix, which is then used for estimation. Note that the data is not scaled, so the user must scale the covariates manually. The function glmnet is employed within the backfitting algorithm implemented in RS. The optimal Lasso shrinkage parameter is selected based on an information criterion. Available options for the criterion are criterion = c(“gcv”, “aic”, “gaic”, “aicc”, “bic”).\n\n\n\nThe lasso() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms using function glmnet.\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc) |\n  lasso(~Flc + Ac + loc)\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## extract fitted special lasso model term\nst &lt;- specials(b, model = \"mu\")\n\n## plot coefficient paths\nplot(st$model)\n\n## same for sigma\nplot(specials(b, model = \"sigma\", elements = \"model\"))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "glmnet"
    ]
  },
  {
    "objectID": "man/cv_gamlss2.html",
    "href": "man/cv_gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "cv_gamlss2() implements K-fold cross validation for models fitted with gamlss2. Different scoring rules can be supplied via the metric argument. Convenience metric functions (log_pdf_metric(), rqres_metric(), mse_metric()) are provided.\n\n\n\n## K-fold cross-validation\ncv_gamlss2(..., data, folds = 5,\n  metric = log_pdf_metric, parallel = FALSE, simplify = TRUE)\n\n## log-pdf for each observation\nlog_pdf_metric(model, data)\n\n## randomized quantile residuals\nrqres_metric(model, data)\n\n## mean squared error\nmse_metric(model, data)\n\n\n\n\n\n\n\n…\n\n\nmodel specification passed to gamlss2 such as formula, family, etc.\n\n\n\n\ndata\n\n\na data.frame containing the variables in the model. For functions supplied to argument metric, a data.frame for evaluating predictions or residuals.\n\n\n\n\nfolds\n\n\neither an integer specifying the number of folds, or a list, matrix, or data frame of index sets for test folds. Defaults to 5.\n\n\n\n\nmetric\n\n\na function of the form metric(model, data) returning a score for the given fitted model and test data. Defaults to log_pdf_metric.\n\n\n\n\nparallel\n\n\nlogical. If TRUE, computation is carried out in parallel using future.apply.\n\n\n\n\nsimplify\n\n\nlogical. If TRUE, results are returned in a simplified vector or data frame depending on the metric output.\n\n\n\n\nmodel\n\n\na fitted gamlss2 model.\n\n\n\n\n\n\ncv_gamlss2() splits the data into training and test folds. For each fold the model is fitted on the training data, and the chosen metric is evaluated on the held-out test data. By default, the scoring rule is the log predictive density (log_pdf_metric), but other metrics can be used, such as randomized quantile residuals (rqres_metric) or mean squared error of the conditional mean (mse_metric).\nThe function returns either a list of fold-wise results or, if simplify = TRUE, a named vector or data frame aligned with the original observations.\n\n\n\nIf simplify = TRUE and the metric returns scalars, a named numeric vector of fold scores is returned. Otherwise a data frame with fold membership and scores per observation is returned.\nThe convenience metrics return a numeric vector of scores or residuals.\n\n\n\ngamlss2, log_pdf\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## cross-validation using the NO distribution\n## only model the mean with s(x)\ncv1 &lt;- cv_gamlss2(y ~ s(x), data = abdom, family = NO)\n\n## now, also model the standard deviation with s(x)\ncv2 &lt;- cv_gamlss2(y ~ s(x) | s(x), data = abdom, family = BCT)\n\n## evaluate log-likelihood\nsum(cv1$score)\nsum(cv2$score)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "cv_gamlss2"
    ]
  },
  {
    "objectID": "man/cv_gamlss2.html#cross-validation-for-gamlss2-models",
    "href": "man/cv_gamlss2.html#cross-validation-for-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "cv_gamlss2() implements K-fold cross validation for models fitted with gamlss2. Different scoring rules can be supplied via the metric argument. Convenience metric functions (log_pdf_metric(), rqres_metric(), mse_metric()) are provided.\n\n\n\n## K-fold cross-validation\ncv_gamlss2(..., data, folds = 5,\n  metric = log_pdf_metric, parallel = FALSE, simplify = TRUE)\n\n## log-pdf for each observation\nlog_pdf_metric(model, data)\n\n## randomized quantile residuals\nrqres_metric(model, data)\n\n## mean squared error\nmse_metric(model, data)\n\n\n\n\n\n\n\n…\n\n\nmodel specification passed to gamlss2 such as formula, family, etc.\n\n\n\n\ndata\n\n\na data.frame containing the variables in the model. For functions supplied to argument metric, a data.frame for evaluating predictions or residuals.\n\n\n\n\nfolds\n\n\neither an integer specifying the number of folds, or a list, matrix, or data frame of index sets for test folds. Defaults to 5.\n\n\n\n\nmetric\n\n\na function of the form metric(model, data) returning a score for the given fitted model and test data. Defaults to log_pdf_metric.\n\n\n\n\nparallel\n\n\nlogical. If TRUE, computation is carried out in parallel using future.apply.\n\n\n\n\nsimplify\n\n\nlogical. If TRUE, results are returned in a simplified vector or data frame depending on the metric output.\n\n\n\n\nmodel\n\n\na fitted gamlss2 model.\n\n\n\n\n\n\ncv_gamlss2() splits the data into training and test folds. For each fold the model is fitted on the training data, and the chosen metric is evaluated on the held-out test data. By default, the scoring rule is the log predictive density (log_pdf_metric), but other metrics can be used, such as randomized quantile residuals (rqres_metric) or mean squared error of the conditional mean (mse_metric).\nThe function returns either a list of fold-wise results or, if simplify = TRUE, a named vector or data frame aligned with the original observations.\n\n\n\nIf simplify = TRUE and the metric returns scalars, a named numeric vector of fold scores is returned. Otherwise a data frame with fold membership and scores per observation is returned.\nThe convenience metrics return a numeric vector of scores or residuals.\n\n\n\ngamlss2, log_pdf\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## cross-validation using the NO distribution\n## only model the mean with s(x)\ncv1 &lt;- cv_gamlss2(y ~ s(x), data = abdom, family = NO)\n\n## now, also model the standard deviation with s(x)\ncv2 &lt;- cv_gamlss2(y ~ s(x) | s(x), data = abdom, family = BCT)\n\n## evaluate log-likelihood\nsum(cv1$score)\nsum(cv2$score)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "cv_gamlss2"
    ]
  },
  {
    "objectID": "man/plots.html",
    "href": "man/plots.html",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "plots"
    ]
  },
  {
    "objectID": "man/plots.html#plotting-gamlss",
    "href": "man/plots.html#plotting-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "plots"
    ]
  },
  {
    "objectID": "man/pb.html",
    "href": "man/pb.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26379.1782 eps = 0.390130     \nGAMLSS-RS iteration  2: Global Deviance = 26205.4924 eps = 0.006584     \nGAMLSS-RS iteration  3: Global Deviance = 26202.6475 eps = 0.000108     \nGAMLSS-RS iteration  4: Global Deviance = 26202.2604 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 26202.1179 eps = 0.000005     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "pb"
    ]
  },
  {
    "objectID": "man/pb.html#p-splines-for-gamlss",
    "href": "man/pb.html#p-splines-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26379.1782 eps = 0.390130     \nGAMLSS-RS iteration  2: Global Deviance = 26205.4924 eps = 0.006584     \nGAMLSS-RS iteration  3: Global Deviance = 26202.6475 eps = 0.000108     \nGAMLSS-RS iteration  4: Global Deviance = 26202.2604 eps = 0.000014     \nGAMLSS-RS iteration  5: Global Deviance = 26202.1179 eps = 0.000005     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Model terms",
      "pb"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html",
    "href": "man/predict.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? Standard errors are computed by simulating from the approximate multivariate normal distribution of the maximum likelihood estimates. The number of simulations is controlled by the argument R, which defaults to R = 200, and can be passed via ….\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 405.766 eps = 0.003924     \nGAMLSS-RS iteration  3: Global Deviance = 405.7473 eps = 0.000045     \nGAMLSS-RS iteration  4: Global Deviance = 405.7473 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.02058 10.08716\n2 59.13735 18.49146\n3 96.53656 33.88827\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.02058 10.08716\n2 59.13735 18.49146\n3 96.53656 33.88827\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.08716 18.49146 33.88827 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.08716\n2 18.49146\n3 33.88827\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1    2.638535 -0.3272719\n2    2.638535  0.2787743\n3    2.638535  0.8845340\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3272719\n2  0.2787743\n3  0.8845340\n\n## standard errors\npredict(m, newdata = nd, se.fit = TRUE, R = 200)\n\n    mu.fit      mu.se    sigma.fit     sigma.se\n1 23.02058   4.954498 1.102496e+01 4.878271e+00\n2 59.13735  13.160966 2.409469e+01 1.890208e+01\n3 96.53656 104.926124 1.163849e+09 1.645647e+10",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "href": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? Standard errors are computed by simulating from the approximate multivariate normal distribution of the maximum likelihood estimates. The number of simulations is controlled by the argument R, which defaults to R = 200, and can be passed via ….\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 405.766 eps = 0.003924     \nGAMLSS-RS iteration  3: Global Deviance = 405.7473 eps = 0.000045     \nGAMLSS-RS iteration  4: Global Deviance = 405.7473 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.02058 10.08716\n2 59.13735 18.49146\n3 96.53656 33.88827\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.02058 10.08716\n2 59.13735 18.49146\n3 96.53656 33.88827\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.08716 18.49146 33.88827 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.08716\n2 18.49146\n3 33.88827\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1    2.638535 -0.3272719\n2    2.638535  0.2787743\n3    2.638535  0.8845340\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3272719\n2  0.2787743\n3  0.8845340\n\n## standard errors\npredict(m, newdata = nd, se.fit = TRUE, R = 200)\n\n    mu.fit      mu.se    sigma.fit     sigma.se\n1 23.02058   4.954498 1.102496e+01 4.878271e+00\n2 59.13735  13.160966 2.409469e+01 1.890208e+01\n3 96.53656 104.926124 1.163849e+09 1.645647e+10",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html",
    "href": "man/gamlss2-package.html",
    "title": "gamlss2",
    "section": "",
    "text": "Next generation infrastructure for generalized additive models for location, scale, and shape (GAMLSS) and distributional regression more generally. The package provides a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.\n\n\n\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Documentation",
      "Package overview",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "href": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "title": "gamlss2",
    "section": "",
    "text": "Next generation infrastructure for generalized additive models for location, scale, and shape (GAMLSS) and distributional regression more generally. The package provides a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.\n\n\n\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Documentation",
      "Package overview",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html",
    "href": "man/gamlss2_control.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html#control-parameters",
    "href": "man/gamlss2_control.html#control-parameters",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html",
    "href": "man/select_gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "href": "man/select_gamlss2.html#smooth-model-term-selection-with-additional-penalties",
    "title": "gamlss2",
    "section": "",
    "text": "The function select_gamlss2() allows for penalizing all mgcv model terms with an additional shrinkage penalty, which can shrink some terms to zero, effectively selecting them out of the model. In addition to this penalty, model terms are selected based on two criteria: the estimated degrees of freedom of the term and the percentage of the predictor range covered by the model term. These two thresholds aim to mimic a natural selection process, similar to what one might do by inspecting summaries and effect plots, ensuring that only relevant terms are retained in the final model.\n\n\n\n## Wrapper function.\nselect_gamlss2(formula, ..., criterion = \"BIC\", thres = c(0.9, 0.2))\n\n## Modified RS optimizer function.\nsRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\n…\n\n\nArguments passed to argument control in function sRS().\n\n\n\n\ncriterion\n\n\nThe information criterion to be used for estimating the shrinkage parameters. This can also be a vector of length 2, where the first element specifies the criterion to be used during the selection step, and the second element specifies the criterion to be used during the refitting step. Possible options are “BIC”, “GCV”, “AIC”, “AICc” and “GAIC” with user defined penalty K, default is K = 2.\n\n\n\n\nthres\n\n\nA vector of thresholds used for model term selection. The first element controls the minimum allowed estimated degrees of freedom for a model term to enter the model. The second element specifies the minimum percentage of the total estimated predictor range required for a term to be included in the model.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe function select_gamlss2 selects model terms by identifying those with estimated degrees of freedom greater than a pre-specified threshold (e.g., thres = 0.9). In addition, model term selection can also be based on the percentage of the total predictor range covered by the model term to ensure that the term represents a substantial portion of the total effect. After the selection step, the model is refitted using only the selected terms, excluding the additional penalty applied during the initial fitting process. The additional penalty for automatic term selection is described in ?gam.selection. Please note that this is experimental, and careful consideration should always be given to the modeling process.\n\n\n\nAn object of class “gamlss2”.\n\n\n\ngamlss2, new_formula.\n\n\n\n\nlibrary(\"gamlss2\")\n\nset.seed(123)\n\n## number of observations\nn &lt;- 1000\n\n## covariates\nk &lt;- 100\nx &lt;- matrix(runif(n * k, -3, 3), ncol = k)\ncolnames(x) &lt;- paste0(\"x\", 1:k)\nd &lt;- as.data.frame(x)\n\n## true effects\nd$f1 &lt;- sin(d$x1)\nd$f2 &lt;- exp(d$x2)/15 - 1\nd$f3 &lt;- -d$x3 / 3\nd$f4 &lt;- d$x4^2/5 - 1 \nd$f5 &lt;- cos(d$x5)\n\n## true parameters\nmu &lt;- with(d, f1 + f3 + f4)\nsigma &lt;- with(d, exp(1.5 + f2 + f4 + f5))\n\n## simulate response\nd$y &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula\nf &lt;- paste(\"~\", paste0(\"s(x\", 1:k, \")\", collapse = \"+\"))\nf &lt;- as.formula(f)\nf &lt;- list(f, f)\nf[[1]] &lt;- update(f[[1]], y ~ .)\n\n## estimate model\nb &lt;- select_gamlss2(f, data = d, family = NO)\n\n## plot selected estimated effects\nplot(b)\n\n## final model\nnew_formula(b)\n\n## example taken from ?gam.selection\nlibrary(\"mgcv\")\nset.seed(3)\nn &lt;- 200\n\n## simulate data\ndat &lt;- gamSim(1, n = n, scale = .15, dist = \"poisson\")\n\n## spurious\ndat$x4 &lt;- runif(n, 0, 1)\ndat$x5 &lt;- runif(n, 0, 1)\n\n## formula\nf &lt;- y ~ s(x0) + s(x1) + s(x2) + s(x3) + s(x4) + s(x5)\n\n## estimate model\nb1 &lt;- gam(f, data = dat, family = poisson,\n  select = TRUE, method = \"REML\")\nsummary(b1)\nplot(b1, pages = 1)\n\n## same with gamlss2\nb2 &lt;- select_gamlss2(f, data = dat, family = PO)\n\n## plot selected effects\nplot(b2)\n\n## final model\nnew_formula(b2)",
    "crumbs": [
      "Documentation",
      "Regression models",
      "select_gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html",
    "href": "man/gamlss2.family.html",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nA gamlss2 family object must be a list of class “gamlss2.family”, containing the necessary elements to define the response distribution and how it is handled during model fitting. The minimum requirements are as follows:\n\n\nfamily: the name of the distribution (character string).\n\n\nnames: a character vector of parameter names (e.g., c(“mu”, “sigma”)).\n\n\nlinks: a named character vector specifying the link function for each parameter (e.g., c(mu = “identity”, sigma = “log”)), or a list of link functions, e.g., see softplus.\n\n\npdf(y, par, log = FALSE, …): a function to evaluate the (log-)density.\n\n\nThe pdf() function must accept the response y, a named list par of evaluated parameter values (e.g., par$mu, par$sigma), a logical log, and optional additional arguments.\nOptionally, the family object may include:\n\n\nscore: a named list of functions (one per parameter), each computing the first derivative of the log-likelihood with respect to the linear predictor: score[param].\n\n\nhess: a named list of functions computing second derivatives (negative Hessian). For parameters mu and sigma, this includes: hess[“mu”], hess[“sigma”], and optionally cross derivatives like hess[“mu.sigma”].\n\n\nloglik(y, par, …): a function computing the total log-likelihood.\n\n\ncdf(y, par, …): cumulative distribution function.\n\n\nquantile(p, par, …): quantile function.\n\n\nrandom(n, par, …): random number generator.\n\n\nmean(par, …): mean function.\n\n\nvariance(par, …): variance function.\n\n\nskewness(par, …), kurtosis(par, …): optional higher-order moment functions.\n\n\ninitialize: a named list of initialization functions, one per parameter (e.g., initialize$mu(y, …)), used to generate starting values.\n\n\nvalid.response(x): a function that checks whether the response is valid (e.g., numeric, non-factor).\n\n\noptimizer(): an optional function to define a custom optimization method for use with gamlss2, see also link{RS}.\n\n\nIf the analytical score or Hessian functions are not provided, they will be approximated numerically. If quantile residuals are to be computed, a cdf() function must be provided.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"pdf\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$quantile(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $cdf() and $quantile() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"cdf\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"quantile\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $cdf() and $quantile() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "href": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nA gamlss2 family object must be a list of class “gamlss2.family”, containing the necessary elements to define the response distribution and how it is handled during model fitting. The minimum requirements are as follows:\n\n\nfamily: the name of the distribution (character string).\n\n\nnames: a character vector of parameter names (e.g., c(“mu”, “sigma”)).\n\n\nlinks: a named character vector specifying the link function for each parameter (e.g., c(mu = “identity”, sigma = “log”)), or a list of link functions, e.g., see softplus.\n\n\npdf(y, par, log = FALSE, …): a function to evaluate the (log-)density.\n\n\nThe pdf() function must accept the response y, a named list par of evaluated parameter values (e.g., par$mu, par$sigma), a logical log, and optional additional arguments.\nOptionally, the family object may include:\n\n\nscore: a named list of functions (one per parameter), each computing the first derivative of the log-likelihood with respect to the linear predictor: score[param].\n\n\nhess: a named list of functions computing second derivatives (negative Hessian). For parameters mu and sigma, this includes: hess[“mu”], hess[“sigma”], and optionally cross derivatives like hess[“mu.sigma”].\n\n\nloglik(y, par, …): a function computing the total log-likelihood.\n\n\ncdf(y, par, …): cumulative distribution function.\n\n\nquantile(p, par, …): quantile function.\n\n\nrandom(n, par, …): random number generator.\n\n\nmean(par, …): mean function.\n\n\nvariance(par, …): variance function.\n\n\nskewness(par, …), kurtosis(par, …): optional higher-order moment functions.\n\n\ninitialize: a named list of initialization functions, one per parameter (e.g., initialize$mu(y, …)), used to generate starting values.\n\n\nvalid.response(x): a function that checks whether the response is valid (e.g., numeric, non-factor).\n\n\noptimizer(): an optional function to define a custom optimization method for use with gamlss2, see also link{RS}.\n\n\nIf the analytical score or Hessian functions are not provided, they will be approximated numerically. If quantile residuals are to be computed, a cdf() function must be provided.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"pdf\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$quantile(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $cdf() and $quantile() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"cdf\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"quantile\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $cdf() and $quantile() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html",
    "href": "man/Kumaraswamy.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "href": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\nKS(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9979 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1074 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1261 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1293 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/GDF.html",
    "href": "man/GDF.html",
    "title": "gamlss2",
    "section": "",
    "text": "The GDF (gamlss2 Distribution Family) is a unified class with corresponding methods that represent all distributional families supported by the gamlss2 package. It enables seamless integration with the distributions3 workflow and provides a consistent interface for model fitting and distributional computations.\n\n\n\nGDF(family, parameters)\n\n\n\n\n\n\n\nfamily\n\n\ncharacter. Name of a gamlss2.family or a family provided by the gamlss.dist package, e.g, NO or BI for the normal or binomial distribution, respectively.\n\n\n\n\nparameters\n\n\nnumeric, matrix, list or data frame, see the examples.\n\n\n\n\n\n\nThe S3 class GDF is a slightly more general implementation of the S3 class GAMLSS tailored for gamlss2. For details please see the documentation of GAMLSS\n\n\n\nA GDF object, inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\ngamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## package and random seed\nlibrary(\"distributions3\")\nset.seed(6020)\n\n## one normal distribution\nX &lt;- GDF(\"NO\", c(mu = 1, sigma = 2))\nX\n\n[1] \"GDF NO(mu = 1, sigma = 2)\"\n\n## two normal distributions\nX &lt;- GDF(\"NO\", cbind(c(1, 1.5), c(0.6, 1.2)))\nX\n\n[1] \"GDF NO(mu = 1.0, sigma = 0.6)\" \"GDF NO(mu = 1.5, sigma = 1.2)\"\n\n## three Weibull distributions\nX &lt;- GDF(\"WEI\", list(mu = c(1, 1, 2), sigma = c(1, 2, 2)))\nX\n\n[1] \"GDF WEI(mu = 1, sigma = 1)\" \"GDF WEI(mu = 1, sigma = 2)\"\n[3] \"GDF WEI(mu = 2, sigma = 2)\"\n\n## see ?gamlss.dist::GAMLSS for the remainder of this example\n\n## example using gamlss2\ndata(\"abdom\", package = \"gamlss.data\")\n\n## estimate model\nb &lt;- gamlss2(y ~ s(x) | . | . | ., data = abdom, family = GA)\n\nGAMLSS-RS iteration  1: Global Deviance = 5039.2922 eps = 0.356998     \nGAMLSS-RS iteration  2: Global Deviance = 4802.238 eps = 0.047041     \nGAMLSS-RS iteration  3: Global Deviance = 4800.5126 eps = 0.000359     \nGAMLSS-RS iteration  4: Global Deviance = 4800.4943 eps = 0.000003     \n\n## extract, also works with newdata\nd &lt;- data.frame(\n  \"mean\" = mean(b),\n  \"median\" = median(b),\n  \"q95\" = quantile(b, probs = 0.95),\n  \"variance\" = variance(b),\n  \"pdf\" = pdf(b),\n  \"cdf\" = cdf(b)\n)\nprint(head(d))\n\n      mean   median      q95 variance        pdf        cdf\n1 63.03104 62.92909 70.42364 19.28276 0.06246974 0.18010635\n2 63.03104 62.92909 70.42364 19.28276 0.08730887 0.59589436\n3 63.03104 62.92909 70.42364 19.28276 0.02556281 0.05035205\n4 64.38740 64.28355 71.92811 20.06443 0.06986751 0.22764748\n5 67.18717 67.07943 75.03293 21.72338 0.02854450 0.92478019\n6 67.18717 67.07943 75.03293 21.72338 0.02660748 0.05735297",
    "crumbs": [
      "Documentation",
      "Families and links",
      "GDF"
    ]
  },
  {
    "objectID": "man/GDF.html#create-a-gdf-distribution",
    "href": "man/GDF.html#create-a-gdf-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "The GDF (gamlss2 Distribution Family) is a unified class with corresponding methods that represent all distributional families supported by the gamlss2 package. It enables seamless integration with the distributions3 workflow and provides a consistent interface for model fitting and distributional computations.\n\n\n\nGDF(family, parameters)\n\n\n\n\n\n\n\nfamily\n\n\ncharacter. Name of a gamlss2.family or a family provided by the gamlss.dist package, e.g, NO or BI for the normal or binomial distribution, respectively.\n\n\n\n\nparameters\n\n\nnumeric, matrix, list or data frame, see the examples.\n\n\n\n\n\n\nThe S3 class GDF is a slightly more general implementation of the S3 class GAMLSS tailored for gamlss2. For details please see the documentation of GAMLSS\n\n\n\nA GDF object, inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\ngamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## package and random seed\nlibrary(\"distributions3\")\nset.seed(6020)\n\n## one normal distribution\nX &lt;- GDF(\"NO\", c(mu = 1, sigma = 2))\nX\n\n[1] \"GDF NO(mu = 1, sigma = 2)\"\n\n## two normal distributions\nX &lt;- GDF(\"NO\", cbind(c(1, 1.5), c(0.6, 1.2)))\nX\n\n[1] \"GDF NO(mu = 1.0, sigma = 0.6)\" \"GDF NO(mu = 1.5, sigma = 1.2)\"\n\n## three Weibull distributions\nX &lt;- GDF(\"WEI\", list(mu = c(1, 1, 2), sigma = c(1, 2, 2)))\nX\n\n[1] \"GDF WEI(mu = 1, sigma = 1)\" \"GDF WEI(mu = 1, sigma = 2)\"\n[3] \"GDF WEI(mu = 2, sigma = 2)\"\n\n## see ?gamlss.dist::GAMLSS for the remainder of this example\n\n## example using gamlss2\ndata(\"abdom\", package = \"gamlss.data\")\n\n## estimate model\nb &lt;- gamlss2(y ~ s(x) | . | . | ., data = abdom, family = GA)\n\nGAMLSS-RS iteration  1: Global Deviance = 5039.2922 eps = 0.356998     \nGAMLSS-RS iteration  2: Global Deviance = 4802.238 eps = 0.047041     \nGAMLSS-RS iteration  3: Global Deviance = 4800.5126 eps = 0.000359     \nGAMLSS-RS iteration  4: Global Deviance = 4800.4943 eps = 0.000003     \n\n## extract, also works with newdata\nd &lt;- data.frame(\n  \"mean\" = mean(b),\n  \"median\" = median(b),\n  \"q95\" = quantile(b, probs = 0.95),\n  \"variance\" = variance(b),\n  \"pdf\" = pdf(b),\n  \"cdf\" = cdf(b)\n)\nprint(head(d))\n\n      mean   median      q95 variance        pdf        cdf\n1 63.03104 62.92909 70.42364 19.28276 0.06246974 0.18010635\n2 63.03104 62.92909 70.42364 19.28276 0.08730887 0.59589436\n3 63.03104 62.92909 70.42364 19.28276 0.02556281 0.05035205\n4 64.38740 64.28355 71.92811 20.06443 0.06986751 0.22764748\n5 67.18717 67.07943 75.03293 21.72338 0.02854450 0.92478019\n6 67.18717 67.07943 75.03293 21.72338 0.02660748 0.05735297",
    "crumbs": [
      "Documentation",
      "Families and links",
      "GDF"
    ]
  },
  {
    "objectID": "vignettes/topmodels.html#probabilistic-model-infrastructure",
    "href": "vignettes/topmodels.html#probabilistic-model-infrastructure",
    "title": "Forecasting and Assessment with topmodels",
    "section": "1 Probabilistic model infrastructure",
    "text": "1 Probabilistic model infrastructure\nIntroduction on how to use the topmodels package (topmodels?) with gamlss2.\nCurrently not on CRAN, yet, so install from R-universe (if not done already).\n\nif(!(\"topmodels\" %in% installed.packages())) {\n  install.packages(\"topmodels\", repos = \"https://zeileis.R-universe.dev\")\n}\nif(packageVersion(\"gamlss.dist\") &lt; \"6.1-3\") {\n  install.packages(\"gamlss.dist\", repos = \"https://gamlss-dev.R-universe.dev\")\n}\n\nOn GitHub, unfortunately, in the GitHub Action the gamlss.dist package is always taken from CRAN (via r-cran-gamlss.dist apparently).\n\npackageVersion(\"gamlss.dist\")\n\n[1] '6.1.1'"
  },
  {
    "objectID": "vignettes/topmodels.html#data-and-models",
    "href": "vignettes/topmodels.html#data-and-models",
    "title": "Forecasting and Assessment with topmodels",
    "section": "2 Data and models",
    "text": "2 Data and models\n\nlibrary(\"gamlss2\")\ndata(\"HarzTraffic\", package = \"gamlss2\")\nm1 &lt;- lm(log(cars) ~ poly(yday, 3), data = HarzTraffic)\nm2 &lt;- gamlss2(log(cars) ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"), data = HarzTraffic, family = SN2)"
  },
  {
    "objectID": "vignettes/topmodels.html#probabilistic-forecasting",
    "href": "vignettes/topmodels.html#probabilistic-forecasting",
    "title": "Forecasting and Assessment with topmodels",
    "section": "3 Probabilistic forecasting",
    "text": "3 Probabilistic forecasting\n\nlibrary(\"topmodels\")\nnd &lt;- data.frame(yday = 1:365)\nnd &lt;- cbind(nd,\n  procast(m1, newdata = nd, type = \"quantile\", at = c(0.025, 0.5, 0.975)),\n  procast(m2, newdata = nd, type = \"quantile\", at = c(0.025, 0.5, 0.975)))\nplot(log(cars) ~ yday, data = HarzTraffic, type = \"n\")\npolygon(c(nd[[1]], rev(nd[[1]])), c(nd[[2]], rev(nd[[4]])),\n  col = adjustcolor(2, alpha.f = 0.4), border = \"transparent\")\npolygon(c(nd[[1]], rev(nd[[1]])), c(nd[[5]], rev(nd[[7]])),\n  col = adjustcolor(4, alpha.f = 0.4), border = \"transparent\")\npoints(log(cars) ~ yday, data = HarzTraffic)\nlines(nd[[1]], nd[[3]], col = 2, lwd = 2)\nlines(nd[[1]], nd[[6]], col = 4, lwd = 2)"
  },
  {
    "objectID": "vignettes/topmodels.html#graphical-model-assessment",
    "href": "vignettes/topmodels.html#graphical-model-assessment",
    "title": "Forecasting and Assessment with topmodels",
    "section": "4 Graphical model assessment",
    "text": "4 Graphical model assessment\n\n4.1 Within model diagnostics\n\npar(mfrow = c(2, 2))\nrootogram(m1)\npithist(m1)\nqqrplot(m1)\nwormplot(m1)\n\n\n\n\n\n\n\n\n\npar(mfrow = c(2, 2))\nrootogram(m2)\npithist(m2)\nqqrplot(m2)\nwormplot(m2)\n\n\n\n\n\n\n\n\n\n\n4.2 Between Models diagnostics\n\npar(mfrow = c(1, 2))\np1 &lt;- pithist(m1, plot = FALSE)\np2 &lt;- pithist(m2, plot = FALSE)\nplot(c(p1, p2), col = c(2, 4), single_graph = TRUE, style = \"line\")\nw1 &lt;- wormplot(m1, plot = FALSE)\nw2 &lt;- wormplot(m2, plot = FALSE)\nplot(c(w1, w2), col = c(2, 4), single_graph = TRUE)"
  },
  {
    "objectID": "vignettes/topmodels.html#scoring-rules",
    "href": "vignettes/topmodels.html#scoring-rules",
    "title": "Forecasting and Assessment with topmodels",
    "section": "5 Scoring rules",
    "text": "5 Scoring rules\n\nm &lt;- list(lm = m1, gamlss2 = m2)\nsapply(m, proscore, type = c(\"logs\", \"crps\", \"mae\", \"mse\", \"dss\"))\n\nLoading required namespace: scoringRules\n\n\n     lm         gamlss2   \nlogs 0.1806799  0.0369116 \ncrps 0.1580683  0.1471254 \nmae  0.2191784  0.2081393 \nmse  0.08403538 0.07790537\ndss  -1.476517  -1.741182"
  },
  {
    "objectID": "vignettes/families.html",
    "href": "vignettes/families.html",
    "title": "Family Objects",
    "section": "",
    "text": "All family objects of the gamlss.dist package, see Rigby et al. (2019), can be used for modelling in gamlss2. However, for users wanting to specify their own (new) distribution model, this document provides a guide on how to define custom family objects within the gamlss2 framework.\nFamily objects in the gamlss2 package play an essential role in defining the models used for fitting data to distributions. These objects encapsulate the necessary details about the distribution and the parameters, such as:\nThis document provides an overview of how to construct and use family objects within gamlss2. By the end, you should have a good understanding of how to implement a custom family for use in statistical models."
  },
  {
    "objectID": "vignettes/families.html#defining-family-objects",
    "href": "vignettes/families.html#defining-family-objects",
    "title": "Family Objects",
    "section": "1 Defining Family Objects",
    "text": "1 Defining Family Objects\nA family object in gamlss2 is a list that must meet the following minimum criteria:\n\nFamily Name: The object must contain the family name as a character string.\nParameters: The object must list the parameters of the distribution (e.g., \"mu\" and \"sigma\" for a normal distribution).\nLink Functions: It must specify the link functions associated with each parameter.\nProbability Density Function: A pdf() function must be provided to evaluate the (log-)density of the distribution.\n\nOptionally, a family object can include functions to calculate the log-likelihood, random number generation, cumulative distribution function (CDF), and quantile function.\nHere’s an example of a minimal family object for the normal distribution.\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\"\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIn this example, we define a normal distribution with two parameters: \"mu\" (mean) and \"sigma\" (standard deviation). The link function for \"mu\" is the identity, and for \"sigma\", it is the log function. The probability density function (pdf()) must accept the following arguments:\n\npdf(y, par, log = FALSE, ...)\n\n\ny: The response variable.\npar: A named list of parameters (e.g., \"mu\", \"sigma\" for the normal distribution).\nlog: A logical value indicating whether to return the log-density.\n\nHere, the pdf() function uses the standard dnorm() function to calculate the normal density."
  },
  {
    "objectID": "vignettes/families.html#optional-derivatives",
    "href": "vignettes/families.html#optional-derivatives",
    "title": "Family Objects",
    "section": "2 Optional Derivatives",
    "text": "2 Optional Derivatives\nFamily objects can optionally include functions to compute the first and second derivatives of the log-likelihood with respect to the predictors (or the expected values of those derivatives). These functions are used during model fitting to improve optimization efficiency and accuracy.\nAll derivative functions must follow the structure:\nfunction(y, par, ...)\nFirst-order derivatives must be provided as a named list called \"score\", with one function per distribution parameter. Second-order derivatives must be provided in a list named \"hess\". Each function in \"hess\" must return the negative (expected) second derivative with respect to the predictor.\nThe following code illustrates how to provide both \"score\" and \"hess\" functions for a normal distribution:\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\",\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y)) ## example cross-derivative\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\nIf no derivative functions are provided, all necessary derivatives will be approximated numerically. In addition to derivatives with respect to single parameters, cross-derivatives (i.e., second-order derivatives involving two different parameters) can also be specified. These should be added to the \"hess\" list and named using the format \"param1.param2\", for example \"mu.sigma\". They must use the same function arguments as the other derivative functions.\nCross-derivatives can be beneficial when using second-order optimization algorithms such as Cole and Green (CG) flavor implemented in the default backfitting algorithm RS in gamlss2. Supplying analytical expressions for these derivatives can significantly improve convergence speed and numerical stability in such settings.\nNote that the family object may also include a list of initialization functions for the model parameters. Providing suitable starting values can significantly improve the stability and speed of the estimation process."
  },
  {
    "objectID": "vignettes/families.html#additional-functions",
    "href": "vignettes/families.html#additional-functions",
    "title": "Family Objects",
    "section": "3 Additional Functions",
    "text": "3 Additional Functions\nFamily objects can also include other functions such as\n\ncdf(y, par, ...): Cumulative distribution function.\nquantile(p, par, ...): Quantile function with probability vector p.\nrandom(n, par, ...): Random number generation with number of samples n.\nmean(par, ...): Mean function.\nvariance(par, ...): Variance function.\nskewness(par, ...): Skewness function.\nkurtosis(par, ...): Kurtosis function.\nvalid.response(y): Function to check the values of the response.\n\nNote that the cdf() function is needed it for computing the quantile residuals.\nA complete version of the Normal() family is given below:\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"cdf\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"random\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"quantile\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"mean\" = function(par) { par$mu },\n    \"variance\"  = function(par) { par$sigma^2 },\n    \"skewness\" = function(par) { rep(0, length(par$mu)) },\n    \"kurtosis\" = function(par) { rep(3, length(par$mu)) },\n    \"type\" = \"continuous\",\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"valid.response\" = function(y) {\n      if(is.factor(y) | is.character(y))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    },\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y)) ## example cross-derivative\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}"
  },
  {
    "objectID": "vignettes/families.html#flexible-links",
    "href": "vignettes/families.html#flexible-links",
    "title": "Family Objects",
    "section": "4 Flexible Links",
    "text": "4 Flexible Links\nThe example above used static link functions to define the family object. However, gamlss2 also allows users to define families with flexible link functions. To support this, the helper function make.link2() is used. The only nontrivial part is adapting the score and hess functions to work on the linear predictor scale. This is not done automatically in gamlss2 for performance reasons - users may even write these functions in C for speed. Below is a minimal example of implementing the Normal family with flexible link functions:\n\nNormal &lt;- function(mu.link = \"identity\", sigma.link = \"log\", ...) {\n  mu.link &lt;- make.link2(mu.link)\n  sigma.link &lt;- make.link2(sigma.link)\n\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = mu.link, \"sigma\" = sigma.link),\n    \"pdf\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"type\" = \"continuous\"\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nNote that the score and hess elements are omitted and approximated numerically during estimation.\nThe following is a small example using the new Normal family with different link functions. We now compare two models, one using an identity link (default) and one using a flexible softplus link.\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n     \n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n     \n## estimate models\nm1 &lt;- gamlss2(f, data = abdom, family = Normal(mu.link = \"identity\"))\n\nGAMLSS-RS iteration  1: Global Deviance = 4785.931 eps = 0.999867     \nGAMLSS-RS iteration  2: Global Deviance = 4785.931 eps = 0.000000     \n\nm2 &lt;- gamlss2(f, data = abdom, family = Normal(mu.link = softplus))\n\nGAMLSS-RS iteration  1: Global Deviance = 4787.4409 eps = 0.999866     \nGAMLSS-RS iteration  2: Global Deviance = 4785.3442 eps = 0.000437     \nGAMLSS-RS iteration  3: Global Deviance = 4785.3442 eps = 0.000000     \n\n\nThe fitted means are visualized with\n\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nlines(abdom$x, mean(m1), col = 2, lwd = 5)\nlines(abdom$x, mean(m2), col = 4, lwd = 2)\nlegend(\"topleft\",\n  legend = c(\"Identity\", \"Softplus\"),\n  col = c(2, 4), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\nBoth models yield identical fits in this case, however, in practice, flexible links can help stabilize estimation or improve fit in more complex scenarios."
  },
  {
    "objectID": "vignettes/families.html#summary",
    "href": "vignettes/families.html#summary",
    "title": "Family Objects",
    "section": "5 Summary",
    "text": "5 Summary\nFamily objects in the gamlss2 package are a fundamental component for defining flexible, distributional regression models, and beyond. By encapsulating the necessary elements, such as parameters, link functions, and probability density functions, they provide a powerful framework for customizing models to fit specific data. The flexibility to define custom families, as demonstrated with the Normal() distribution, enables users to extend the package beyond its default families, making it adaptable to a wide range of modeling scenarios."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Overview",
    "text": "Overview\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Installation",
    "text": "Installation\nThe development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "index.html#licence",
    "href": "index.html#licence",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Licence",
    "text": "Licence\nThe package is available under the General Public License version 3 or version 2"
  },
  {
    "objectID": "index.html#illustration",
    "href": "index.html#illustration",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "Illustration",
    "text": "Illustration\nThe package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nWe illustrate how gamlss2 builds on the established gamlss framework by modeling daily maximum temperature (Tmax) at Munich Airport (MUC) to estimate the probability of “heat days” (Tmax \\(\\geq 30^\\circ\\text{C}\\)). Heat days can have serious impacts by stressing highways and railways, increasing the load on healthcare facilities, and affecting airport operations. Using 30 years of historical Tmax data, we fit a flexible distributional regression model that captures the full conditional distribution of daily temperatures. By evaluating this fitted distribution at the \\(30^\\circ\\text{C}\\) threshold, we obtain heat-day probabilities. Required packages can be loaded by\n\nif(!(\"gamlss\" %in% installed.packages())) {\n  install.packages(\"gamlss\")\n}\nlibrary(\"gamlss\")\nlibrary(\"gamlss2\")\n\nThe data comes from the same R-universe as gamlss2 and is loaded with\n\nif(!(\"WeatherGermany\" %in% installed.packages())) {\n  install.packages('WeatherGermany',\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\n\nInstalling package into '/usr/local/lib/R/site-library'\n(as 'lib' is unspecified)\n\ndata(\"WeatherGermany\", package = \"WeatherGermany\")\nMUC &lt;- subset(WeatherGermany, id == 1262)\n\nWe find that the four-parameter SEP family fits the marginal distribution of Tmax quite well. To estimate a full distributional model, we specify the following additive predictor\n\\(\\eta = \\beta_0 + f_1(\\texttt{year}) + f_2(\\texttt{yday}) + f_3(\\texttt{year}, \\texttt{yday})\\)\nfor each parameter. Here, \\(f_1( \\cdot )\\) captures the long-term trend, \\(f_2( \\cdot )\\) models seasonal variation, and \\(f_3( \\cdot, \\cdot )\\) represents a time-varying seasonal effect. The required variables can be added to the data by\n\nMUC$year &lt;- as.POSIXlt(MUC$date)$year + 1900\nMUC$yday &lt;- as.POSIXlt(MUC$date)$yday\n\nIn gamlss, model estimation is performed via\n\nif(!(\"gamlss.add\" %in% installed.packages())) {\n  install.packages(\"gamlss.add\")\n}\nlibrary(\"gamlss.add\")\n\n\nf1 &lt;- Tmax ~ ga(~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")))\nb1 &lt;- gamlss(f1, family = SEP,\n  data = MUC[, c(\"Tmax\", \"year\", \"yday\")])\n\nGAMLSS-RS iteration 1: Global Deviance = 65081.32 \nGAMLSS-RS iteration 2: Global Deviance = 64953.2 \nGAMLSS-RS iteration 3: Global Deviance = 64893.27 \nGAMLSS-RS iteration 4: Global Deviance = 64869.21 \nGAMLSS-RS iteration 5: Global Deviance = 64859.02 \nGAMLSS-RS iteration 6: Global Deviance = 64854.43 \nGAMLSS-RS iteration 7: Global Deviance = 64852.19 \nGAMLSS-RS iteration 8: Global Deviance = 64850.95 \nGAMLSS-RS iteration 9: Global Deviance = 64850.15 \nGAMLSS-RS iteration 10: Global Deviance = 64849.55 \nGAMLSS-RS iteration 11: Global Deviance = 64849.04 \nGAMLSS-RS iteration 12: Global Deviance = 64848.58 \nGAMLSS-RS iteration 13: Global Deviance = 64848.14 \nGAMLSS-RS iteration 14: Global Deviance = 64847.73 \nGAMLSS-RS iteration 15: Global Deviance = 64847.33 \nGAMLSS-RS iteration 16: Global Deviance = 64846.94 \nGAMLSS-RS iteration 17: Global Deviance = 64846.56 \nGAMLSS-RS iteration 18: Global Deviance = 64846.19 \nGAMLSS-RS iteration 19: Global Deviance = 64845.84 \nGAMLSS-RS iteration 20: Global Deviance = 64845.49 \n\n\nWarning in RS(): Algorithm RS has not yet converged\n\n\nThis setup requires loading the gamlss.add package to access mgcv-based smooth terms. Estimation takes 20 iterations of the backfitting algorithm (without full convergence) and about 44 seconds on a 64-bit Linux system. Moreover, gamlss() requires that the input data contains no NA values. In gamlss2 the model can be specified directly, following mgcv syntax\n\nf2 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\"))\nb2 &lt;- gamlss2(f2, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 65324.7244 eps = 0.572868     \nGAMLSS-RS iteration  2: Global Deviance = 65122.8496 eps = 0.003090     \nGAMLSS-RS iteration  3: Global Deviance = 64958.3544 eps = 0.002525     \nGAMLSS-RS iteration  4: Global Deviance = 64895.5748 eps = 0.000966     \nGAMLSS-RS iteration  5: Global Deviance = 64870.287 eps = 0.000389     \nGAMLSS-RS iteration  6: Global Deviance = 64859.484 eps = 0.000166     \nGAMLSS-RS iteration  7: Global Deviance = 64854.7149 eps = 0.000073     \nGAMLSS-RS iteration  8: Global Deviance = 64852.3536 eps = 0.000036     \nGAMLSS-RS iteration  9: Global Deviance = 64851.0278 eps = 0.000020     \nGAMLSS-RS iteration 10: Global Deviance = 64850.16 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 64849.5251 eps = 0.000009     \n\n\nThis model converges in 11 iterations and requires only about 2 seconds of computation time, yielding a similar deviance (small differences arise due to differences in smoothing parameter optimization). In many applications, it is desirable to use the same predictor structure for all distribution parameters. In gamlss, this requires specifying identical formulas separately via sigma.formula, nu.formula, and tau.formula, which can be tedious. In gamlss2, this is simplified using “.”\n\nf3 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")) | . | . | .\nb3 &lt;- gamlss2(f3, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 64917.6847 eps = 0.575529     \nGAMLSS-RS iteration  2: Global Deviance = 64722.0734 eps = 0.003013     \nGAMLSS-RS iteration  3: Global Deviance = 64648.7666 eps = 0.001132     \nGAMLSS-RS iteration  4: Global Deviance = 64618.4329 eps = 0.000469     \nGAMLSS-RS iteration  5: Global Deviance = 64603.983 eps = 0.000223     \nGAMLSS-RS iteration  6: Global Deviance = 64596.5941 eps = 0.000114     \nGAMLSS-RS iteration  7: Global Deviance = 64592.4075 eps = 0.000064     \nGAMLSS-RS iteration  8: Global Deviance = 64589.8333 eps = 0.000039     \nGAMLSS-RS iteration  9: Global Deviance = 64588.0574 eps = 0.000027     \nGAMLSS-RS iteration 10: Global Deviance = 64586.5646 eps = 0.000023     \nGAMLSS-RS iteration 11: Global Deviance = 64585.3395 eps = 0.000018     \nGAMLSS-RS iteration 12: Global Deviance = 64584.2536 eps = 0.000016     \nGAMLSS-RS iteration 13: Global Deviance = 64583.2584 eps = 0.000015     \nGAMLSS-RS iteration 14: Global Deviance = 64582.3412 eps = 0.000014     \nGAMLSS-RS iteration 15: Global Deviance = 64581.4785 eps = 0.000013     \nGAMLSS-RS iteration 16: Global Deviance = 64580.668 eps = 0.000012     \nGAMLSS-RS iteration 17: Global Deviance = 64579.904 eps = 0.000011     \nGAMLSS-RS iteration 18: Global Deviance = 64579.1834 eps = 0.000011     \nGAMLSS-RS iteration 19: Global Deviance = 64578.5027 eps = 0.000010     \nGAMLSS-RS iteration 20: Global Deviance = 64577.8639 eps = 0.000009     \n\n\nThis model converges in 20 iterations in about 30 seconds. After estimation, results can be inspected using the summary() method for both packages. Using plot() in gamlss produces standard residual diagnostic plots, whereas in gamlss2\n\nplot(b3)\n\n\n\n\ndisplays all estimated covariate effects. For residual diagnostics, gamlss2 leverages the topmodels package, which provides infrastructures for probabilistic model assessment. E.g., a PIT histogram can be created by\n\nif(!(\"topmodels\" %in% installed.packages())) {\n  install.packages(\"topmodels\", repos = \"https://zeileis.R-universe.dev\")\n}\nlibrary(\"topmodels\")\n\npithist(b3)\n\n\n\n\nshowing good model calibration. Finally, we compute the probability of a heat day for 2025. First, the procast() function from `topmodels predicts the fitted distributions\n\nnd &lt;- data.frame(\"year\" = 2025, \"yday\" = 0:365)\npf &lt;- procast(b3, newdata = nd, drop = TRUE)\n\nThis yields a distribution vector pf using the infrastructure from the distributions3 package. Probabilities of a heat day can then be calculated with the corresponding cdf() method.\n\nif(!(\"distributions3\" %in% installed.packages())) {\n  install.packages(\"distributions3\")\n}\nlibrary(\"distributions3\")\nprobs &lt;- 1 - cdf(pf, 30)\n\nand visualized, for example, by\n\npar(mar = c(4, 4, 1, 1))\nplot(probs, type = \"l\", xlab = \"Day of Year\",\n  ylab = \"Prob(Tmax &gt; 30)\")\n\n\n  \n\nNote that a predict() method is available for both gamlss and gamlss2, allowing direct prediction of distribution parameters. However, in gamlss, predict() may not fully support new data in all cases."
  },
  {
    "objectID": "vignettes/specials.html",
    "href": "vignettes/specials.html",
    "title": "Special Model Terms",
    "section": "",
    "text": "Special model terms in gamlss2 can be virtually any kind of model specification. For example, gamlss2 supports all smooth terms from the mgcv package, including s(), te(), and others. Another example is the la() constructor, which provides Lasso-penalized model terms.\nDefining new special model terms in gamlss2 is relatively straightforward. To implement a new model term, the following three functions need to be provided:\nAs a demonstration, we show how to incorporate local polynomial regression () via loess() (Cleveland, Grosse, and Shyu 1993). Since loess() supports a weights argument, it integrates naturally into the gamlss2 framework, like many other fitting functions that accept weights."
  },
  {
    "objectID": "vignettes/specials.html#the-special-model-term-constructor",
    "href": "vignettes/specials.html#the-special-model-term-constructor",
    "title": "Special Model Terms",
    "section": "1 The special model term constructor",
    "text": "1 The special model term constructor\nAny special model term constructor must be registered in the fake_formula() function, which is called internally by gamlss2(). If a constructor is not yet registered, the user can either:\n\nprovide the new special term name via the specials argument of fake_formula(), or\nuse the reserved constructor name \"user\", which is already recognized by fake_formula().\n\nTo implement a local polynomial smoothing term via loess(), we define a new constructor function called lo() (registered in fake_formula()). This function can accept all relevant arguments from both loess() and loess.control(), which are passed on to the fitting function.\n\nlo &lt;- function(formula, ...) \n{\n  ## ensure it's a formula\n  if(!inherits(formula, \"formula\")) {\n    formula &lt;- as.character(substitute(formula))\n    formula &lt;- as.formula(paste(\"~\", formula))\n    environment(formula) &lt;- sys.frame(-1)\n  }\n\n  ## list for setting up the special model term \n  st &lt;- list()\n\n  ## control arguments\n  st$control &lt;- list(...)\n\n  ## variables, label and data\n  st$term &lt;- all.vars(formula) \n  st$label &lt;- paste0(\"lo(\", paste0(gsub(\" \", \"\",\n    as.character(formula)), collapse = \"\"), \")\") \n  st$data &lt;- model.frame(formula)\n\n  ## per default scale the data\n  if(is.null(st$control$scale))\n    st$control$scale &lt;- TRUE\n  if(isTRUE(st$control$scale)) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      sx[[j]] &lt;- c(\"mean\" = mean(st$data[[j]]), \"sd\" = sd(st$data[[j]]))\n      st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][\"mean\"]) / sx[[j]][\"sd\"]\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## New model formula used for fitting.\n  st$formula &lt;- update(formula, response_z ~ .)\n\n  ## Assign the \"special\" class and the new class \"n\".\n  class(st) &lt;- c(\"special\", \"lo\")\n\n  return(st) \n}\n\nNote that the data to be used in model fitting is evaluated directly within the constructor function and is scaled per default. The returned list must contain all relevant information required for both estimation and prediction. The return value must be of class \"special\" and \"lo\" in this case."
  },
  {
    "objectID": "vignettes/specials.html#the-fitting-function",
    "href": "vignettes/specials.html#the-fitting-function",
    "title": "Special Model Terms",
    "section": "2 The fitting function",
    "text": "2 The fitting function\nFor estimation within gamlss2(), the generic special_fit() function is used. To support the loess model term, a method special_fit.lo() must be provided.\nThe fitting function takes the list x of class \"lo\" (as returned by the constructor lo()), the current working response z, the current working weights w, and a list of control parameters (which are passed through the dots argument in the gamlss2() call). Estimation is carried out via loess(), where z and w are inserted into the data stored in the x\n\nspecial_fit.lo &lt;- function(x, z, w, control, ...)\n{\n  ## assign current working response and weights\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## set up loess call\n  call &lt;- \"loess(formula = x$formula, data = x$data, weights = weights_w\"\n\n  ## add optional control parameters\n  if(!is.null(x$control)) {\n    for(j in names(x$control))\n      call &lt;- paste0(call, \", \", j, \"= x$control$\", j)\n  }\n  call &lt;- paste0(call, \")\")\n\n  ## estimate model\n  rval &lt;- list(\"model\" = eval(parse(text = call)))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- fitted(rval$model) \n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;-  rval$model$trace.hat\n\n  ## pass scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method \n  class(rval) &lt;- \"lo.fitted\" \n\n  return(rval) \n}\n\nThe returned object must be a list containing a \"model\" element that holds the fitted loess() object. Additionally:\n\n\"fitted.values\" must contain the centered fitted values to ensure identifiability in the backfitting algorithm,\n\"edf\" must specify the effective degrees of freedom used in the smoother, and\nthe returned object must be of class \"lo.fitted\" so that special_predict() can dispatch the appropriate prediction method.\n\nThis setup integrates seamlessly with the iterative estimation algorithm implemented in RS()."
  },
  {
    "objectID": "vignettes/specials.html#the-predict-function",
    "href": "vignettes/specials.html#the-predict-function",
    "title": "Special Model Terms",
    "section": "3 The predict function",
    "text": "3 The predict function\nThe prediction function defines how fitted values are obtained from a model term of class \"lo.fitted\". This method is called by special_predict() during model evaluation and prediction.\n\nspecial_predict.lo.fitted &lt;- function(x, data, se.fit = FALSE, ...) \n{\n  ## scaling\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][\"mean\"]) / x$scalex[[j]][\"sd\"]\n    }\n  }\n\n  ## compute predicted values from the loess model\n  p &lt;- as.numeric(predict(x$model, newdata = data))\n\n  ## apply centering shift\n  p &lt;- p - x$shift\n\n  ## wrap in a data frame if se.fit = TRUE,\n  ## mandatory\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n\n  return(p)\n}\n\nThis function must return a numeric vector (or data frame if se.fit = TRUE) containing the predicted values for the given data. The shift value, computed during model fitting, is subtracted to maintain identifiability of the additive predictor.\nThe argument se.fit is included for compatibility and can be extended in the future to return standard errors."
  },
  {
    "objectID": "vignettes/specials.html#example-munich-rent-data",
    "href": "vignettes/specials.html#example-munich-rent-data",
    "title": "Special Model Terms",
    "section": "4 Example: Munich rent data",
    "text": "4 Example: Munich rent data\nWe use the rent dataset from the gamlss.data package to demonstrate the use of custom model terms based on local polynomial smoothing via loess().\n\n## load the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\nWe first estimate a model using the custom lo() constructor for univariate smoothers on floor size (Fl) and year of construction (A).\n\n## define model formula with univariate smoothers\nf1 &lt;- R ~ lo(~Fl) + lo(~A) + loc + B + H + L | . | . | .\n\n## estimate the model using the BCT distribution\nb1 &lt;- gamlss2(f1, data = rent, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 27582.0017 eps = 0.293228     \nGAMLSS-RS iteration  2: Global Deviance = 27543.3096 eps = 0.001402     \nGAMLSS-RS iteration  3: Global Deviance = 27541.3529 eps = 0.000071     \nGAMLSS-RS iteration  4: Global Deviance = 27541.0354 eps = 0.000011     \nGAMLSS-RS iteration  5: Global Deviance = 27540.9221 eps = 0.000004     \n\n\nNext, we include a bivariate loess smoother for Fl and A to allow for interaction.\n\n## define model formula with bivariate smoother\nf2 &lt;- R ~ lo(~Fl*A) + loc + B + H + L | . | . | .\n\n## estimate the alternative model\nb2 &lt;- gamlss2(f2, data = rent, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 27570.2133 eps = 0.293530     \nGAMLSS-RS iteration  2: Global Deviance = 27520.8741 eps = 0.001789     \nGAMLSS-RS iteration  3: Global Deviance = 27518.9667 eps = 0.000069     \nGAMLSS-RS iteration  4: Global Deviance = 27518.5501 eps = 0.000015     \nGAMLSS-RS iteration  5: Global Deviance = 27518.2997 eps = 0.000009     \n\n\nWe can compare the models using the AIC().\n\nAIC(b1, b2)\n\n        AIC       df\nb2 27659.73 70.71661\nb1 27671.02 65.04671\n\n\nFinally, we visualize the estimated effects from the second model.\n\npar(mfrow = c(2, 2))\nplot(b2, spar = FALSE)\n\n\n\n\n\n\n\n\nThis example illustrates how easy it is to integrate loess smoothers into gamlss2 using the custom model term interface."
  },
  {
    "objectID": "vignettes/gamlss2.html#overview",
    "href": "vignettes/gamlss2.html#overview",
    "title": "Overview",
    "section": "1.1 Overview",
    "text": "1.1 Overview\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?gamlss2,family.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "vignettes/gamlss2.html#installation",
    "href": "vignettes/gamlss2.html#installation",
    "title": "Overview",
    "section": "1.2 Installation",
    "text": "1.2 Installation\nThe development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\",\n            \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "vignettes/gamlss2.html#licence",
    "href": "vignettes/gamlss2.html#licence",
    "title": "Overview",
    "section": "1.3 Licence",
    "text": "1.3 Licence\nThe package is available under the General Public License version 3 or version 2"
  },
  {
    "objectID": "vignettes/gamlss2.html#illustration",
    "href": "vignettes/gamlss2.html#illustration",
    "title": "Overview",
    "section": "1.4 Illustration",
    "text": "1.4 Illustration\nThe package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nWe illustrate how gamlss2 builds on the established gamlss framework by modeling daily maximum temperature (Tmax) at Munich Airport (MUC) to estimate the probability of “heat days” (Tmax \\(\\geq 30^\\circ\\text{C}\\)). Heat days can have serious impacts by stressing highways and railways, increasing the load on healthcare facilities, and affecting airport operations. Using 30 years of historical Tmax data, we fit a flexible distributional regression model that captures the full conditional distribution of daily temperatures. By evaluating this fitted distribution at the \\(30^\\circ\\text{C}\\) threshold, we obtain heat-day probabilities. Required packages can be loaded by\n\nif(!(\"gamlss\" %in% installed.packages())) {\n  install.packages(\"gamlss\")\n}\nlibrary(\"gamlss\")\nlibrary(\"gamlss2\")\n\nThe data comes from the same R-universe as gamlss2 and is loaded with\n\nif(!(\"WeatherGermany\" %in% installed.packages())) {\n  install.packages('WeatherGermany',\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\ndata(\"WeatherGermany\", package = \"WeatherGermany\")\nMUC &lt;- subset(WeatherGermany, id == 1262)\n\nWe find that the four-parameter SEP family fits the marginal distribution of Tmax quite well. To estimate a full distributional model, we specify the following additive predictor\n\\(\\eta = \\beta_0 + f_1(\\texttt{year}) + f_2(\\texttt{yday}) + f_3(\\texttt{year}, \\texttt{yday})\\)\nfor each parameter. Here, \\(f_1( \\cdot )\\) captures the long-term trend, \\(f_2( \\cdot )\\) models seasonal variation, and \\(f_3( \\cdot, \\cdot )\\) represents a time-varying seasonal effect. The required variables can be added to the data by\n\nMUC$year &lt;- as.POSIXlt(MUC$date)$year + 1900\nMUC$yday &lt;- as.POSIXlt(MUC$date)$yday\n\nIn gamlss, model estimation is performed via\n\nif(!(\"gamlss.add\" %in% installed.packages())) {\n  install.packages(\"gamlss.add\",\n    repos = c(\"https://gamlss-dev.r-universe.dev\",\n              \"https://cloud.r-project.org\"))\n}\nlibrary(\"gamlss.add\")\n\n\nf1 &lt;- Tmax ~ ga(~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")))\nb1 &lt;- gamlss(f1, family = SEP,\n  data = MUC[, c(\"Tmax\", \"year\", \"yday\")])\n\nGAMLSS-RS iteration 1: Global Deviance = 65081.32 \nGAMLSS-RS iteration 2: Global Deviance = 64953.2 \nGAMLSS-RS iteration 3: Global Deviance = 64893.27 \nGAMLSS-RS iteration 4: Global Deviance = 64869.21 \nGAMLSS-RS iteration 5: Global Deviance = 64859.02 \nGAMLSS-RS iteration 6: Global Deviance = 64854.43 \nGAMLSS-RS iteration 7: Global Deviance = 64852.19 \nGAMLSS-RS iteration 8: Global Deviance = 64850.95 \nGAMLSS-RS iteration 9: Global Deviance = 64850.15 \nGAMLSS-RS iteration 10: Global Deviance = 64849.55 \nGAMLSS-RS iteration 11: Global Deviance = 64849.04 \nGAMLSS-RS iteration 12: Global Deviance = 64848.58 \nGAMLSS-RS iteration 13: Global Deviance = 64848.14 \nGAMLSS-RS iteration 14: Global Deviance = 64847.73 \nGAMLSS-RS iteration 15: Global Deviance = 64847.33 \nGAMLSS-RS iteration 16: Global Deviance = 64846.94 \nGAMLSS-RS iteration 17: Global Deviance = 64846.56 \nGAMLSS-RS iteration 18: Global Deviance = 64846.19 \nGAMLSS-RS iteration 19: Global Deviance = 64845.84 \nGAMLSS-RS iteration 20: Global Deviance = 64845.49 \n\n\nWarning in RS(): Algorithm RS has not yet converged\n\n\nThis setup requires loading the gamlss.add package to access mgcv-based smooth terms. Estimation takes 20 iterations of the backfitting algorithm (without full convergence) and about 44 seconds on a 64-bit Linux system. Moreover, gamlss() requires that the input data contains no NA values. In gamlss2 the model can be specified directly, following mgcv syntax\n\nf2 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\"))\nb2 &lt;- gamlss2(f2, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 65324.7244 eps = 0.572868     \nGAMLSS-RS iteration  2: Global Deviance = 65122.8496 eps = 0.003090     \nGAMLSS-RS iteration  3: Global Deviance = 64958.3544 eps = 0.002525     \nGAMLSS-RS iteration  4: Global Deviance = 64895.5748 eps = 0.000966     \nGAMLSS-RS iteration  5: Global Deviance = 64870.287 eps = 0.000389     \nGAMLSS-RS iteration  6: Global Deviance = 64859.484 eps = 0.000166     \nGAMLSS-RS iteration  7: Global Deviance = 64854.7149 eps = 0.000073     \nGAMLSS-RS iteration  8: Global Deviance = 64852.3536 eps = 0.000036     \nGAMLSS-RS iteration  9: Global Deviance = 64851.0278 eps = 0.000020     \nGAMLSS-RS iteration 10: Global Deviance = 64850.16 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 64849.5251 eps = 0.000009     \n\n\nThis model converges in 11 iterations and requires only about 2 seconds of computation time, yielding a similar deviance (small differences arise due to differences in smoothing parameter optimization). In many applications, it is desirable to use the same predictor structure for all distribution parameters. In gamlss, this requires specifying identical formulas separately via sigma.formula, nu.formula, and tau.formula, which can be tedious. In gamlss2, this is simplified using “.”\n\nf3 &lt;- Tmax ~ s(year) + s(yday, bs = \"cc\") +\n  te(year, yday, bs = c(\"cr\", \"cc\")) | . | . | .\nb3 &lt;- gamlss2(f3, family = SEP, data = MUC)\n\nGAMLSS-RS iteration  1: Global Deviance = 64917.6847 eps = 0.575529     \nGAMLSS-RS iteration  2: Global Deviance = 64722.0734 eps = 0.003013     \nGAMLSS-RS iteration  3: Global Deviance = 64648.7666 eps = 0.001132     \nGAMLSS-RS iteration  4: Global Deviance = 64618.4329 eps = 0.000469     \nGAMLSS-RS iteration  5: Global Deviance = 64603.983 eps = 0.000223     \nGAMLSS-RS iteration  6: Global Deviance = 64596.5941 eps = 0.000114     \nGAMLSS-RS iteration  7: Global Deviance = 64592.4075 eps = 0.000064     \nGAMLSS-RS iteration  8: Global Deviance = 64589.8333 eps = 0.000039     \nGAMLSS-RS iteration  9: Global Deviance = 64588.0574 eps = 0.000027     \nGAMLSS-RS iteration 10: Global Deviance = 64586.5646 eps = 0.000023     \nGAMLSS-RS iteration 11: Global Deviance = 64585.3395 eps = 0.000018     \nGAMLSS-RS iteration 12: Global Deviance = 64584.2536 eps = 0.000016     \nGAMLSS-RS iteration 13: Global Deviance = 64583.2584 eps = 0.000015     \nGAMLSS-RS iteration 14: Global Deviance = 64582.3412 eps = 0.000014     \nGAMLSS-RS iteration 15: Global Deviance = 64581.4785 eps = 0.000013     \nGAMLSS-RS iteration 16: Global Deviance = 64580.668 eps = 0.000012     \nGAMLSS-RS iteration 17: Global Deviance = 64579.904 eps = 0.000011     \nGAMLSS-RS iteration 18: Global Deviance = 64579.1834 eps = 0.000011     \nGAMLSS-RS iteration 19: Global Deviance = 64578.5027 eps = 0.000010     \nGAMLSS-RS iteration 20: Global Deviance = 64577.8639 eps = 0.000009     \n\n\nThis model converges in 20 iterations in about 30 seconds. After estimation, results can be inspected using the summary() method for both packages. Using plot() in gamlss produces standard residual diagnostic plots, whereas in gamlss2\n\nplot(b3)\n\n\n\n\n\n\n\n\ndisplays all estimated covariate effects. For residual diagnostics, gamlss2 leverages the topmodels package, which provides infrastructures for probabilistic model assessment. E.g., a PIT histogram can be created by\n\nif(!(\"topmodels\" %in% installed.packages())) {\n  install.packages(\"topmodels\", repos = \"https://zeileis.R-universe.dev\")\n}\nlibrary(\"topmodels\")\n\npithist(b3)\n\n\n\n\n\n\n\n\nshowing good model calibration. Finally, we compute the probability of a heat day for 2025. First, the procast() function from `topmodels predicts the fitted distributions\n\nnd &lt;- data.frame(\"year\" = 2025, \"yday\" = 0:365)\npf &lt;- procast(b3, newdata = nd, drop = TRUE)\n\nThis yields a distribution vector pf using the infrastructure from the distributions3 package. Probabilities of a heat day can then be calculated with the corresponding cdf() method.\n\nif(!(\"distributions3\" %in% installed.packages())) {\n  install.packages(\"distributions3\")\n}\nlibrary(\"distributions3\")\nprobs &lt;- 1 - cdf(pf, 30)\n\nand visualized, for example, by\n\npar(mar = c(4, 4, 1, 1))\nplot(probs, type = \"l\", xlab = \"Day of Year\",\n  ylab = \"Prob(Tmax &gt; 30)\")\n\n\n\n\n\n\n\n\nNote that a predict() method is available for both gamlss and gamlss2, allowing direct prediction of distribution parameters. However, in gamlss, predict() may not fully support new data in all cases."
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "gamlss2 0.1-0",
    "section": "",
    "text": "gamlss2 0.1-0\n\nFirst version of ‘gamlss2’ providing a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models."
  },
  {
    "objectID": "man/prodist.gamlss2.html",
    "href": "man/prodist.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 405.766 eps = 0.003924     \nGAMLSS-RS iteration  3: Global Deviance = 405.7473 eps = 0.000045     \nGAMLSS-RS iteration  4: Global Deviance = 405.7473 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                  1                                   2 \n\"GDF NO(mu = 23.02, sigma = 10.09)\" \"GDF NO(mu = 59.14, sigma = 18.49)\" \n                                  3 \n\"GDF NO(mu = 96.54, sigma = 33.89)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.428687 23.02058  39.61248\n2 28.721600 59.13735  89.55309\n3 40.795319 96.53656 152.27779\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.428687  59.137347 152.277794 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\nvariance(d)\n\n        1         2         3 \n 101.7507  341.9341 1148.4146 \n\n## simulate random numbers\nrandom(d, 5)\n\n       r_1       r_2      r_3      r_4       r_5\n1 42.96650  28.38734 35.71977 33.71695  24.33406\n2 95.84680  91.07311 74.15519 74.95690  41.89576\n3 56.91729 113.92945 90.77733 93.16320 105.01322\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.992414e-34 1.652166e-13 0.0029253352 0.001105976 8.928201e-15\n2 1.783797e-18 5.885926e-10 0.0001297196 0.019094897 1.877372e-03\n3 5.850207e-10 1.024848e-06 0.0002035755 0.004585323 1.171096e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 1.637069e-34 2.260584e-13 0.0112397196 0.99625942 1.0000000\n2 3.783013e-18 1.795168e-09 0.0006917068 0.31060410 0.9864409\n3 3.324736e-09 7.657479e-06 0.0021951055 0.08483964 0.5407018\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                   1 \n\"GDF PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "href": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3647 eps = 0.125474     \nGAMLSS-RS iteration  2: Global Deviance = 405.766 eps = 0.003924     \nGAMLSS-RS iteration  3: Global Deviance = 405.7473 eps = 0.000045     \nGAMLSS-RS iteration  4: Global Deviance = 405.7473 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                  1                                   2 \n\"GDF NO(mu = 23.02, sigma = 10.09)\" \"GDF NO(mu = 59.14, sigma = 18.49)\" \n                                  3 \n\"GDF NO(mu = 96.54, sigma = 33.89)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.428687 23.02058  39.61248\n2 28.721600 59.13735  89.55309\n3 40.795319 96.53656 152.27779\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.428687  59.137347 152.277794 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.02058 59.13735 96.53656 \n\nvariance(d)\n\n        1         2         3 \n 101.7507  341.9341 1148.4146 \n\n## simulate random numbers\nrandom(d, 5)\n\n       r_1       r_2      r_3      r_4       r_5\n1 42.96650  28.38734 35.71977 33.71695  24.33406\n2 95.84680  91.07311 74.15519 74.95690  41.89576\n3 56.91729 113.92945 90.77733 93.16320 105.01322\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.992414e-34 1.652166e-13 0.0029253352 0.001105976 8.928201e-15\n2 1.783797e-18 5.885926e-10 0.0001297196 0.019094897 1.877372e-03\n3 5.850207e-10 1.024848e-06 0.0002035755 0.004585323 1.171096e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 1.637069e-34 2.260584e-13 0.0112397196 0.99625942 1.0000000\n2 3.783013e-18 1.795168e-09 0.0006917068 0.31060410 0.9864409\n3 3.324736e-09 7.657479e-06 0.0021951055 0.08483964 0.5407018\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                   1 \n\"GDF PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Documentation",
      "Predictions and model statistics",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/softplus.html",
    "href": "man/softplus.html",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "softplus"
    ]
  },
  {
    "objectID": "man/softplus.html#softplus-link-object",
    "href": "man/softplus.html#softplus-link-object",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "softplus"
    ]
  },
  {
    "objectID": "man/make.link2.html",
    "href": "man/make.link2.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list of class “link_gamlss2” containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"",
    "crumbs": [
      "Documentation",
      "Families and links",
      "make.link2"
    ]
  },
  {
    "objectID": "man/make.link2.html#create-a-link-for-families",
    "href": "man/make.link2.html#create-a-link-for-families",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list of class “link_gamlss2” containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr [1:2] \"link_gamlss2\" \"link-glm\"",
    "crumbs": [
      "Documentation",
      "Families and links",
      "make.link2"
    ]
  },
  {
    "objectID": "man/find_family.html",
    "href": "man/find_family.html",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL, ...)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n## Find gamlss2 model.\nfind_gamlss2(formula, families = NULL, k = 2,\n  select = FALSE, verbose = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\nformula\n\n\nA model formula, see gamlss2.\n\n\n\n\nselect\n\n\nLogical, if set to select = TRUE, model term selection is enforced using model fitting function select_gamlss2.\n\n\n\n\n…\n\n\nFor function available_families(), arguments passed to the family objects, e.g., for setting link functions mu.link = “log”. Further arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family(). For function find_gamlss(), arguments are passed to available_families() and gamlss2.\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)\n\n## search complete model\n## b &lt;- find_gamlss2(R ~ s(Fl) + s(A) | . | . | ., data = rent,\n##   select = TRUE, mu.link = \"log\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "find_family"
    ]
  },
  {
    "objectID": "man/find_family.html#find-and-fit-gamlss-families",
    "href": "man/find_family.html#find-and-fit-gamlss-families",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL, ...)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n## Find gamlss2 model.\nfind_gamlss2(formula, families = NULL, k = 2,\n  select = FALSE, verbose = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\nformula\n\n\nA model formula, see gamlss2.\n\n\n\n\nselect\n\n\nLogical, if set to select = TRUE, model term selection is enforced using model fitting function select_gamlss2.\n\n\n\n\n…\n\n\nFor function available_families(), arguments passed to the family objects, e.g., for setting link functions mu.link = “log”. Further arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family(). For function find_gamlss(), arguments are passed to available_families() and gamlss2.\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)\n\n## search complete model\n## b &lt;- find_gamlss2(R ~ s(Fl) + s(A) | . | . | ., data = rent,\n##   select = TRUE, mu.link = \"log\")",
    "crumbs": [
      "Documentation",
      "Families and links",
      "find_family"
    ]
  },
  {
    "objectID": "man/new_formula.html",
    "href": "man/new_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "new_formula"
    ]
  },
  {
    "objectID": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "href": "man/new_formula.html#extracting-a-new-formula-after-selection-algorithms",
    "title": "gamlss2",
    "section": "",
    "text": "The generic function extracts the selected model terms after applying variable selection algorithms and constructs a new model formula based on those selected terms.\n\n\n\nnew_formula(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model.\n\n\n\n\n…\n\n\nNot used yet.\n\n\n\n\n\n\nA Formula of selected model terms.\n\n\n\nstep_gamlss2, select_gamlss2, gamlss2",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "new_formula"
    ]
  },
  {
    "objectID": "man/misc.html",
    "href": "man/misc.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "misc"
    ]
  },
  {
    "objectID": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "href": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "misc"
    ]
  },
  {
    "objectID": "man/lasso.html",
    "href": "man/lasso.html",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “ordinal” the ordinal fusion penalty and type = 4 or type = “nominal” the nominal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” for shrinkage parameter selection, arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the Bayesian Information Criterion (BIC).\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nAndreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in the framework of generalized additive models for location, scale and shape. Computational Statistics & Data Analysis. doi:10.1016/j.csda.2019.06.005\nOelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of penalties in generalized structured models. Adv Data Anal Classif. doi:10.1007/s11634-015-0205-y\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) | . | .\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 5)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"sigma.la(Ac\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), main = \"Fused Lasso\")\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X %*% beta$mu\nsigma &lt;- exp(-1 + X %*% beta$sigma)\n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=3) | la(X,type=3)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\",\n  zoom = c(8, 9))\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\n## true positive rate\ntp &lt;- mean(c(cb_mu[beta$mu &gt; 0] &gt; 0,\n  cb_sigma[beta$sigma &gt; 0] &gt; 0))\n\n## false positive rate, needs threshold\nthres &lt;- 0.01\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "lasso"
    ]
  },
  {
    "objectID": "man/lasso.html#lasso-model-terms",
    "href": "man/lasso.html#lasso-model-terms",
    "title": "gamlss2",
    "section": "",
    "text": "Constructor function and plotting for Lasso penalized model terms for GAMLSS.\n\n\n\n## Model term constructor function.\nla(x, type = 1, const = 1e-05, ...)\n\n## Plotting function.\nplot_lasso(x, terms = NULL,\n  which = c(\"criterion\", \"coefficients\"),\n  zoom = c(3, 4), spar = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nFor function la(), a numeric vector or matrix, or a formula. See the examples. For function plot_lasso(), an object returned from gamlss2.\n\n\n\n\ntype\n\n\nInteger or character, the type of the Lasso penalty. type = 1 or type = “normal” uses the normal penalty, type = 2 or type = “group” the group penalty, type = 3 or type = “ordinal” the ordinal fusion penalty and type = 4 or type = “nominal” the nominal fusion penalty.\n\n\n\n\nconst\n\n\nNumeric, the constant that is used for approximating the absolute function.\n\n\n\n\nterms\n\n\nCharacter or integer, the model term that should be plotted. The default terms = NULL is plotting all model terms.\n\n\n\n\nwhich\n\n\nCharacter, should the information criterion or the coefficient paths be plotted? See the examples.\n\n\n\n\nzoom\n\n\nNumeric vector of length 2, the zooming factors for plotting information criteria curves and coefficient paths. The first element sets the distance from the optimum shrinkage parameter lambda to the left side, and the second element to the right side, respectively.\n\n\n\n\nspar\n\n\nLogical, should plotting parameters be automatically set in par?\n\n\n\n\n…\n\n\nFor function la() further control arguments can be passed: The criterion = “bic” for shrinkage parameter selection, arguments for creating the model.matrix if the model term is specified using a formula. For function plot_lasso() arguments like lwd, col, main, etc., that control plotting parameters can be supplied. An additional ridge penalty (elastic net) can be added to each la() term be setting add_ridge = TRUE in the gamlss2 call.\n\n\n\n\n\n\nTo implement the Lasso penalty, an approximation of the absolute value function is used, following the approach by Oelker and Tutz (2015). This enables the use of standard Newton-Raphson-type algorithms for estimation. Each Lasso model term has its own shrinkage parameter, allowing a mix of different penalty types within the model. The framework builds on the methodology of Groll et al. (2019), where coefficients are updated through iteratively reweighted least squares (IWLS). This is feasible due to the absolute function approximation, which results in a quadratic penalty matrix similar to that used in penalized splines. By default, the shrinkage parameters are selected using the Bayesian Information Criterion (BIC).\n\n\n\nThe la() function is used internally within gamlss2 and provides the necessary details for estimating Lasso-type model terms. Essentially, it serves as a special model term, as outlined in specials.\nCurrently, the plot_lasso() function does not return any output.\n\n\n\nAndreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in the framework of generalized additive models for location, scale and shape. Computational Statistics & Data Analysis. doi:10.1016/j.csda.2019.06.005\nOelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of penalties in generalized structured models. Adv Data Anal Classif. doi:10.1007/s11634-015-0205-y\n\n\n\ngamlss2, specials.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## transform numeric to factor variables\nrent$Flc &lt;- cut(rent$Fl, breaks = seq(20, 160, by = 10),\n  include.lowest = TRUE)\nrent$Ac &lt;- cut(rent$A, breaks = seq(1890, 1990, by = 10),\n  include.lowest = TRUE)\n\n## set up the model formula for a BCT model\nf &lt;- R ~ la(Flc,type=4) + la(Ac,type=4) + la(loc,type=4) | . | .\n\n## estimation\nb &lt;- gamlss2(f, data = rent, family = BCT)\n\n## summary, shows the estimated degrees of freedom\n## for each model term\nsummary(b)\n\n## plot estimated coefficients\nplot(b)\n\n## plot information criteria curves\n## for each model term.\nplot_lasso(b)\n\n## plot parameter paths.\nplot_lasso(b, which = \"coefficients\")\n\n## plot a single model term.\nplot_lasso(b, which = \"coefficients\", term = 5)\n\n## same with\nplot_lasso(b, which = \"coefficients\", term = \"sigma.la(Ac\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7))\n\n## set names\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), names = c(\"A\", \"B\", \"C\"))\n\n## set title\nplot_lasso(b, which = \"coefficients\", term = 5,\n  zoom = c(8, 7), main = \"Fused Lasso\")\n\n## simulated example using the normal lasso\n## and a matrix as argument for la()\nset.seed(123)\n\n## number of observations and covariates\nn &lt;- 500\nk &lt;- 50\n\n## model matrix\nX &lt;- matrix(rnorm(n * k), n, k)\ncolnames(X) &lt;- paste0(\"x\", 1:k)\n\n## true coefficients\nbeta &lt;- list(\n  \"mu\" = rbinom(k, 1, 0.1),\n  \"sigma\" = rbinom(k, 1, 0.1) * 0.3\n)\n\n## parameters\nmu &lt;- X %*% beta$mu\nsigma &lt;- exp(-1 + X %*% beta$sigma)\n\n## response\ny &lt;- rnorm(n, mean = mu, sd = sigma)\n\n## model formula with nominal fused lasso\nf &lt;- y ~ la(X,type=3) | la(X,type=3)\n\n## estimate model incl. extra ridge penalty\n## for all la() model terms\nb &lt;- gamlss2(f, add_ridge = TRUE)\n\n## plot information criteria curves\nplot_lasso(b)\n\n## coefficient paths\nplot_lasso(b, which = \"coefficients\")\n\n## zoom out\nplot_lasso(b, which = \"coefficients\",\n  zoom = c(8, 9))\n\n## extract coefficients\ncb &lt;- coef(b, full = TRUE)\n\n## compare (without intercept)\ncb_mu &lt;- cb[grep(\"mu.\", names(cb))][-1]\ncb_sigma &lt;- cb[grep(\"sigma.\", names(cb))][-1]\n\n## true positive rate\ntp &lt;- mean(c(cb_mu[beta$mu &gt; 0] &gt; 0,\n  cb_sigma[beta$sigma &gt; 0] &gt; 0))\n\n## false positive rate, needs threshold\nthres &lt;- 0.01\nfp &lt;- mean(c(abs(cb_mu[beta$mu == 0]) &gt; thres,\n  abs(cb_sigma[beta$sigma == 0]) &gt; thres))",
    "crumbs": [
      "Documentation",
      "Model terms",
      "lasso"
    ]
  },
  {
    "objectID": "man/gamlss2.html",
    "href": "man/gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \nmu.(Intercept)    226.33309    1.25941  179.71  &lt; 2e-16 ***\nsigma.(Intercept)  -2.92261    0.01104 -264.67  &lt; 2e-16 ***\nnu.(Intercept)     -0.18026    0.04611   -3.91 0.000103 ***\ntau.(Intercept)     2.65014    0.01440  183.98  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    mu.s(x) sigma.s(x) nu.s(x) tau.s(x)\nedf  4.5505     2.5450  1.0015   1.0004\n*--------\nn = 610 df =  13.1 res.df =  596.9\nDeviance = 4770.1544 Null Dev. Red. = 33.39%\nAIC = 4796.3494 elapsed =  0.86sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4816.1239 eps = 0.553570     \nGAMLSS-RS iteration  2: Global Deviance = -7383.8761 eps = 2.533157     \nGAMLSS-RS iteration  3: Global Deviance = -19583.8761 eps = 1.652248     \nGAMLSS-RS iteration  4: Global Deviance = -31783.8761 eps = 0.622961     \nGAMLSS-RS iteration  5: Global Deviance = -36347.9794 eps = 0.143598     \nGAMLSS-RS iteration  6: Global Deviance = -36347.9794 eps = 0.000000     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 5076.3585 eps = 0.529448     \nGAMLSS-RS iteration  2: Global Deviance = 5076.3565 eps = 0.000000     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.358484           -2.302585            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 7749.3698 eps = 0.013476     \nGAMLSS-RS iteration  2: Global Deviance = 4869.5907 eps = 0.371614     \nGAMLSS-RS iteration  3: Global Deviance = 4793.4424 eps = 0.015637     \nGAMLSS-RS iteration  4: Global Deviance = 4792.9818 eps = 0.000096     \nGAMLSS-RS iteration  5: Global Deviance = 4792.9727 eps = 0.000001     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "href": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(formula, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(formula, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam. For gamlss.list() formula is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nCoefficients:\n                   Estimate Std. Error t value Pr(&gt;|t|)    \nmu.(Intercept)    226.33309    1.25941  179.71  &lt; 2e-16 ***\nsigma.(Intercept)  -2.92261    0.01104 -264.67  &lt; 2e-16 ***\nnu.(Intercept)     -0.18026    0.04611   -3.91 0.000103 ***\ntau.(Intercept)     2.65014    0.01440  183.98  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n    mu.s(x) sigma.s(x) nu.s(x) tau.s(x)\nedf  4.5505     2.5450  1.0015   1.0004\n*--------\nn = 610 df =  13.1 res.df =  596.9\nDeviance = 4770.1544 Null Dev. Red. = 33.39%\nAIC = 4796.3494 elapsed =  0.86sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4816.1239 eps = 0.553570     \nGAMLSS-RS iteration  2: Global Deviance = -7383.8761 eps = 2.533157     \nGAMLSS-RS iteration  3: Global Deviance = -19583.8761 eps = 1.652248     \nGAMLSS-RS iteration  4: Global Deviance = -31783.8761 eps = 0.622961     \nGAMLSS-RS iteration  5: Global Deviance = -36347.9794 eps = 0.143598     \nGAMLSS-RS iteration  6: Global Deviance = -36347.9794 eps = 0.000000     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 5076.3585 eps = 0.529448     \nGAMLSS-RS iteration  2: Global Deviance = 5076.3565 eps = 0.000000     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.358484           -2.302585            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 7749.3698 eps = 0.013476     \nGAMLSS-RS iteration  2: Global Deviance = 4869.5907 eps = 0.371614     \nGAMLSS-RS iteration  3: Global Deviance = 4793.4424 eps = 0.015637     \nGAMLSS-RS iteration  4: Global Deviance = 4792.9818 eps = 0.000096     \nGAMLSS-RS iteration  5: Global Deviance = 4792.9727 eps = 0.000001     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.5602 eps = 0.534336     \nGAMLSS-RS iteration  2: Global Deviance = 4770.2329 eps = 0.000906     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1693 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1544 eps = 0.000003",
    "crumbs": [
      "Documentation",
      "Regression models",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/RS_CG.html",
    "href": "man/RS_CG.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "href": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html",
    "href": "man/HarzTraffic.html",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.1249 eps = 0.148398     \nGAMLSS-RS iteration  2: Global Deviance = 10151.6273 eps = 0.001131     \nGAMLSS-RS iteration  3: Global Deviance = 10151.3662 eps = 0.000025     \nGAMLSS-RS iteration  4: Global Deviance = 10151.2887 eps = 0.000007     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\n\n## corresponding quantiles\np &lt;- quantile(m, newdata = nd, probs = c(0.05, 0.5, 0.95))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Data",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "href": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.1249 eps = 0.148398     \nGAMLSS-RS iteration  2: Global Deviance = 10151.6273 eps = 0.001131     \nGAMLSS-RS iteration  3: Global Deviance = 10151.3662 eps = 0.000025     \nGAMLSS-RS iteration  4: Global Deviance = 10151.2887 eps = 0.000007     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\n\n## corresponding quantiles\np &lt;- quantile(m, newdata = nd, probs = c(0.05, 0.5, 0.95))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Documentation",
      "Data",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/special_terms.html",
    "href": "man/special_terms.html",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## compute median rent R estimate\nnd$fit &lt;- quantile(b, newdata = nd, probs = 0.5)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Documentation",
      "Model terms",
      "special_terms"
    ]
  },
  {
    "objectID": "man/special_terms.html#special-model-terms-for-gamlss",
    "href": "man/special_terms.html#special-model-terms-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict quantiles\npq &lt;- quantile(b, probs = c(0.05, 0.5, 0.95))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## compute median rent R estimate\nnd$fit &lt;- quantile(b, newdata = nd, probs = 0.5)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Documentation",
      "Model terms",
      "special_terms"
    ]
  },
  {
    "objectID": "man/discretize.html",
    "href": "man/discretize.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Simulate count data using the Poisson distribution.\nset.seed(111)\ny &lt;- rpois(1000, lambda = 10)\n\n## Create a discretized family using the BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model using the discretized family.\nfit_family(y, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = 5272.794 eps = 0.498257     \nGAMLSS-RS iteration  2: Global Deviance = 5182.6298 eps = 0.017099     \nGAMLSS-RS iteration  3: Global Deviance = 5169.4544 eps = 0.002542     \nGAMLSS-RS iteration  4: Global Deviance = 5163.3186 eps = 0.001186     \nGAMLSS-RS iteration  5: Global Deviance = 5126.728 eps = 0.007086     \nGAMLSS-RS iteration  6: Global Deviance = 5123.1813 eps = 0.000691     \nGAMLSS-RS iteration  7: Global Deviance = 5121.8096 eps = 0.000267     \nGAMLSS-RS iteration  8: Global Deviance = 5121.3064 eps = 0.000098     \nGAMLSS-RS iteration  9: Global Deviance = 5121.12 eps = 0.000036     \nGAMLSS-RS iteration 10: Global Deviance = 5121.0523 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 5121.012 eps = 0.000007",
    "crumbs": [
      "Documentation",
      "Families and links",
      "discretize"
    ]
  },
  {
    "objectID": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "href": "man/discretize.html#discretize-continuous-distribution-family-for-count-regression-models",
    "title": "gamlss2",
    "section": "",
    "text": "This function takes any continuous distribution family object and discretizes it, enabling it to be used for the estimation of count regression models. The discretized family can then be used in gamlss2 models that deal with count data.\n\n\n\ndiscretize(family = NO)\n\n\n\n\n\n\n\nfamily\n\n\nA continuous distribution family object. The family will be discretized for modeling count data, where the distribution is adapted for count outcomes.\n\n\n\n\n\n\nThe function discretizes a continuous distribution family by converting its cumulative distribution function (CDF) into a probability mass function (PMF). This is done by computing the difference between the CDF evaluated at adjacent points. The resulting discretized distribution can be used in count regression models to estimate the relationship between count data and explanatory variables.\n\n\n\nReturns an object of class “gamlss2.family”, which is a discretized version of the input continuous family object, suitable for use in gamlss2 models for count data.\n\n\n\ngamlss2, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Simulate count data using the Poisson distribution.\nset.seed(111)\ny &lt;- rpois(1000, lambda = 10)\n\n## Create a discretized family using the BCT distribution (with log link for mu).\nfam &lt;- discretize(family = BCT(mu.link = \"log\"))\n\n## Fit a count regression model using the discretized family.\nfit_family(y, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = 5272.794 eps = 0.498257     \nGAMLSS-RS iteration  2: Global Deviance = 5182.6298 eps = 0.017099     \nGAMLSS-RS iteration  3: Global Deviance = 5169.4544 eps = 0.002542     \nGAMLSS-RS iteration  4: Global Deviance = 5163.3186 eps = 0.001186     \nGAMLSS-RS iteration  5: Global Deviance = 5126.728 eps = 0.007086     \nGAMLSS-RS iteration  6: Global Deviance = 5123.1813 eps = 0.000691     \nGAMLSS-RS iteration  7: Global Deviance = 5121.8096 eps = 0.000267     \nGAMLSS-RS iteration  8: Global Deviance = 5121.3064 eps = 0.000098     \nGAMLSS-RS iteration  9: Global Deviance = 5121.12 eps = 0.000036     \nGAMLSS-RS iteration 10: Global Deviance = 5121.0523 eps = 0.000013     \nGAMLSS-RS iteration 11: Global Deviance = 5121.012 eps = 0.000007",
    "crumbs": [
      "Documentation",
      "Families and links",
      "discretize"
    ]
  },
  {
    "objectID": "man/stepwise.html",
    "href": "man/stepwise.html",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Documentation",
      "Regression models",
      "stepwise"
    ]
  },
  {
    "objectID": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "href": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\nnew_formula, gamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Documentation",
      "Regression models",
      "stepwise"
    ]
  },
  {
    "objectID": "man/fake_formula.html",
    "href": "man/fake_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "href": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Documentation",
      "Misc functionality",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/ologit.html",
    "href": "man/ologit.html",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nologit(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe ologit() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = ologit(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = ologit(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink function: location = identity, theta1 = identity, delta2 = identity\n*--------\nCoefficients:\n                        Estimate Std. Error t value Pr(&gt;|t|)  \nlocation.(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nlocation.InflMedium       0.5671     0.5367   1.057   0.2947  \nlocation.InflHigh         1.2904     0.5572   2.316   0.0238 *\nlocation.TypeApartment   -0.5731     0.6345  -0.903   0.3698  \nlocation.TypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nlocation.TypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nlocation.ContHigh         0.3607     0.4462   0.808   0.4219  \ntheta1.(Intercept)       -0.6932  3481.4687   0.000   0.9998  \ndelta2.(Intercept)        0.1724     0.2191   0.787   0.4344  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = 2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533",
    "crumbs": [
      "Documentation",
      "Families and links",
      "ologit"
    ]
  },
  {
    "objectID": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "href": "man/ologit.html#ordered-logistic-family-for-ordinal-regression",
    "title": "gamlss2",
    "section": "",
    "text": "Defines the ordered logistic (cumulative logit) family for modeling ordinal response variables within the gamlss2 framework. This implementation supports flexible modeling of the location and threshold (cutpoint) parameters, including effects of covariates.\n\n\n\nologit(k)\n\n\n\n\n\n\n\nk\n\n\nAn integer specifying the number of response categories. Must be k &gt;= 2.\n\n\n\n\n\n\nThis family implements a cumulative logit model for ordinal responses with k ordered categories. The linear predictor models a latent location parameter, and the cutpoints between response categories are parameterized via a monotonic transformation:\n\n\nThe first cutpoint is modeled directly (theta1).\n\n\nThe remaining cutpoints are expressed as theta1 + exp(delta_j) for j = 2, …, k - 1, ensuring that the thresholds remain ordered.\n\n\nThe ologit() family supports modeling the location and threshold differences (delta_j) as functions of covariates using additive predictors in gamlss2 via the “|” formula interface.\nThe family returns an object of class “gamlss2.family”, which includes methods for evaluating the log-likelihood, simulating from the model, and computing predicted probabilities.\n\n\n\nA “gamlss2.family” object to be used with gamlss2.\n\n\n\ngamlss2, gamlss2.family, polr\n\n\n\n\nlibrary(\"gamlss2\")\n\n## Example using the housing data from the MASS package:\nlibrary(\"MASS\")\n\n## Fit standard cumulative logit model using polr().\nm &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)\nsummary(m)\n\nCall:\npolr(formula = Sat ~ Infl + Type + Cont, data = housing, weights = Freq)\n\nCoefficients:\n                Value Std. Error t value\nInflMedium     0.5664    0.10465   5.412\nInflHigh       1.2888    0.12716  10.136\nTypeApartment -0.5724    0.11924  -4.800\nTypeAtrium    -0.3662    0.15517  -2.360\nTypeTerrace   -1.0910    0.15149  -7.202\nContHigh       0.3603    0.09554   3.771\n\nIntercepts:\n            Value   Std. Error t value\nLow|Medium  -0.4961  0.1248    -3.9739\nMedium|High  0.6907  0.1255     5.5049\n\nResidual Deviance: 3479.149 \nAIC: 3495.149 \n\n## Convert response to integer for use with gamlss2.\nhousing$Satint &lt;- as.integer(housing$Sat)\n\n## Fit equivalent model using gamlss2.\nb &lt;- gamlss2(Satint ~ Infl + Type + Cont,\n  data = housing, weights = Freq,\n  family = ologit(k = 3))\n\nGAMLSS-RS iteration  1: Global Deviance = 3483.3719 eps = 0.322658     \nGAMLSS-RS iteration  2: Global Deviance = 3479.4958 eps = 0.001112     \nGAMLSS-RS iteration  3: Global Deviance = 3479.1765 eps = 0.000091     \nGAMLSS-RS iteration  4: Global Deviance = 3479.1514 eps = 0.000007     \n\nsummary(b)\n\nCall:\ngamlss2(formula = Satint ~ Infl + Type + Cont, data = housing, \n    family = ologit(k = 3), weights = Freq)\n---\nFamily: Ordered Logit (3 categories) \nLink function: location = identity, theta1 = identity, delta2 = identity\n*--------\nCoefficients:\n                        Estimate Std. Error t value Pr(&gt;|t|)  \nlocation.(Intercept)     -0.1949  3481.4686   0.000   1.0000  \nlocation.InflMedium       0.5671     0.5367   1.057   0.2947  \nlocation.InflHigh         1.2904     0.5572   2.316   0.0238 *\nlocation.TypeApartment   -0.5731     0.6345  -0.903   0.3698  \nlocation.TypeAtrium      -0.3666     0.6364  -0.576   0.5666  \nlocation.TypeTerrace     -1.0924     0.6401  -1.707   0.0928 .\nlocation.ContHigh         0.3607     0.4462   0.808   0.4219  \ntheta1.(Intercept)       -0.6932  3481.4687   0.000   0.9998  \ndelta2.(Intercept)        0.1724     0.2191   0.787   0.4344  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n*--------\nn = 72 df =  9 res.df =  63\nDeviance = 3479.1514 Null Dev. Red. = 2099.21%\nAIC = 3497.1514 elapsed =  0.03sec\n\n## Compare coefficients.\ncoef(m)\n\n   InflMedium      InflHigh TypeApartment    TypeAtrium   TypeTerrace \n    0.5663937     1.2888191    -0.5723501    -0.3661866    -1.0910149 \n     ContHigh \n    0.3602841 \n\ncoef(b)\n\n  location.p.(Intercept)    location.p.InflMedium      location.p.InflHigh \n              -0.1949313                0.5671416                1.2904361 \nlocation.p.TypeApartment    location.p.TypeAtrium   location.p.TypeTerrace \n              -0.5730733               -0.3666344               -1.0924039 \n     location.p.ContHigh     theta1.p.(Intercept)     delta2.p.(Intercept) \n               0.3607349               -0.6931503                0.1723565 \n\n## Predict class probabilities.\npm &lt;- predict(m, type = \"p\")\npb &lt;- predict(b)\npb &lt;- family(b)$probabilities(pb)\n\nprint(head(pm))\n\n        Low    Medium      High\n1 0.3784493 0.2876752 0.3338755\n2 0.3784493 0.2876752 0.3338755\n3 0.3784493 0.2876752 0.3338755\n4 0.2568264 0.2742122 0.4689613\n5 0.2568264 0.2742122 0.4689613\n6 0.2568264 0.2742122 0.4689613\n\nprint(head(pb))\n\n       Pr(Y=1)   Pr(Y=2)   Pr(Y=3)\n[1,] 0.3779593 0.2879814 0.3340593\n[2,] 0.3779593 0.2879814 0.3340593\n[3,] 0.3779593 0.2879814 0.3340593\n[4,] 0.2562864 0.2743603 0.4693533\n[5,] 0.2562864 0.2743603 0.4693533\n[6,] 0.2562864 0.2743603 0.4693533",
    "crumbs": [
      "Documentation",
      "Families and links",
      "ologit"
    ]
  }
]