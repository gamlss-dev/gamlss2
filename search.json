[
  {
    "objectID": "man/Kumaraswamy.html",
    "href": "man/Kumaraswamy.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9982 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1075 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1262 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1294 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "href": "man/Kumaraswamy.html#kumaraswamy-distribution",
    "title": "gamlss2",
    "section": "",
    "text": "This function implements the two-parameter Kumaraswamy family for responses in (0, 1).\n\n\n\n## The Kumaraswamy family.\nKumaraswamy(a.link = shiftlog, b.link = shiftlog, ...)\n\n## The exp(x) + shift link specification.\nshiftlog(shift = 1)\n\n\n\n\n\n\n\na.link\n\n\nCharacter or function, the link function to be used for parameter a.\n\n\n\n\nb.link\n\n\nCharacter or function, the link function to be used for parameter b.\n\n\n\n\nshift\n\n\nNumeric, the shift parameter to be used for the link.\n\n\n\n\n…\n\n\nNot used.\n\n\n\n\n\n\nThe Kumaraswamy distribution is a continuous distribution defined on the interval (0, 1). The probability density function is\n\n\\(\\displaystyle f(y; a, b) = aby^{a - 1}(1 - y^a)^{b - 1}\\)\n\\(y \\in (0, 1)\\) is the response, \\(a\\) and \\(b\\) are non-negative parameters.\nThe shiftlog link function is given by:\n\n\\(\\displaystyle \\exp(x) + 1\\)\nThis is the default, since the mode of the distribution is only defined for \\(a \\geq 1\\), \\(b \\geq 1\\).\n\n\n\nThe family returns an object of class “gamlss2.family”.\nFunction shiftlog() returns a link specification object of class “link-glm”.\n\n\n\nKumaraswamy P (1980). “A Generalized Probability Density Function for Double-Bounded Random Processes.” Journal of Hydrology, 46(1), 79–88. doi:https://doi.org/10.1016/0022-1694(80)90036-0\n\n\n\ngamlss2.family, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## create family object with\n## different link specifications\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## simulate data\nset.seed(123)\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## true parameters\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,\n  \"b\" = 1\n)\n\n## sample response\nd$y &lt;- fam$r(1, par)\n\n## estimate model using the Kumaraswamy family\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9982 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1075 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1262 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1294 eps = 0.000002     \n\n## plot estimated effect\nplot(b)\n\n\n\n\n\n\n\n## plot residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "Kumaraswamy"
    ]
  },
  {
    "objectID": "man/quantiles.html",
    "href": "man/quantiles.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Reference",
      "quantiles"
    ]
  },
  {
    "objectID": "man/quantiles.html#quantiles-for-gamlss",
    "href": "man/quantiles.html#quantiles-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The function computes estimated quantiles and optionally produces a plot.\n\n\n\n## S3 method for class 'gamlss2'\nquantile(x, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),\n  variable = NULL, newdata = NULL,\n  plot = FALSE, data = TRUE,\n  n = 100L, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2”.\n\n\n\n\nprobs\n\n\nNumeric vector of probabilities with values in [0,1].\n\n\n\n\nvariable\n\n\nLogical or integer, should quantiles be plotted using the covariate data? Note that the variable option is only possible for single covariate models.\n\n\n\n\nnewdata\n\n\nData frame that should be used for computing the quantiles.\n\n\n\n\nplot\n\n\nLogical, should a plot be shown?\n\n\n\n\ndata\n\n\nLogical, should the raw data be added to the plot?\n\n\n\n\nn\n\n\nInteger, number of observations that should be used to compute an equidistant grid for the selected variable.\n\n\n\n\n…\n\n\nArguments such as col, legend = TRUE/FALSE. See the examples.\n\n\n\n\n\n\nThe function applies the predict method to determine the parameters of the response distribution. It then computes the quantiles as specified in the argument probs.\n\n\n\nA data frame of the estimated quantiles.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compute quantiles using \"newdata\"\nnd &lt;- film90[1:10, ]\nprint(quantile(b, newdata = nd))\n\n## plot sorted quantiles\nquantile(b, plot = TRUE)\n\n## quantile plot using covariate data\nquantile(b, plot = TRUE, variable = TRUE)\n\n## plot without raw data\nquantile(b, plot = TRUE, variable = TRUE, data = FALSE)",
    "crumbs": [
      "Reference",
      "quantiles"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html",
    "href": "man/gamlss2_control.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Reference",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/gamlss2_control.html#control-parameters",
    "href": "man/gamlss2_control.html#control-parameters",
    "title": "gamlss2",
    "section": "",
    "text": "Various parameters that control fitting of GAMLSS using gamlss2.\n\n\n\ngamlss2_control(optimizer = RS, trace = TRUE,\n  flush = TRUE, light = FALSE, expand = TRUE,\n  model = TRUE, x = TRUE, y = TRUE,\n  fixed = FALSE, ...)\n\n\n\n\n\n\n\noptimizer\n\n\nFunction, the optimizer function that should be used for fitting.\n\n\n\n\ntrace\n\n\nLogical, should information be printed while the algorithm is running?\n\n\n\n\nflush\n\n\nLogical, use flush.console for displaying the current output in the console.\n\n\n\n\nlight\n\n\nLogical, if set to light = TRUE, no model frame, response, model matrix and other design matrices will be part of the return value.\n\n\n\n\nexpand\n\n\nLogical, if fewer formulas are supplied than there are parameters of the distribution, should formulas with intercept only formulas be added?\n\n\n\n\nmodel\n\n\nLogical, should the model frame be included as component of the returned object.\n\n\n\n\nx\n\n\nLogical, indicating whether the model matrix should be included as component of the returned object.\n\n\n\n\ny\n\n\nLogical, should the response be included as component of the returned object.\n\n\n\n\nfixed\n\n\nLogical, a named vector of parameters that should be fixed during estimation. See the examples for gamlss2.\n\n\n\n\n…\n\n\nFurther control parameters to be part of the return value, e.g., used within optimizer function RS.\n\n\n\n\n\n\nThe control parameters in gamlss2_control can also be extended, e.g., if another optimization function is used, newly specified control parameters are automatically passed on to this function.\n\n\n\nA list with the arguments specified.\n\n\n\nRS, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model with different step length\n## control in the RS algorithm\nb1 &lt;- gamlss2(f, data = abdom, family = BCT, step = 1)\nb2 &lt;- gamlss2(f, data = abdom, family = BCT, step = 0.9)",
    "crumbs": [
      "Reference",
      "gamlss2_control"
    ]
  },
  {
    "objectID": "man/pb.html",
    "href": "man/pb.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26377.8229 eps = 0.390162     \nGAMLSS-RS iteration  2: Global Deviance = 26205.3586 eps = 0.006538     \nGAMLSS-RS iteration  3: Global Deviance = 26202.541 eps = 0.000107     \nGAMLSS-RS iteration  4: Global Deviance = 26202.1755 eps = 0.000013     \nGAMLSS-RS iteration  5: Global Deviance = 26202.0501 eps = 0.000004     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "pb"
    ]
  },
  {
    "objectID": "man/pb.html#p-splines-for-gamlss",
    "href": "man/pb.html#p-splines-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of P-splines using an efficient local maximum likelihood approach to automatically select the smoothing parameter. According to the inventors of P-splines, pb stands for \"penalized beta\" splines or \"Paul and Brian\".\n\n\n\npb(x, k = 20, ...)\n\n\n\n\n\n\n\nx\n\n\nThe variable that should be used for estimation.\n\n\n\n\nk\n\n\nThe dimension of the B-spline basis to represent the smooth term.\n\n\n\n\n…\n\n\nFurther arguments passed to function s.\n\n\n\n\n\n\nFunction pb() is an internal wrapper function that calls s to set up a smooth specification object that can be used for model fitting with gamlss2. Using pb(), an efficient local maximum likelihood approach is used to estimate the smoothing parameter. See the reference for details.\n\n\n\nThe function returns a smooth specification object of class “ps.smooth.spec”, see also smooth.construct.ps.smooth.spec.\n\n\n\nEilers PHC, Marx BD (1996). “Flexible Smoothing with B-Splines and Penalties.” Statistical Science, 11(2), 89–121. doi:10.1214/ss/1038425655\nRigby RA, Stasinopoulos DM (2014). “Automatic Smoothing Parameter Selection in GAMLSS with an Application to Centile Estimation.” Statistical Methods in Medical Research, 23(4), 318–332. doi:10.1177/0962280212473302\n\n\n\ngamlss2, smooth.construct.ps.smooth.spec\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load head circumference data\ndata(\"dbhh\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- head ~ pb(age) | pb(age) | pb(age) | pb(age)\n\n## estimate model\nb &lt;- gamlss2(f, data = dbhh, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 26377.8229 eps = 0.390162     \nGAMLSS-RS iteration  2: Global Deviance = 26205.3586 eps = 0.006538     \nGAMLSS-RS iteration  3: Global Deviance = 26202.541 eps = 0.000107     \nGAMLSS-RS iteration  4: Global Deviance = 26202.1755 eps = 0.000013     \nGAMLSS-RS iteration  5: Global Deviance = 26202.0501 eps = 0.000004     \n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(head ~ age, data = dbhh, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(dbhh$age, pq, type = \"l\",\n  lty = 1, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "pb"
    ]
  },
  {
    "objectID": "man/special_terms.html",
    "href": "man/special_terms.html",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## predict parameters of the GA distribution\npar &lt;- predict(b, newdata = nd)\n\n## compute median rent R estimate\nnd$fit &lt;- family(b)$q(0.5, par)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Reference",
      "special_terms"
    ]
  },
  {
    "objectID": "man/special_terms.html#special-model-terms-for-gamlss",
    "href": "man/special_terms.html#special-model-terms-for-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "The gamlss2 package provides infrastructure to include special model terms for the optimizer functions RS and CG, e.g., such as neural networks, trees and forests. The infrastructure assumes that such special model terms provide their own fitting and predict method.\n\n\n\n## Generic fitting method.\nspecial_fit(x, ...)\n\n## Generic predict method.\nspecial_predict(x, ...)\n\n## Extractor function for fitted special terms.\nspecials(object, model = NULL, terms = NULL, elements = NULL, ...)\n\n\n\n\n\n\n\nx\n\n\nA model term object as supplied in the formula in the gamlss2 call.\n\n\n\n\nobject\n\n\nA fitted gamlss2 object.\n\n\n\n\nmodel\n\n\nCharacter or integer, specifies the model for which fitted special terms should be extracted.\n\n\n\n\nterms\n\n\nCharacter or integer, specifies the special model terms that should be extracted.\n\n\n\n\nelements\n\n\nCharacter, specifies which elements of a fitted special term should be extracted. If elements = “names”, the corresponding element names are extracted.\n\n\n\n\n…\n\n\nArguments needed for the special_fit() function to facilitate the fitting of the model term, see the details. Similarly, for the special_predict() function, the … argument encompasses the objects for computing predictions for the model term.\n\n\n\n\n\n\nTo implement a new special term, the first step is to write a formula constructor function for the new model term. For example, consider the implementation below, which demonstrates how to create a neural network model term. Additionally, the name of the new model term constructor must be passed to the specials argument of the function fake_formula. Please note that in the provided example, no new special name is passed because “n” is already registered in fake_formula.\nAfterwards, a fitting and a predict method for the new special model term needs to be implemented. Please also refer to the example below, implementing these functions for a neural network model term.\nThe following describes the detailed arguments and return values.\nA method for special_fit() has the following arguments:\n\n\nx: The special model term object, containing all the data for fitting.\n\n\nz: The current working response/residual from the backfitting step.\n\n\nw: The current working weights from the backfitting step.\n\n\ny: The response vector/matrix, e.g., used to evaluate the log-likelihood.\n\n\neta: The current named list of predictors.\n\n\nj: Character, the parameter name for which the model term needs to be updated.\n\n\nfamily: The family object of the model, see gamlss2.family.\n\n\ncontrol: A named list of control arguments, see gamlss2_control.\n\n\nNote that for setting up a special model term only the first three arguments a mandatory, all other arguments are optional. The function must at least return a named list containing the “fitted.values” to work with RS and CG.\nA method for special_predict() has the following arguments:\n\n\nx: Depending on the return value of function special_fit(), the fitted model term object, see the examples.\n\n\ndata: The data for which predictions should be computed.\n\n\nse.fit: Logical, should standard errors of the predictions be computed.\n\n\nNote that function special_predict() should return a data frame with named colums “fit”, “lower” and “upper”, “lower” and “upper” are optional.\n\n\n\ngamlss2, RS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## example special term for neural networks,\n## the constructor function is used in the formula\n## when calling gamlss2()\nn &lt;- function(formula, ...)\n{\n  stopifnot(requireNamespace(\"nnet\"))\n\n  ## list for setting up the special model term\n  st &lt;- list()\n\n  ## list of control arguments\n  ctr &lt;- list(...)\n  if(is.null(ctr$size))\n    ctr$size &lt;- 50\n  if(is.null(ctr$maxit))\n    ctr$maxit &lt;- 1000\n  if(is.null(ctr$decay))\n    ctr$decay &lt;- 0.1\n  if(is.null(ctr$trace))\n    ctr$trace &lt;- FALSE\n  if(is.null(ctr$MaxNWts))\n    ctr$MaxNWts &lt;- 10000\n  if(is.null(ctr$scale))\n    ctr$scale &lt;- TRUE\n\n  ## put all information together\n  st$control &lt;- ctr\n  st$formula &lt;- formula\n  st$term &lt;- all.vars(formula)\n  st$label &lt;- paste0(\"n(\", paste0(gsub(\" \", \"\", as.character(formula)), collapse = \"\"), \")\")\n  st$data &lt;- model.frame(formula)\n\n  ## scale per default!\n  if(ctr$scale) {\n    sx &lt;- list()\n    for(j in colnames(st$data)) {\n      if(!is.factor(st$data[[j]])) {\n        sx[[j]] &lt;- range(st$data[[j]])\n        st$data[[j]] &lt;- (st$data[[j]] - sx[[j]][1]) / diff(sx[[j]])\n      }\n    }\n    st$scalex &lt;- sx\n  }\n\n  ## assign the \"special\" class and the new class \"n\"\n  class(st) &lt;- c(\"special\", \"n\")\n\n  return(st)\n}\n\n## set up the special \"n\" model term fitting function\nspecial_fit.n &lt;- function(x, z, w, control, ...)\n{\n  ## model formula needs to be updated\n  .fnns &lt;- update(x$formula, response_z ~ .)\n\n  ## assign current working response\n  x$data$response_z &lt;- z\n  x$data$weights_w &lt;- w\n\n  ## possible weights from last iteration\n  Wts &lt;- list(...)$transfer$Wts\n\n  ## estimate model\n  nnc &lt;- parse(text = paste0('nnet::nnet(formula = .fnns, data = x$data, weights = weights_w,',\n      'size = x$control$size, maxit = x$control$maxit, decay = x$control$decay,',\n      'trace = x$control$trace, MaxNWts = x$control$MaxNWts, linout = TRUE',\n      if(!is.null(Wts)) ', Wts = Wts)' else ')'))\n\n  rval &lt;- list(\"model\" = eval(nnc))\n\n  ## get the fitted.values\n  rval$fitted.values &lt;- predict(rval$model)\n\n  ## transferring the weights for the next backfitting iteration\n  ## note, \"transfer\" can be used to transfer anything from one\n  ## iteration to the next\n  rval$transfer &lt;- list(\"Wts\" = rval$model$wts)\n\n  ## center fitted values\n  rval$shift &lt;- mean(rval$fitted.values)\n  rval$fitted.values &lt;- rval$fitted.values - rval$shift\n\n  ## degrees of freedom\n  rval$edf &lt;- length(coef(rval$model))\n\n  ## possible scaling\n  rval$scalex &lt;- x$scalex\n\n  ## assign class for predict method\n  class(rval) &lt;- \"n.fitted\"\n\n  return(rval)\n}\n\n## finally, the predict method\nspecial_predict.n.fitted &lt;- function(x, data, se.fit = FALSE, ...)\n{\n  if(!is.null(x$scalex)) {\n    for(j in names(x$scalex)) {\n      data[[j]] &lt;- (data[[j]] - x$scalex[[j]][1]) / diff(x$scalex[[j]])\n    }\n  }\n  p &lt;- predict(x$model, newdata = data, type = \"raw\")\n  p &lt;- p - x$shift\n  if(se.fit)\n    p &lt;- data.frame(\"fit\" = p)\n  return(p)\n}\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ n(~x) | n(~x) | n(~x) | n(~x)\n\n## estimate model,\n## set the seed for reproducibility\n## note, data should be scaled!\nset.seed(123)\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## plot\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model Formula\nf &lt;- R ~ n(~Fl+A,size=10,decay=0.7) | n(~Fl+A,size=10,decay=0.7)\n\n## estimate model\nset.seed(456)\nb &lt;- gamlss2(f, data = rent, family = GA)\n\n## plot estimated effects\nplot(b, which = \"effects\", persp = FALSE)\n\n## diagnostics\nplot(b, which = \"resid\")\n\n## predict using new data\nn &lt;- 50\nnd &lt;- with(rent, expand.grid(\n  \"Fl\" = seq(min(Fl), max(Fl), length = n),\n  \"A\" = seq(min(A), max(A), length = n)\n))\n\n## predict parameters of the GA distribution\npar &lt;- predict(b, newdata = nd)\n\n## compute median rent R estimate\nnd$fit &lt;- family(b)$q(0.5, par)\n\n## visualize\nlibrary(\"lattice\")\n\np1 &lt;- wireframe(fit ~ Fl + A, data = nd,\n  screen = list(z = 50, x = -70, y = -10),\n  aspect = c(1, 0.9), drape = TRUE,\n  main = \"n(~Fl+A)\",\n  xlab = \"Floor\", ylab = \"YoC\",\n  zlab = \"Rent\")\n\np2 &lt;- levelplot(fit ~ Fl + A, data = nd,\n  contour = TRUE,\n  main = \"n(~Fl+A)\", xlab = \"Floor\", ylab = \"YoC\")\n\nprint(p1, split = c(1, 1, 2, 1), more = TRUE)\nprint(p2, split = c(2, 1, 2, 1), more = FALSE)\n\n## extract fitted special terms,\n## fitted NN for parameter mu\nspecials(b, model = \"mu\", elements = \"model\")\n\n## same for sigma\nspecials(b, model = \"sigma\", elements = \"model\")\n\n## return element names of fitted special term list\nspecials(b, model = \"sigma\", elements = \"names\")",
    "crumbs": [
      "Reference",
      "special_terms"
    ]
  },
  {
    "objectID": "man/modelstats.html",
    "href": "man/modelstats.html",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 406.0278 eps = 0.298340     \nGAMLSS-RS iteration  2: Global Deviance = 373.0395 eps = 0.081246     \nGAMLSS-RS iteration  3: Global Deviance = 363.9491 eps = 0.024368     \nGAMLSS-RS iteration  4: Global Deviance = 363.1967 eps = 0.002067     \nGAMLSS-RS iteration  5: Global Deviance = 363.1423 eps = 0.000149     \nGAMLSS-RS iteration  6: Global Deviance = 363.1339 eps = 0.000023     \nGAMLSS-RS iteration  7: Global Deviance = 363.1323 eps = 0.000004     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9892885 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 388.9107 12.88923\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 388.9107 12.88923\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 412.1972 12.88923\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Reference",
      "modelstats"
    ]
  },
  {
    "objectID": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "href": "man/modelstats.html#gaic-and-generalised-pseudo-r-squared-for-gamlss-models",
    "title": "gamlss2",
    "section": "",
    "text": "Functions to compute the GAIC and the generalised R-squared of Nagelkerke (1991) for a GAMLSS models.\n\n\n\n## Information criteria.\nGAIC(object, ...,\n  k = 2, corrected = FALSE)\n\n## R-squared.\nRsq(object, ...,\n  type = c(\"Cox Snell\", \"Cragg Uhler\", \"both\", \"simple\"),\n  newdata = NULL)\n\n\n\n\n\n\n\nobject\n\n\nA fitted model object\n\n\n\n\n…\n\n\nOptionally more fitted model objects.\n\n\n\n\nk\n\n\nNumeric, the penalty to be used. The default k = 2 corresponds to the classical AIC.\n\n\n\n\ncorrected\n\n\nLogical, whether the corrected AIC should be used? Note that it applies only when k = 2.\n\n\n\n\ntype\n\n\nwhich definition of R squared. Can be the “Cox Snell” or the Nagelkerke, “Cragg Uhler” or “both”, and “simple”, which computes the R-squared based on the median. In this case also newdata may be supplied.\n\n\n\n\nnewdata\n\n\nOnly for type = “simple” the R-squared can be evaluated using newdata.\n\n\n\n\n\n\nThe Rsq() function uses the definition for R-squared:\n\n\\(R^2=1- \\left(\\frac{L(0)}{L(\\hat{\\theta})}\\right)^{2/n}\\)\nwhere \\(L(0)\\) is the null model (only a constant is fitted to all parameters) and \\(L(\\hat{\\theta})\\) is the current fitted model. This definition sometimes is referred to as the Cox & Snell R-squared. The Nagelkerke /Cragg & Uhler’s definition divides the above with\n\n\\(1 - L(0)^{2/n}\\)\n\n\n\nNumeric vector or data frame, depending on the number of fitted model objects.\n\n\n\nNagelkerke NJD (1991). “A Note on a General Definition of the Coefficient of Determination.” Biometrika, 78(3), 691–692. doi:10.1093/biomet/78.3.691\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the aids data set\ndata(\"aids\", package = \"gamlss.data\")\n\n## estimate negative binomial count models\nb1 &lt;- gamlss2(y ~ x + qrt, data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 492.7033 eps = 0.148555     \nGAMLSS-RS iteration  2: Global Deviance = 492.6374 eps = 0.000133     \nGAMLSS-RS iteration  3: Global Deviance = 492.6373 eps = 0.000000     \n\nb2 &lt;- gamlss2(y ~ s(x) + s(qrt, bs = \"re\"), data = aids, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 406.0278 eps = 0.298340     \nGAMLSS-RS iteration  2: Global Deviance = 373.0395 eps = 0.081246     \nGAMLSS-RS iteration  3: Global Deviance = 363.9491 eps = 0.024368     \nGAMLSS-RS iteration  4: Global Deviance = 363.1967 eps = 0.002067     \nGAMLSS-RS iteration  5: Global Deviance = 363.1423 eps = 0.000149     \nGAMLSS-RS iteration  6: Global Deviance = 363.1339 eps = 0.000023     \nGAMLSS-RS iteration  7: Global Deviance = 363.1323 eps = 0.000004     \n\n## compare models\nRsq(b1)\n\n[1] 0.8095853\n\nRsq(b1, type = \"both\")\n\n$CoxSnell\n[1] 0.8095853\n\n$CraggUhler\n[1] 0.809588\n\nRsq(b1, b2)\n\n       b1        b2 \n0.8095853 0.9892885 \n\nGAIC(b1, b2)\n\n        AIC       df\nb2 388.9107 12.88923\nb1 504.6373  6.00000\n\nAIC(b1, b2)\n\n        AIC       df\nb2 388.9107 12.88923\nb1 504.6373  6.00000\n\nBIC(b1, b2)\n\n        AIC       df\nb2 412.1972 12.88923\nb1 515.4773  6.00000\n\n## plot estimated effects\nplot(b2)",
    "crumbs": [
      "Reference",
      "modelstats"
    ]
  },
  {
    "objectID": "man/Germany.html",
    "href": "man/Germany.html",
    "title": "gamlss2",
    "section": "",
    "text": "The map contains the counties of Germany. The data was originally taken from GADM (https://gadm.org/) and slightly simplified to reduce disk space.\n\n\n\ndata(\"storms\", package = \"gamlss2\")\n\n\n\nA class “sf” data frame containing 403 counties of Germany.\n\n\nid\n\n\nFactor, a county id.\n\n\ncounty\n\n\nCharacter, the county in Germany where the weather station is located.\n\n\nstate\n\n\nCharacter, the state in Germany where the weather station is located.\n\n\ngeometry\n\n\nThe polygon information.\n\n\n\n\n\nMap of Germany:\n\n\nData Source:\n\n\nGADM\n\n\nLicence:\n\n\nCC BY\n\n\nURL:\n\n\nhttps://gadm.org/\n\n\nCoordinate Reference System:\n\n\nLongitude/latitude and the WGS84 datum.\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load sf package for plotting\nlibrary(\"sf\")\n\n## load the data\ndata(\"Germany\", package = \"gamlss2\")\n\n## plot the map\nplot(st_geometry(Germany))",
    "crumbs": [
      "Reference",
      "Germany"
    ]
  },
  {
    "objectID": "man/Germany.html#map-of-germany",
    "href": "man/Germany.html#map-of-germany",
    "title": "gamlss2",
    "section": "",
    "text": "The map contains the counties of Germany. The data was originally taken from GADM (https://gadm.org/) and slightly simplified to reduce disk space.\n\n\n\ndata(\"storms\", package = \"gamlss2\")\n\n\n\nA class “sf” data frame containing 403 counties of Germany.\n\n\nid\n\n\nFactor, a county id.\n\n\ncounty\n\n\nCharacter, the county in Germany where the weather station is located.\n\n\nstate\n\n\nCharacter, the state in Germany where the weather station is located.\n\n\ngeometry\n\n\nThe polygon information.\n\n\n\n\n\nMap of Germany:\n\n\nData Source:\n\n\nGADM\n\n\nLicence:\n\n\nCC BY\n\n\nURL:\n\n\nhttps://gadm.org/\n\n\nCoordinate Reference System:\n\n\nLongitude/latitude and the WGS84 datum.\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load sf package for plotting\nlibrary(\"sf\")\n\n## load the data\ndata(\"Germany\", package = \"gamlss2\")\n\n## plot the map\nplot(st_geometry(Germany))",
    "crumbs": [
      "Reference",
      "Germany"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html",
    "href": "man/predict.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? (not implemented yet).\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3541 eps = 0.125497     \nGAMLSS-RS iteration  2: Global Deviance = 405.7146 eps = 0.004024     \nGAMLSS-RS iteration  3: Global Deviance = 405.6978 eps = 0.000041     \nGAMLSS-RS iteration  4: Global Deviance = 405.6976 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.03912 10.06300\n2 59.03607 18.51012\n3 96.34896 33.95078\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.03912 10.06300\n2 59.03607 18.51012\n3 96.34896 33.95078\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.06300 18.51012 33.95078 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.06300\n2 18.51012\n3 33.95078\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1    2.638039 -0.3291741\n2    2.638039  0.2802782\n3    2.638039  0.8868728\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3291741\n2  0.2802782\n3  0.8868728",
    "crumbs": [
      "Reference",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "href": "man/predict.gamlss2.html#extracting-fitted-or-predicted-parameters-or-terms-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) parameters, terms, etc.\n\n\n\n## S3 method for class 'gamlss2'\npredict(object, model = NULL, newdata = NULL,\n  type = c(\"parameter\", \"link\", \"response\", \"terms\"), terms = NULL,\n  se.fit = FALSE, drop = TRUE, ...)\n\n\n\n\n\n\n\nobject\n\n\nmodel object of class gamlss2.\n\n\n\n\nmodel\n\n\ncharacter. Which model part(s) should be predicted? Can be one or more of “mu”, “sigma”, etc. By default all model parts are included.\n\n\n\n\nnewdata\n\n\ndata.frame. Optionally, a new data frame in which to look for variables with which to predict. If omitted, the original observations are used.\n\n\n\n\ntype\n\n\ncharacter. Which type of prediction should be computed? Can be the full additive predictor(s) (“link”, before applying the link function(s)), the corresponding parameter (“parameter”, after applying the link function(s)), the individual terms of the additive predictor(s) (“terms”), or the corresponding mean of the response distribution (“response”).\n\n\n\n\nterms\n\n\ncharacter. Which of the terms in the additive predictor(s) should be included? By default all terms are included.\n\n\n\n\nse.fit\n\n\nlogical. Should standard errors for the predictions be included? (not implemented yet).\n\n\n\n\ndrop\n\n\nlogical. Should the predictions be simplified to a vector if possible (TRUE) or always returned as a data.frame (FALSE)?\n\n\n\n\n…\n\n\ncurrently only used for catching what as an alias for model.\n\n\n\n\n\n\nPredictions for gamlss2 model objects are obtained in the following steps: First, the original data is extracted or some newdata is set up. Second, all of the terms in the additive predictors of all model parameters (“mu”, “sigma”, …) are computed. Third, the full additive predictor(s) are obtained by adding up all individual terms. Fourth, the parameter(s) are obtained from the additive predictor(s) by applying the inverse link function(s). In a final step, the mean of the associated probability distribution can be computed.\nSee also prodist.gamlss2 for setting up a full distributions3 object from which moments, probabilities, quantiles, or random numbers can be obtained.\n\n\n\nIf drop = FALSE a data.frame. If drop = TRUE (the default), the data.frame might be simplified to a numeric vector, if possible.\n\n\n\npredict, prodist.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\ndata(\"cars\", package = \"datasets\")\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3541 eps = 0.125497     \nGAMLSS-RS iteration  2: Global Deviance = 405.7146 eps = 0.004024     \nGAMLSS-RS iteration  3: Global Deviance = 405.6978 eps = 0.000041     \nGAMLSS-RS iteration  4: Global Deviance = 405.6976 eps = 0.000000     \n\n## new data for predictions\nnd &lt;- data.frame(speed = c(10, 20, 30))\n\n## default: additive predictors (on link scale) for all model parameters\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.03912 10.06300\n2 59.03607 18.51012\n3 96.34896 33.95078\n\n## mean of the response distribution\npredict(m, newdata = nd, type = \"response\")\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\n## model parameter(s)\npredict(m, newdata = nd)\n\n        mu    sigma\n1 23.03912 10.06300\n2 59.03607 18.51012\n3 96.34896 33.95078\n\npredict(m, newdata = nd, model = \"sigma\")\n\n       1        2        3 \n10.06300 18.51012 33.95078 \n\npredict(m, newdata = nd, model = \"sigma\", drop = FALSE)\n\n     sigma\n1 10.06300\n2 18.51012\n3 33.95078\n\n## individual terms in additive predictor(s)\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\")\n\n  (Intercept)   s(speed)\n1    2.638039 -0.3291741\n2    2.638039  0.2802782\n3    2.638039  0.8868728\n\npredict(m, newdata = nd, type = \"terms\", model = \"sigma\", terms = \"s(speed)\")\n\n    s(speed)\n1 -0.3291741\n2  0.2802782\n3  0.8868728",
    "crumbs": [
      "Reference",
      "predict.gamlss2"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html",
    "href": "man/HarzTraffic.html",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de, https://www.bast.de/DE/Verkehrstechnik/Fachthemen/v2-verkehrszaehlung/Verkehrszaehlung.html\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.082 eps = 0.148402     \nGAMLSS-RS iteration  2: Global Deviance = 10151.144 eps = 0.001174     \nGAMLSS-RS iteration  3: Global Deviance = 10151.1409 eps = 0.000000     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\npar &lt;- predict(m, newdata = nd)\n\n## corresponding quantiles\np &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(m)$q(q, par))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "href": "man/HarzTraffic.html#traffic-counts-at-sonnenberg-in-the-harz-region",
    "title": "gamlss2",
    "section": "",
    "text": "This dataset contains daily traffic counts close to Sonnenberg, located in the Harz region in Germany. It covers a period of nearly three years, from 2021-01-01 to 2023-11-30.\n\n\n\ndata(\"HarzTraffic\", package = \"gamlss2\")\n\n\n\nA data frame containing 1057 observations on 16 variables.\n\n\ndate\n\n\nDate, the date of the record.\n\n\nyday\n\n\nInteger, the day of the year.\n\n\nbikes\n\n\nInteger, the number of motorcycles on that day.\n\n\ncars\n\n\nInteger, the number of cars on that day.\n\n\ntrucks\n\n\nInteger, the number of trucks on that day.\n\n\nothers\n\n\nInteger, the number of other vehicles on that day.\n\n\ntempmin\n\n\nNumeric, minimum temperature in \\(^{\\circ}C\\).\n\n\ntempmax\n\n\nNumeric, maximum temperature in \\(^{\\circ}C\\).\n\n\ntemp\n\n\nNumeric, mean temperature in \\(^{\\circ}C\\).\n\n\nhumidity\n\n\nNumeric, mean relative humidity in percent.\n\n\ntempdew\n\n\nNumeric, average dewpoint temperature in \\(^{\\circ}C\\).\n\n\ncloudiness\n\n\nNumeric, average cloud cover in percent.\n\n\nrain\n\n\nNumeric, amount of precipitation in mm (snow and rain).\n\n\nsunshine\n\n\nNumeric, sunshine duration in minutes.\n\n\nwind\n\n\nNumeric, mean wind speed in m/s.\n\n\nwindmax\n\n\nNumeric, maximum wind speed in m/s.\n\n\n\n\n\nWeather Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nStation:\n\n\nWernigerode (5490; Sachsen-Anhalt)\n\n\nPosition:\n\n\n10.7686/51.8454/233 (lon, lat, alt, EPSG 4326)\n\n\nTraffic Data:\n\n\nData Source:\n\n\nBundesanstalt für Strassenwesen (BASt)\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://www.bast.de, https://www.bast.de/DE/Verkehrstechnik/Fachthemen/v2-verkehrszaehlung/Verkehrszaehlung.html\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## seasonal variation of motorcycle counts at Sonnenberg/Harz\ndata(\"HarzTraffic\", package = \"gamlss2\")\nplot(bikes ~ yday, data = HarzTraffic)\n\n\n\n\n\n\n\n## count distribution\nbarplot(table(HarzTraffic$bikes))\n\n\n\n\n\n\n\n## negative binomial seasonal model using cyclic splines\nm &lt;- gamlss2(bikes ~ s(yday, bs = \"cc\") | s(yday, bs = \"cc\"),\n  data = HarzTraffic, family = NBI)\n\nGAMLSS-RS iteration  1: Global Deviance = 10163.082 eps = 0.148402     \nGAMLSS-RS iteration  2: Global Deviance = 10151.144 eps = 0.001174     \nGAMLSS-RS iteration  3: Global Deviance = 10151.1409 eps = 0.000000     \n\n## visualize effects\nplot(m)\n\n\n\n\n\n\n\n## residual diagnostics\nplot(m, which = \"resid\")\n\n\n\n\n\n\n\n## fitted parameters for each day of the year\nnd &lt;- data.frame(yday = 1:365)\npar &lt;- predict(m, newdata = nd)\n\n## corresponding quantiles\np &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(m)$q(q, par))\n\n## visualization\nplot(bikes ~ yday, data = HarzTraffic, pch = 19, col = gray(0.1, alpha = 0.3))\nmatplot(nd$yday, p, type = \"l\", lty = c(2, 1, 2), lwd = 2, col = 4, add = TRUE)",
    "crumbs": [
      "Reference",
      "HarzTraffic"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html",
    "href": "man/gamlss2.family.html",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nThe following lists the minimum requirements on a gamlss2 family object to be used with gamlss2:\n\n\nThe family object is expected to return a list of class “gamlss2.family”.\n\n\nThe object must contain the family name as a character string.\n\n\nThe object must contain the names of the parameters as a character string, as well as the corresponding link functions as character string.\n\n\nThe family object must contain a $d() function to evaluate the (log-)density.\n\n\nFurthermore, it is assumed that the density function in a family object has the following arguments:\nd(y, par, log = FALSE, …)\nwhere argument y is the response (possibly a matrix) and par is a named list holding the evaluated parameters of the distribution, e.g., using a normal distribution par has two elements, one for the mean par$mu and one for the standard deviation par$sigma. The dots argument is for passing special internally used objects, depending on the type of model this feature is usually not needed.\nOptionally, the family object holds derivative functions evaluating derivatives of the log-likelihood w.r.t. the predictors (or expectations of derivatives). For each parameter, these functions must have the following arguments:\nfunction(y, par, …)\nfor computing the first derivative of the log-likelihood w.r.t. a predictor and\nfunction(y, par, …)\nfor computing the negative second derivatives. Within the family object these functions are organized in a named list, see the examples below. If these functions are not specified, all derivatives will be approximated numerically. Note that also cross derivatives can be implemented, e.g., when using the CG algorithm for fitting a GAMLSS.\nIn addition, for the cumulative distribution function (p(y, par, …)), for the quantile function (q(y, par, …)) or for creating random numbers (r(n, par, …)) the same structure is assumed.\nUsing function gamlss2 the family objects may also specify the optimizer()er function that should be used with this family.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"d\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"p\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"r\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"q\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $p() and $q() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"p\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"q\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $p() and $q() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "href": "man/gamlss2.family.html#family-objects-in-gamlss2",
    "title": "gamlss2",
    "section": "",
    "text": "Family objects within the package gamlss2 are used to specify the information required to use a model fitting function. This includes details such as parameter names, corresponding link functions, the density function, log-likelihood function and derivatives of the log-likelihood with respect to the predictors. In addition, family objects are used in the calculation of post-modeling statistics, such as residual diagnostics and random number generation. An overview can be found in the accompanying details and examples.\n\n\n\nThe following lists the minimum requirements on a gamlss2 family object to be used with gamlss2:\n\n\nThe family object is expected to return a list of class “gamlss2.family”.\n\n\nThe object must contain the family name as a character string.\n\n\nThe object must contain the names of the parameters as a character string, as well as the corresponding link functions as character string.\n\n\nThe family object must contain a $d() function to evaluate the (log-)density.\n\n\nFurthermore, it is assumed that the density function in a family object has the following arguments:\nd(y, par, log = FALSE, …)\nwhere argument y is the response (possibly a matrix) and par is a named list holding the evaluated parameters of the distribution, e.g., using a normal distribution par has two elements, one for the mean par$mu and one for the standard deviation par$sigma. The dots argument is for passing special internally used objects, depending on the type of model this feature is usually not needed.\nOptionally, the family object holds derivative functions evaluating derivatives of the log-likelihood w.r.t. the predictors (or expectations of derivatives). For each parameter, these functions must have the following arguments:\nfunction(y, par, …)\nfor computing the first derivative of the log-likelihood w.r.t. a predictor and\nfunction(y, par, …)\nfor computing the negative second derivatives. Within the family object these functions are organized in a named list, see the examples below. If these functions are not specified, all derivatives will be approximated numerically. Note that also cross derivatives can be implemented, e.g., when using the CG algorithm for fitting a GAMLSS.\nIn addition, for the cumulative distribution function (p(y, par, …)), for the quantile function (q(y, par, …)) or for creating random numbers (r(n, par, …)) the same structure is assumed.\nUsing function gamlss2 the family objects may also specify the optimizer()er function that should be used with this family.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      },\n      \"mu.sigma\" = function(y, par, ...) {\n        rep(0, length(y))\n      }\n    ),\n    \"loglik\" = function(y, par, ...) {\n      sum(dnorm(y, par$mu, par$sigma, log = TRUE))\n    },\n    \"mu\" = function(par, ...) {\n      par$mu\n    },\n    \"d\" = function(y, par, log = FALSE) {\n      dnorm(y, mean = par$mu, sd = par$sigma, log = log)\n    },\n    \"p\" = function(y, par, ...) {\n      pnorm(y, mean = par$mu, sd = par$sigma, ...)\n    },\n    \"r\" = function(n, par) {\n      rnorm(n, mean = par$mu, sd = par$sigma)\n    },\n    \"q\" = function(p, par) {\n      qnorm(p, mean = par$mu, sd = par$sigma)\n    },\n    \"initialize\" = list(\n      \"mu\"    = function(y, ...) { (y + mean(y)) / 2 },\n      \"sigma\" = function(y, ...) { rep(sd(y), length(y)) }\n    ),\n    \"mean\"      = function(par) par$mu,\n    \"variance\"  = function(par) par$sigma^2,\n    \"valid.response\" = function(x) {\n      if(is.factor(x) | is.character(x))\n        stop(\"the response should be numeric!\")\n      return(TRUE)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = Normal)\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n## another example using only the density\n## function, all derivatives are approximated\n## in this case; for residual diagnostics,\n## the $p() and $q() function is needed, too.\nGamma &lt;- function(...) {\n  fam &lt;- list(\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"log\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      dgamma(y, shape = shape, scale = scale, log = log)\n    },\n    \"p\" = function(y, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n      pgamma(y, shape = shape, scale = scale,\n        lower.tail = lower.tail, log.p = log.p)\n    },\n    \"q\" = function(p, par, lower.tail = TRUE, log.p = FALSE) {\n      shape &lt;- par$sigma\n      scale &lt;- par$mu/par$sigma\n       qgamma(p, shape = shape, scale = scale,\n         lower.tail = lower.tail, log.p = log.p)\n    }\n  )\n\n  class(fam) &lt;- \"gamlss2.family\"\n\n  return(fam)\n}\n\n## example using the Munich rent data\ndata(\"rent\", package = \"gamlss.data\")\n\n## model formula\nf &lt;- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\") |\n  ti(Fl) + ti(A) + ti(Fl, A, bs = \"ps\")\n\n## estimate model\nb &lt;- gamlss2(f, data = rent, family = Gamma)\n\n## visualize estimated effects\nplot(b, which = \"effects\")\n\n## diagnostics, needs the $p() and $q() function!\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "gamlss2.family"
    ]
  },
  {
    "objectID": "man/fake_formula.html",
    "href": "man/fake_formula.html",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Reference",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "href": "man/fake_formula.html#extended-processing-of-fake-formulas",
    "title": "gamlss2",
    "section": "",
    "text": "Create a \"fake\" formula from a formula, a Formula, or a list of formulas. The function extracts all necessary variables (transformation of variables), to build a model.frame. The function also extracts all special model terms within the formulas, the information can be used to setup any special model term specification list.\n\n\n\nfake_formula(formula, specials = NULL,\n  nospecials = FALSE, onlyspecials = FALSE)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a list of formulas.\n\n\n\n\nspecials\n\n\nCharacter, vector of names of special functions in the formula, see terms.formula.\n\n\n\n\nnospecials\n\n\nLogical, should variables of special model terms be part of the \"fake formula\"?\n\n\n\n\nonlyspecials\n\n\nLogical, should only the special model terms be returned?\n\n\n\n\n\n\nDepending on the input formula, the function returns a formula or Formula. If onlyspecials = TRUE a vector or list of special model term names is returned.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x2 + log(x3)\n\n## including special model terms\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4)\nff &lt;- fake_formula(f)\nprint(ff)\n\n~x1 + x3 + x2 + log(x3) + x4\n\n## multiple parts on the right-hand side\nf &lt;- y ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + sqrt(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5)\n\n## collapse all formula parts\nprint(formula(ff, collapse = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + (x2 + sqrt(x5))\n\nprint(formula(ff, collapse = TRUE, update = TRUE))\n\ny ~ x1 + x3 + x2 + log(x3) + x4 + sqrt(x5)\n\n## list of formulas\nf &lt;- list(\n  y ~ x1 + s(x2) + x3 + te(log(x3), x4),\n    ~ x2 + sqrt(x5),\n    ~ z2 + x1 + exp(x3)\n)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny ~ x1 + x3 + x2 + log(x3) + x4 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract separate parts on the right-hand side\nformula(ff, rhs = 1)\n\ny ~ x1 + x3 + x2 + log(x3) + x4\n\nformula(ff, rhs = 2)\n\ny ~ x2 + sqrt(x5)\n\nformula(ff, rhs = 3)\n\ny ~ z2 + x1 + exp(x3)\n\n## formula with multiple responses and multiple parts\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nff &lt;- fake_formula(f)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 + x2 + log(x3) + x4 | x2 + x5\n\n## list of formulas with multiple responses\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2 ~ x2 + sqrt(x5),\n  y3 ~ z2 + x1 + exp(x3) + s(x10)\n)\nff &lt;- fake_formula(f)\n\n## extract only without special terms\nff &lt;- fake_formula(f, nospecials = TRUE)\nprint(ff)\n\ny1 | y2 | y3 ~ x1 + x3 | x2 + sqrt(x5) | z2 + x1 + exp(x3)\n\n## extract only special terms\nff &lt;- fake_formula(f, onlyspecials = TRUE)\nprint(ff)\n\n[[1]]\n[1] \"s(x2)\"          \"te(log(x3),x4)\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"s(x10)\"",
    "crumbs": [
      "Reference",
      "fake_formula"
    ]
  },
  {
    "objectID": "man/find_family.html",
    "href": "man/find_family.html",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe reponse vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\n…\n\n\nFurther arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family().\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)",
    "crumbs": [
      "Reference",
      "find_family"
    ]
  },
  {
    "objectID": "man/find_family.html#find-and-fit-gamlss-families",
    "href": "man/find_family.html#find-and-fit-gamlss-families",
    "title": "gamlss2",
    "section": "",
    "text": "These functions provide useful infrastructures for finding suitable GAMLSS families for a response variable.\n\n\n\n## List of available families from gamlss.dist package.\navailable_families(type = c(\"continuous\", \"discrete\"), families = NULL)\n\n## Find suitable response distribution.\nfind_family(y, families = NULL, k = 2, verbose = TRUE, ...)\n\n## Fit distribution parameters.\nfit_family(y, family = NO, plot = TRUE, ...)\n\n\n\n\n\n\n\ntype\n\n\nCharacter, is the reponse continuous or discrete?\n\n\n\n\nfamilies\n\n\nCharacter, the names of the family objects of the gamlss.dist package that should be returned.\n\n\n\n\ny\n\n\nThe reponse vector or matrix.\n\n\n\n\nk\n\n\nNumeric, the penalty factor that should be used for the GAIC.\n\n\n\n\nverbose\n\n\nLogical, should runtime information be printed?\n\n\n\n\nfamily\n\n\nA famnily object that should be used for estimation, see also gamlss2.family.\n\n\n\n\nplot\n\n\nLogical, should a plot of the fitted density be provided?\n\n\n\n\n…\n\n\nFurther arguments to be passed to gamlss2 when using find_family(), or arguments legend = TRUE/FALSE, pos = “topright” (see also function legend), main, xlab and ylab when argument plot = TRUE using function fit_family().\n\n\n\n\n\n\nThe function find_family() employs gamlss2 to estimate intercept-only models for each specified family object in the families argument. Note that model estimation occurs within a try block with warnings suppressed. Additionally, the function calculates the GAIC for each family whenever feasible and returns the sorted values in descending order.\nFunction fit_family() fits a single intercept-only model using the specified family and creates a plot of the fitted density.\n\n\n\nFunction find_family() returns a vector of GAIC values for the different fitted families. Function fit_family() returns the fitted intercept-only model.\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## find a suitable response to the response\nic &lt;- find_family(rent$R)\nprint(ic)\n\n## fit parameters using the BCCG family\nfit_family(rent$R, family = BCCG)\n\n## count data\ndata(\"polio\", package = \"gamlss.data\")\n\n## search best count model\nic &lt;- find_family(polio, k = 0,\n  families = available_families(type = \"discrete\"))\nprint(ic)\n\n## fit parameters using the ZASICHEL family\nfit_family(polio, family = ZASICHEL)",
    "crumbs": [
      "Reference",
      "find_family"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\", \"https://cloud.R-project.org\"))\n\n\n\n\nThe primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?family.gamlss2.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The development version of gamlss2 can be installed via\n\ninstall.packages(\"gamlss2\",\n  repos = c(\"https://gamlss-dev.R-universe.dev\", \"https://cloud.R-project.org\"))"
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "gamlss2: Infrastructure for Flexible Distributional Regression",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the GAMLSS modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more flexible infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\nThe main model function is gamlss2().\nThe default optimizer functions is RS(). Optimizer functions can be exchanged.\nMost important methods: summary(), plot(), predict().\nEasy development of new family objects, see ?family.gamlss2.\nUser-specific “special” terms are possible, see ?special_terms.\n\nFor examples, please visit the manual pages.\n\nhelp(package = \"gamlss2\")"
  },
  {
    "objectID": "vignettes/random.html",
    "href": "vignettes/random.html",
    "title": "Random Effects",
    "section": "",
    "text": "Describe how to incorporate random effects in gamlss2\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "Random Effects"
    ]
  },
  {
    "objectID": "vignettes/topmodels.html",
    "href": "vignettes/topmodels.html",
    "title": "Top Models",
    "section": "",
    "text": "Introduction on how to use the topmodels package with gamlss2.\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "Top Models"
    ]
  },
  {
    "objectID": "vignettes/gamlss2.html",
    "href": "vignettes/gamlss2.html",
    "title": "First Steps",
    "section": "",
    "text": "The package is designed to follow the workflow of well-established model fitting functions like lm() or glm(), i.e., the step of estimating full distributional regression models is actually not very difficult.\nTo illustrate the workflow using gamlss2, we analyze the HarzTraffic data, where we model the number of motorcycles (response bikes) at Sonnenberg in the Harz region of Germany. The data can be loaded with\n\ndata(\"HarzTraffic\")\nhead(HarzTraffic)\n\n        date yday bikes cars trucks others tempmin tempmax  temp humidity\n1 2021-01-01    0     2 3135     25      1     0.2     2.6  1.32       85\n2 2021-01-02    1     7 6593     32     10     1.6     4.0  2.63       72\n3 2021-01-03    2     0 3367     30      2    -0.4     1.2  0.19       94\n4 2021-01-04    3     0 2186     75      0    -0.6    -0.1 -0.37       97\n5 2021-01-05    4     3 2071     68      0    -0.6     0.5 -0.21       98\n6 2021-01-06    5     1 2022     97      0    -0.2     0.5  0.17       93\n  tempdew cloudiness rain sunshine wind windmax\n1   -0.93         99  1.2       50 1.38     3.7\n2   -1.99        100  0.0       13 1.35     2.4\n3   -0.65         98 13.5        0 1.74     2.8\n4   -0.78         99  3.8        0 1.39     2.1\n5   -0.46         98  5.3        0 1.42     2.1\n6   -0.84         97  4.5        0 3.02     4.6\n\n\nThe data consists of seasonal time information (variable yday) along with a number of environmental variables (e.g. mean daily temperature). As a first model, we estimate a linear regression model with normal errors (which is the default)\n\nb &lt;- gamlss2(bikes ~ temp + rain + sunshine + wind, data = HarzTraffic)\n\nGAMLSS-RS iteration  1: Global Deviance = 14325.7146 eps = 0.046095     \nGAMLSS-RS iteration  2: Global Deviance = 14325.7146 eps = 0.000000     \n\nsummary(b)\n\nCall:\ngamlss2(formula = bikes ~ temp + rain + sunshine + wind, data = HarzTraffic)\n---\nFamily: NO \nLink function: mu = identity, sigma = log\n*--------\nParameter: mu \n---\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -15.33601   19.67683  -0.779   0.4359    \ntemp         17.68501    1.01429  17.436  &lt; 2e-16 ***\nrain         -3.76399    1.74873  -2.152   0.0316 *  \nsunshine      0.36452    0.02995  12.172  &lt; 2e-16 ***\nwind        -25.26905    4.38768  -5.759 1.11e-08 ***\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  5.35765    0.02175   246.3   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n*--------\nn = 1057 df =  6 res.df =  1051\nDeviance = 14325.7146 Null Dev. Red. = 4.61%\nAIC = 14337.7146 elapsed =  0.02sec\n\n\nNote that the summary output is very similar to lm() and glm() with the main difference being that summary outputs are provided for all parameters of the distribution. In this case, the model is estimated using the NO family of the gamlss.dist package, a two-parameter distribution with parameters mu and sigma.\n\nResidual Diagnostics\nSince we estimated a simple linear model with Gaussian errors up to now, we are assuming that the distribution of the response variable, the number of motorcycles (bikes), follows a normal distribution with constant variance. However, this assumption may not always hold true, especially when the response variable is count data, which often exhibits overdispersion or non-constant variance.\nTo assess whether the normal distribution with constant variance is appropriate, we can start by examining diagnostic plots.\n\nplot(b)\n\n\n\n\n\n\n\n\nThese plots help us visually inspect the residuals for any deviations from the assumptions of normality and constant variance.\n\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "First Steps"
    ]
  },
  {
    "objectID": "NEWS.html",
    "href": "NEWS.html",
    "title": "gamlss2 0.1-0",
    "section": "",
    "text": "gamlss2 0.1-0\n\nFirst version of ‘gamlss2’ providing a fresh reimplementaton of the classic ‘gamlss’ package while being more modular and facilitating the creation of advanced terms and models.",
    "crumbs": [
      "News"
    ]
  },
  {
    "objectID": "vignettes/families.html",
    "href": "vignettes/families.html",
    "title": "Family Objects",
    "section": "",
    "text": "Note that all family objects of the gamlss.dist package can be used for modeling. However, for users wanting to specify their own (new) distribution model, this document provides a guide on how to define custom family objects within the gamlss2 framework.\nFamily objects in the gamlss2 package play an essential role in defining the models used for fitting data to distributions. These objects encapsulate the necessary details about the distribution and the parameters, such as:\n\nThe names of the parameters.\nThe link functions that map the parameters to the predictor.\nFunctions for the density, log-likelihood, and their derivatives.\n\nThis document provides an overview of how to construct and use family objects within gamlss2. By the end, you should have a good understanding of how to implement a custom family for use in statistical models.\n\nDefining Family Objects\nA family object in gamlss2 is a list that must meet the following minimum criteria:\n\nFamily Name: The object must contain the family name as a character string.\nParameters: The object must list the parameters of the distribution (e.g., \"mu\" and \"sigma\" for a normal distribution).\nLink Functions: It must specify the link functions associated with each parameter.\nDensity Function: A d() function must be provided to evaluate the (log-)density of the distribution.\n\nOptionally, a family object can include functions to calculate the log-likelihood, random number generation, cumulative distribution function (CDF), and quantile function.\nHere’s an example of a minimal family object for the normal distribution.\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, par$mu, par$sigma, log = log)\n    }\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIn this example, we define a normal distribution with two parameters: \"mu\" (mean) and \"sigma\" (standard deviation). The link function for \"mu\" is the identity, and for \"sigma\", it is the log function. The density function uses the standard dnorm() function from to calculate the normal density.\n\n\nDensity Function\nThe density function must accept the following arguments:\n\nd(y, par, log = FALSE, ...)\n\n\ny: The response variable.\npar: A named list of parameters (e.g., \"mu\", \"sigma\" for the normal distribution).\nlog: A logical value indicating whether to return the log-density.\n\n\n\nOptional Derivatives\nFamily objects can optionally include functions to compute the first and second derivatives of the log-likelihood with respect to the predictors (or its expectations). These derivatives are used for optimization during model fitting.\nThe derivative functions follow the form:\n\nfunction(y, par, ...)\n\nThe derivate functions of first order must be provided as a named list, one list element for each parameter of the distribution, and is named \"score\". The second order derivative list is named \"hess\". Note that these functions must return the derivative w.r.t. predictor and the \"hess\" functions must return the negative (expected) second derivatives\nAn example of setting up first and second order derivatives for the normal is provided in the following code:\n\nNormal &lt;- function(...) {\n  fam &lt;- list(\n    \"family\" = \"Normal\",\n    \"names\" = c(\"mu\", \"sigma\"),\n    \"links\" = c(\"mu\" = \"identity\", \"sigma\" = \"log\"),\n    \"d\" = function(y, par, log = FALSE, ...) {\n      dnorm(y, par$mu, par$sigma, log = log)\n    },\n    \"score\" = list(\n      \"mu\" = function(y, par, ...) {\n        (y - par$mu) / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        -1 + (y - par$mu)^2 / (par$sigma^2)\n      }\n    ),\n    \"hess\" = list(\n      \"mu\" = function(y, par, ...) {\n        1 / (par$sigma^2)\n      },\n      \"sigma\" = function(y, par, ...) {\n        rep(2, length(y))\n      }\n    )\n  )\n  class(fam) &lt;- \"gamlss2.family\"\n  return(fam)\n}\n\nIf no derivatives are provided, numerical approximations will be used by the package.\n\n\nAdditional Functions\nFamily objects can also include other functions such as:\n\nCumulative distribution function (p()).\nQuantile function (q()).\nRandom number generation (r()).\n\nThese functions should adhere to the same structure as the density function, taking the response (y), parameters (par), and other relevant arguments.\n\n\nFlexible Links\nNote that the example above used static link functions to define the family object. However, users can easily create families with flexible link functions as well. A helpful example of how to implement such flexibility can be found in the Kumaraswamy distribution implementation, which provides a clear template for setting up families with customizable link functions.\nThe Kumaraswamy distribution is a continuous distribution defined on the interval \\((0, 1)\\). It is similar to the Beta distribution but has simpler forms for its cumulative distribution and inverse cumulative distribution functions, making it more computationally efficient for certain applications.\nThe probability density function (PDF) of the Kumaraswamy distribution is:\n\\[\nf(y; a, b) = aby^{a-1}(1 - y^a)^{b-1}\n\\]\nwhere \\(y \\in (0, 1)\\) is the response, and \\(a\\) and \\(b\\) are non-negative parameters that determine the shape of the distribution. The complete implementation, including flexible link functions is provided in the Kumaraswamy() family.\nIn the following example, we will create the family object for the Kumaraswamy distribution using the Kumaraswamy() function and estimate a model using this distribution.\n\nExample: Modeling with the Kumaraswamy Distribution\nIn this example, we will:\n\nDefine the Kumaraswamy family object.\nSimulate data based on this distribution.\nEstimate the model and plot the results.\n\n\n## Define the Kumaraswamy family object with specific link functions.\nfam &lt;- Kumaraswamy(a.link = shiftlog, b.link = \"log\")\n\n## Set seed for reproducibility.\nset.seed(123)\n\n## Simulate data for 1000 observations.\nn &lt;- 1000\nd &lt;- data.frame(\"x\" = runif(n, -pi, pi))\n\n## Specify the true parameters.\npar &lt;- data.frame(\n  \"a\" = exp(1.2 + sin(d$x)) + 1,  # Parameter 'a' depends on 'x'\n  \"b\" = 1  # Parameter 'b' is constant\n)\n\n## Sample response values using the family object.\nd$y &lt;- fam$r(1, par)\n\n## Estimate a model using the Kumaraswamy family.\nb &lt;- gamlss2(y ~ s(x), data = d, family = fam)\n\nGAMLSS-RS iteration  1: Global Deviance = -1503.9982 eps = 0.674665     \nGAMLSS-RS iteration  2: Global Deviance = -1504.1075 eps = 0.000072     \nGAMLSS-RS iteration  3: Global Deviance = -1504.1262 eps = 0.000012     \nGAMLSS-RS iteration  4: Global Deviance = -1504.1294 eps = 0.000002     \n\n## Plot the estimated effect.\nplot(b)\n\n\n\n\n\n\n\n## Plot residual diagnostics.\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n\nIn this example, we simulated a dataset where the parameter a of the Kumaraswamy distribution varies with x following a sinusoidal pattern. We then used the gamlss2() function to fit a smooth model that estimates this relationship. The effect of x on y is plotted, followed by a diagnostic plot to assess residuals.\nThe Kumaraswamy() family in gamlss2 is flexible, allowing the user to specify different link functions for its parameters, such as the default shiftlog link function for parameter a, which ensures non-negative values.\n\n\n\nConclusion\nFamily objects in the gamlss2 package are a fundamental component for defining flexible, distribution-based regression models, and beyond. By encapsulating the necessary elements, such as parameters, link functions, and density functions, they provide a powerful framework for customizing models to fit specific data. The flexibility to define custom families, as demonstrated with the Kumaraswamy() distribution, enables users to extend the package beyond its default families, making it adaptable to a wide range of modeling scenarios. Furthermore, the ability to define both static and dynamic link functions enhances the versatility of gamlss2 for distributional regression, empowering users to tailor models to their unique data and research needs.\n\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "Family Objects"
    ]
  },
  {
    "objectID": "vignettes/selection.html",
    "href": "vignettes/selection.html",
    "title": "Variable and Model Selection",
    "section": "",
    "text": "Find the best fitting distribution.\nFind relevant variables.\n\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "Variable and Model Selection"
    ]
  },
  {
    "objectID": "vignettes/spatial.html",
    "href": "vignettes/spatial.html",
    "title": "Spatial Effects",
    "section": "",
    "text": "Spatial data analysis is important in many fields such as environmental science, epidemiology, and climatology, where observations are collected across different geographical locations. A key challenge in spatial modeling is accounting for the dependence structure among nearby regions, which often display correlated patterns in outcomes.\nIn generalized additive models for location, scale, and shape (GAMLSS), spatial effects can be incorporated in various ways, such as through Markov random fields (MRFs). MRFs handle spatial correlation by applying penalties that reflect the neighborhood structure of the spatial data. This vignette is divided into two parts: the first part demonstrates how to estimate discrete spatial effects using MRFs with the gamlss2 package, while the second part provides examples of modeling spatial effects with smooth functions like thin-plate splines or tensor product splines.\n\nExample: Modeling Severe Storm Counts in Germany\nIn this example, we analyze severe storm counts recorded at various weather stations across Germany over multiple years. Our goal is to model these storm counts while accounting for the spatial dependence between stations. To achieve this, we associate each weather station with its respective county in Germany, enabling us to incorporate the geographical structure into the model.\n\n## load the Germany severe storm data\ndata(\"storms\", package = \"gamlss2\")\n\n## plot storm counts per station and year\nplot(range(storms$year), range(storms$counts), type = \"n\",\n  xlab = \"Year\", ylab = \"Counts\")\nfor(j in levels(storms$id)) {\n  dj &lt;- subset(storms, id == j)\n  dj &lt;- dj[order(dj$year), ]\n  with(dj, lines(counts ~ year, type = \"b\", pch = 16,\n    col = rgb(0.1, 0.1, 0.1, alpha = 0.4)))\n}\n\n\n\n\n\n\n\n\nThe data contains storm counts per year for each station. A preliminary visualization of these counts allows us to inspect patterns of storm frequency over time and across stations.\n\n\nVisualizing the Spatial Structure\nWe begin by plotting the locations of weather stations on a map of Germany. The sf package is used to manage and plot spatial data.\n\n## load map of Germany\n## needs sf package for plotting\nlibrary(\"sf\")\ndata(\"Germany\", package = \"gamlss2\")\n\n## plot station locations\nplot(st_geometry(Germany))\nco &lt;- unique(storms[, c(\"lat\", \"lon\")])\npoints(co, col = 2, pch = 4, lwd = 2)\n\n\n\n\n\n\n\n\nThis map shows the geographical distribution of weather stations. The spatial structure will be incorporated into our model to account for the proximity of stations when estimating storm counts.\n\n\nDefining the Neighborhood Structure\nNext, we define the neighborhood structure among the weather stations using a distance-based criterion. This is crucial for the Markov random field, as it specifies how spatial correlation should be penalized.\n\n## estimate spatial count model using\n## a Markov random field, first a neighbor matrix\n## needs to be computed, here we use distance based\n## neighbors\nlibrary(\"spdep\")\n\nLoading required package: spData\n\n\nTo access larger datasets in this package, install the spDataLarge\npackage with: `install.packages('spDataLarge',\nrepos='https://nowosad.github.io/drat/', type='source')`\n\nnb &lt;- dnearneigh(st_centroid(st_geometry(Germany)), d1 = 0, d2 = 80)\nplot(st_geometry(Germany), border = \"lightgray\")\nplot.nb(nb, st_geometry(Germany), add = TRUE)\n\nWarning in st_point_on_surface.sfc(coords): st_point_on_surface may not give\ncorrect results for longitude/latitude data\n\n\n\n\n\n\n\n\n\nThe neighbor matrix is constructed using the poly2nb() function from the spdep package, which calculates the adjacency structure of the geographical regions. We then visualize the spatial network of neighbors on the map.\n\n\nConstructing the Penalty Matrix\nThe penalty matrix defines the spatial penalties imposed by the Markov random field. The matrix is constructed based on the neighbor relationships defined earlier.\n\n## compute final neighbor penalty matrix\nK &lt;- nb2mat(nb, style = \"B\", zero.policy = TRUE)\n\n## assign region names\nrownames(K) &lt;- colnames(K) &lt;- levels(Germany$id)\n\n## set up final penalty matrix\nK &lt;- -1 * K\ndiag(K) &lt;- -1 * rowSums(K)\n\n## remove regions not in data\ni &lt;- which(rownames(K) %in% levels(storms$id))\nK &lt;- K[i, i]\n\nThe penalty matrix K is set up such that it reflects the neighborhood relationships between the regions. Each element of the matrix represents how strongly each region is connected to its neighbors. The diagonal entries represent the total number of neighbors for each region.\n\n\nEstimating the Model\nWe now estimate the spatial count model using the Negative Binomial distribution (NBI). The model includes smooth functions of altitude, year, and an interaction between altitude and year. Spatial effects are incorporated using the bs = \"mrf\" option.\n\n## estimate count model using the NBI family,\n## model formula is\nf &lt;- ~ s(alt) + s(year) + s(id, bs = \"mrf\", xt = list(\"penalty\" = K)) +\n  te(alt, year)\nf &lt;- list(update(f, counts ~ .), f)\n\n## estimate model using BIC for shrinkage parameter selection\nb &lt;- gamlss2(f, data = storms, family = NBI, criterion = \"BIC\")\n\n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = counts ~ s(alt) + s(year) + s(id, bs = \"mrf\", \n    xt = list(penalty = K)) + te(alt, year) | s(alt) + s(year) + \n    s(id, bs = \"mrf\", xt = list(penalty = K)) + te(alt, year), \n    data = storms, family = NBI, ... = pairlist(x = FALSE, criterion = \"BIC\"))\n---\nFamily: NBI \nLink function: mu = log, sigma = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  1.15816    0.01616   71.68   &lt;2e-16 ***\n---\nSmooth terms:\n      s(alt)  s(year)    s(id) te(alt,year)\nedf   8.9102   6.3675 100.9338       4.5541\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.61129    0.02754   -22.2   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n     s(alt) s(year)   s(id) te(alt,year)\nedf  5.4313  1.9047 25.9703       3.0937\n*--------\nn = 3494 df =  159.17 res.df =  3334.83\nDeviance = 15698.2644 Null Dev. Red. = 18.53%\nAIC = 16016.5958 elapsed =  8.44sec\n\n\nHere, the spatial effect is modeled as an MRF smooth (s(id, bs = \"mrf\")), where the penalty matrix K enforces spatial structure based on neighboring stations. We use the Bayesian Information Criterion (BIC) to select the optimal smoothing parameters.\n\n\nVisualizing the Estimated Effects\nFinally, we visualize the estimated effects from the fitted model.\n\nplot(b)\n\n\n\n\n\n\n\n\nThe plot shows the estimated smooth functions for altitude, year, and the spatial effect. These visualizations help us interpret how storm counts vary across space and time.\n\n\nPrediction\nFirst we predict the spatial effects on the scale of the predictors. Therefore, we set up a new data frame containing only the unique loactions.\n\nnd &lt;- unique(storms[, \"id\", drop = FALSE])\n\n## set some dummy values, not needed when predicting single model term\nnd$alt &lt;- 1000\nnd$year &lt;- 2020\n\n## prediction for the mu predictor\nnd$fmu &lt;- predict(b, newdata = nd,\n  model = \"mu\", term = \"s(id)\",\n  type = \"link\")\n\n## same for sigma\nnd$fsigma &lt;- predict(b, newdata = nd,\n  model = \"sigma\", term = \"s(id)\",\n  type = \"link\")\n\n## add fitted values to map of Germany\nm &lt;- merge(Germany, nd, by = \"id\", all.x = TRUE)\n\n## plot spatial effects\nlibrary(\"ggplot2\")\nlibrary(\"colorspace\")\nggplot(m) + geom_sf(aes(fill = fmu)) +\nscale_fill_continuous_diverging(\"Blue-Red 3\") + theme_bw()\n\n\n\n\n\n\n\n## note that because of the discrete spatial effect,\n## there are a lot of NAs, therefore, we need to compute\n## predictions in such regions by averaging using the neighbors\n## of a region. we use the neighbour list object nb to compute\n## the predictions, this is iterated.\nwhile(any(is.na(m$fmu))) {\n  m$fmu &lt;- sapply(nb, function(i) mean(m$fmu[i], na.rm = TRUE))\n}\n\n## plot final spatial effect\nggplot(m) + geom_sf(aes(fill = fmu)) +\nscale_fill_continuous_diverging(\"Blue-Red 3\") + theme_bw()\n\n\n\n\n\n\n\n\n\n\n\n\n\nReferences\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Articles",
      "Spatial Effects"
    ]
  },
  {
    "objectID": "vignettes/s_pb.html",
    "href": "vignettes/s_pb.html",
    "title": "Smooth Terms using s() and pb()",
    "section": "",
    "text": "Examples on how to set up models using smooth terms with s() and pb().\n\n\n\n\nReferences\n\nEilers, P. H. C., and B. D. Marx. 2021. Practical Smoothing: The Joys of p-Splines. Cambridge University Press.\n\n\nFahrmeir, Ludwig, Thomas Kneib, Stefan Lang, and Brian Marx. 2021. Regression – Models, Methods and Applications. 2nd ed. Berlin: Springer-Verlag. https://doi.org/10.1007/978-3-662-63882-8.\n\n\nHofner, B., A. Mayr, N. Robinzonov, and M. Schmid. 2014. “Model-Based Boosting in r: A Hands-on Tutorial Using the r Package Mboost.” Computational Statistics 29: 3–35.\n\n\nHofner, B., A. Mayr, and M. Schmid. 2016. “gamboostLSS: An R Package for Model Building and Variable Selection in the GAMLSS Framework.” Journal of Statistical Software 74 (1): 1–31.\n\n\nKleiber, C., and A. Zeileis. 2016. “Visualizing Count Data Regressions Using Rootograms.” The American Statistician 70 (3): 296–303.\n\n\nLang, Stefan, Nikolaus Umlauf, Peter Wechselberger, Kenneth Harttgen, and Thomas Kneib. 2012. “Multilevel Structured Additive Regression.” Statistics and Computing 24 (2): 223–38. https://doi.org/10.1007/s11222-012-9366-0.\n\n\nMayr, A., N. Fenske, B. Hofner, T. Kneib, and M. Schmid. 2012. “Generalized Additive Models for Location, Scale and Shape for High Dimensional Data, a Flexible Approach Based on Boosting.” J. R. Statist. Soc. Series C 61: 403–27.\n\n\nRigby, R. A., and D. M. Stasinopoulos. 2005. “Generalized Additive Models for Location, Scale and Shape.” Journal of the Royal Statistical Society Series C (Applied Statistics) 54 (3): 507–54. https://doi.org/10.1111/j.1467-9876.2005.00510.x.\n\n\nRigby, R. A., D. M. Stasinopoulos, G. Z. Heller, and F. De Bastiani. 2019. Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in r. Boca Raton: Chapman & Hall/CRC.\n\n\nStadlmann, S. 2019. Distreg.vis: Framework for the Visualization of Distributional Regression Models. https://CRAN.R-project.org/package=distreg.vis.\n\n\nStasinopoulos, D. M., R. A. Rigby, and F. De Bastiani. 2018. “GAMLSS: A Distributional Regression Approach.” Statistical Modelling 18 (3-4): 248–73.\n\n\nStasinopoulos, D. M., R. A. Rigby, N. Giorgikopoulos, and F. De Bastiani. 2022. “Principal component regression in GAMLSS applied to Greek–German government bond yield spreads.” Statistical Modelling 22 (1-2): 127–45. https://doi.org/10.1177/1471082X211022980.\n\n\nStasinopoulos, D. M., R. A. Rigby, G. Z. Heller, V. Voudouris, and F. De Bastiani. 2017. Flexible Regression and Smoothing: Using GAMLSS in r. Boca Raton: Chapman & Hall/CRC.\n\n\nStasinopoulos, Dimitrios M, Robert A Rigby, Gillian Z Heller, and Fernanda De Bastiani. 2023. “P-Splines and GAMLSS: A Powerful Combination, with an Application to Zero-Adjusted Distributions.” Statistical Modelling 23 (5-6): 510–24.\n\n\nStasinopoulos, M. D., T. Kneib, N. Klein, A. Mayr, and G. Z Heller. 2024. Generalized Additive Models for Location, Scale and Shape: A Distributional Regression Approach, with Applications. Vol. 56. Cambridge University Press.\n\n\nUmlauf, N., N. Klein, and Α. Zeileis. 2018. “BAMLSS: Bayesian Additive Models for Location, Scale and Shape (and Beyond).” Journal of Computational and Graphical Statistics 27: 612–27.",
    "crumbs": [
      "Articles",
      "Smooth Terms using s() and pb()"
    ]
  },
  {
    "objectID": "CITATION.html",
    "href": "CITATION.html",
    "title": "Citation",
    "section": "",
    "text": "Citation\nTo cite GAMLSS in publications use:\n\nR.A. Rigby, D.M. Stasinopoulos (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x.",
    "crumbs": [
      "Citation"
    ]
  },
  {
    "objectID": "man/softplus.html",
    "href": "man/softplus.html",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Reference",
      "softplus"
    ]
  },
  {
    "objectID": "man/softplus.html#softplus-link-object",
    "href": "man/softplus.html#softplus-link-object",
    "title": "gamlss2",
    "section": "",
    "text": "Link object (with link function, inverse link function, etc.) that assures positivity of parameters based on the softplus function.\n\n\n\nsoftplus(a = 1)\n\n\n\n\n\n\n\na\n\n\nExtra parameter of the generalized softplus function\n\n\n\n\n\n\nThe softplus link function with parameter \\(a\\) is given by:\n\n\\(\\displaystyle \\frac{\\log(1 + \\exp(a \\cdot x))}{a}\\)\nThis is an approximation of the linear spline \\(\\max\\{0, x\\}\\) where the discrepancy between the two functions decreases with increasing \\(a\\).\nWiemann et al. (2023) propose to employ the softplus function as the inverse link function where positivity of a parameter needs to be assured, e.g., in count data regressions. This is in particular of interest as an alternative to the exponential inverse link function because the exponential implies multiplicative effects of the regressors while the softplus function does not.\n\n\n\nAn object of class “link-glm”.\n\n\n\nWiemann PFV, Kneib T, Hambuckers J (2023). “Using the Softplus Function to Construct Alternative Link Functions in Generalized Linear Models and Beyond.” Statistical Papers, forthcoming. doi:https://doi.org/10.1007/s00362-023-01509-x\n\n\n\nmake.link, gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## visualization of softmax function from Wiemann et al. (2003, Figure 1)\nx &lt;- -200:200/50\nplot(x, softplus(1)$linkinv(x), ylab = expression(softplus[a](x)),\n  type = \"l\", col = 2, lwd = 2)\ngrid()\nlines(x, softplus(5)$linkinv(x), col = 3, lwd = 2)\nlines(x, softplus(10)$linkinv(x), col = 4, lwd = 2)\nlines(x, pmax(0, x), lty = 3, lwd = 2)\nlegend(\"topleft\", c(\"a = 1\", \"a = 5\", \"a = 10\", \"linear spline\"),\n  col = c(2, 3, 4, 1), lty = c(1, 1, 1, 3), lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n## Poisson regression example with different links\ndata(\"FIFA2018\", package = \"distributions3\")\nm_exp &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = \"log\"))\nm_splus &lt;- glm(goals ~ difference, data = FIFA2018, family = poisson(link = softplus(1)))\nAIC(m_exp, m_splus)\n\n        df      AIC\nm_exp    2 359.3942\nm_splus  2 359.3774\n\n## comparison of fitted effects\nnd &lt;- data.frame(difference = -15:15/10)\nnd$mu_exp &lt;- predict(m_exp, newdata = nd, type = \"response\")\nnd$mu_splus &lt;- predict(m_splus, newdata = nd, type = \"response\")\nplot(mu_exp ~ difference, data = nd, ylab = expression(mu),\n  type = \"l\", col = 4, lwd = 2, ylim = c(0, 2.5))\nlines(mu_splus ~ difference, data = nd, col = 2, lwd = 2)\nlegend(\"topleft\", c(\"exp\", \"softplus\"), col = c(4, 2), lwd = 2, lty = 1, bty = \"n\")",
    "crumbs": [
      "Reference",
      "softplus"
    ]
  },
  {
    "objectID": "man/random.html",
    "href": "man/random.html",
    "title": "gamlss2",
    "section": "",
    "text": "There are two ways of fitting a random effect within gamlss2. The first, using s(), is for a simple random effect, that is, when only one factor is entered the model as a smoother. This method uses the function s() of the package mgcv with argument bs = “re”. For example, if area is factor with several levels, s(area, bs = “re”) will sringh the levels of area towards their mean level. The second, more general way, allows to fit more complicated random effect models using the function re(). The function re() is an interface connecting gamlss2 with the specialised package for random effects nlme.\nHere we document only the re() function only but we also give examples using s(…, bs = “re”).\n\n\n\nre(fixed =~ 1, random = NULL, ...)\n\n\n\n\n\n\n\nfixed\n\n\nA formula that specifies the fixed effects of the nlme{lme} model. In most cases, this can also be included in the gamlss2 parameter formula.\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the nlme{lme()} function.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the nlme{lme} function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor\nb &lt;- gamlss2(distance ~ s(age,k=3) + re(random =~ age11 | Subject),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6569 eps = 0.392363     \nGAMLSS-RS iteration  2: Global Deviance = 326.0931 eps = 0.001726     \nGAMLSS-RS iteration  3: Global Deviance = 326.0758 eps = 0.000053     \nGAMLSS-RS iteration  4: Global Deviance = 326.0757 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", elements = \"model\")\nsummary(st)\n\n                             Length Class  Mode\nmu.s(age)                     9     -none- list\nmu.re(random=~age11|Subject) 19     lme    list\n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.3879 eps = 0.204987     \nGAMLSS-RS iteration  2: Global Deviance = 370.2269 eps = 0.133744     \nGAMLSS-RS iteration  3: Global Deviance = 340.2986 eps = 0.080837     \nGAMLSS-RS iteration  4: Global Deviance = 325.4086 eps = 0.043755     \nGAMLSS-RS iteration  5: Global Deviance = 319.3603 eps = 0.018586     \nGAMLSS-RS iteration  6: Global Deviance = 316.706 eps = 0.008311     \nGAMLSS-RS iteration  7: Global Deviance = 315.7332 eps = 0.003071     \nGAMLSS-RS iteration  8: Global Deviance = 315.3835 eps = 0.001107     \nGAMLSS-RS iteration  9: Global Deviance = 315.2588 eps = 0.000395     \nGAMLSS-RS iteration 10: Global Deviance = 315.2156 eps = 0.000137     \nGAMLSS-RS iteration 11: Global Deviance = 315.2007 eps = 0.000047     \nGAMLSS-RS iteration 12: Global Deviance = 315.1956 eps = 0.000016     \nGAMLSS-RS iteration 13: Global Deviance = 315.1933 eps = 0.000007     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ s(Time) + re(random =~ sin1 | Mare,\n  correlation = corARMA(q = 2), control = lmeControl(maxIter = 100))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1553.7576 eps = 0.168812     \nGAMLSS-RS iteration  2: Global Deviance = 1550.0142 eps = 0.002409     \nGAMLSS-RS iteration  3: Global Deviance = 1549.9734 eps = 0.000026     \nGAMLSS-RS iteration  4: Global Deviance = 1549.9731 eps = 0.000000     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1007 eps = 0.185747     \nGAMLSS-RS iteration  2: Global Deviance = 1436.4746 eps = 0.056255     \nGAMLSS-RS iteration  3: Global Deviance = 1426.662 eps = 0.006831     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7706 eps = 0.000624     \nGAMLSS-RS iteration  5: Global Deviance = 1425.692 eps = 0.000055     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6854 eps = 0.000004     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n }",
    "crumbs": [
      "Reference",
      "random"
    ]
  },
  {
    "objectID": "man/random.html#random-effects",
    "href": "man/random.html#random-effects",
    "title": "gamlss2",
    "section": "",
    "text": "There are two ways of fitting a random effect within gamlss2. The first, using s(), is for a simple random effect, that is, when only one factor is entered the model as a smoother. This method uses the function s() of the package mgcv with argument bs = “re”. For example, if area is factor with several levels, s(area, bs = “re”) will sringh the levels of area towards their mean level. The second, more general way, allows to fit more complicated random effect models using the function re(). The function re() is an interface connecting gamlss2 with the specialised package for random effects nlme.\nHere we document only the re() function only but we also give examples using s(…, bs = “re”).\n\n\n\nre(fixed =~ 1, random = NULL, ...)\n\n\n\n\n\n\n\nfixed\n\n\nA formula that specifies the fixed effects of the nlme{lme} model. In most cases, this can also be included in the gamlss2 parameter formula.\n\n\n\n\nrandom\n\n\nA formula specifying the random effect part of the model, as in the nlme{lme()} function.\n\n\n\n\n…\n\n\nFor the re() function, the dots argument is used to specify additional control arguments for the nlme{lme} function, such as the method and correlation arguments.\n\n\n\n\n\n\nBoth functions set up model terms that can be estimated using a backfitting algorithm, e.g., the default RS algorithm.\n\n\n\nFunction s with bs = “re” returns a smooth specification object of class “re.smooth.spec”, see also smooth.construct.re.smooth.spec.\nThe re() function returns a special model term specification object, see specials for details.\n\n\n\ngamlss2, smooth.construct.re.smooth.spec, s, lme\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n\n\n## orthdontic measurement data\ndata(\"Orthodont\", package = \"nlme\")\n\n## model using lme()\nm &lt;- lme(distance ~ I(age-11), data = Orthodont,\n  random =~ I(age-11) | Subject, method = \"ML\")\n\n## using re(), function I() is not supported,\n## please transform all variables in advance\nOrthodont$age11  &lt;- Orthodont$age - 11\n\n## estimation using the re() constructor\nb &lt;- gamlss2(distance ~ s(age,k=3) + re(random =~ age11 | Subject),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 326.6569 eps = 0.392363     \nGAMLSS-RS iteration  2: Global Deviance = 326.0931 eps = 0.001726     \nGAMLSS-RS iteration  3: Global Deviance = 326.0758 eps = 0.000053     \nGAMLSS-RS iteration  4: Global Deviance = 326.0757 eps = 0.000000     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## extract summary for re() model term\nst &lt;- specials(b, model = \"mu\", elements = \"model\")\nsummary(st)\n\n                             Length Class  Mode\nmu.s(age)                     9     -none- list\nmu.re(random=~age11|Subject) 19     lme    list\n\n## random intercepts and slopes with s() using AIC\na &lt;- gamlss2(distance ~ s(age,k=3) + s(Subject, bs = \"re\") + s(Subject, age11, bs = \"re\"),\n  data = Orthodont)\n\nGAMLSS-RS iteration  1: Global Deviance = 427.3879 eps = 0.204987     \nGAMLSS-RS iteration  2: Global Deviance = 370.2269 eps = 0.133744     \nGAMLSS-RS iteration  3: Global Deviance = 340.2986 eps = 0.080837     \nGAMLSS-RS iteration  4: Global Deviance = 325.4086 eps = 0.043755     \nGAMLSS-RS iteration  5: Global Deviance = 319.3603 eps = 0.018586     \nGAMLSS-RS iteration  6: Global Deviance = 316.706 eps = 0.008311     \nGAMLSS-RS iteration  7: Global Deviance = 315.7332 eps = 0.003071     \nGAMLSS-RS iteration  8: Global Deviance = 315.3835 eps = 0.001107     \nGAMLSS-RS iteration  9: Global Deviance = 315.2588 eps = 0.000395     \nGAMLSS-RS iteration 10: Global Deviance = 315.2156 eps = 0.000137     \nGAMLSS-RS iteration 11: Global Deviance = 315.2007 eps = 0.000047     \nGAMLSS-RS iteration 12: Global Deviance = 315.1956 eps = 0.000016     \nGAMLSS-RS iteration 13: Global Deviance = 315.1933 eps = 0.000007     \n\n## compare fitted values\nplot(fitted(b, model = \"mu\"), fitted(m))\npoints(fitted(a, model = \"mu\"), fitted(m), col = 2)\nabline(0, 1, col = 4)\n\n\n\n\n\n\n\n## more complicated correlation structures.\ndata(\"Ovary\", package = \"nlme\")\n\n## ARMA model\nm &lt;- lme(follicles ~ sin(2 * pi * Time) + cos(2 * pi * Time), data = Ovary, \n  random = pdDiag(~sin(2*pi*Time)), correlation = corARMA(q = 2))\n\n## now with gamlss2(), transform in advance\nOvary$sin1 &lt;- sin(2 * pi * Ovary$Time)\nOvary$cos1 &lt;- cos(2 * pi * Ovary$Time)\n\n## model formula\nf &lt;- follicles ~ s(Time) + re(random =~ sin1 | Mare,\n  correlation = corARMA(q = 2), control = lmeControl(maxIter = 100))\n\n## estimate model\nb &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1553.7576 eps = 0.168812     \nGAMLSS-RS iteration  2: Global Deviance = 1550.0142 eps = 0.002409     \nGAMLSS-RS iteration  3: Global Deviance = 1549.9734 eps = 0.000026     \nGAMLSS-RS iteration  4: Global Deviance = 1549.9731 eps = 0.000000     \n\n## smooth random effects\nf &lt;- follicles ~ ti(Time) + ti(Mare, bs = \"re\") + \n  ti(Mare, Time, bs = c(\"re\", \"cr\"), k = c(11, 5))\n\ng &lt;- gamlss2(f, data = Ovary)\n\nGAMLSS-RS iteration  1: Global Deviance = 1522.1007 eps = 0.185747     \nGAMLSS-RS iteration  2: Global Deviance = 1436.4746 eps = 0.056255     \nGAMLSS-RS iteration  3: Global Deviance = 1426.662 eps = 0.006831     \nGAMLSS-RS iteration  4: Global Deviance = 1425.7706 eps = 0.000624     \nGAMLSS-RS iteration  5: Global Deviance = 1425.692 eps = 0.000055     \nGAMLSS-RS iteration  6: Global Deviance = 1425.6854 eps = 0.000004     \n\n## compare fitted values\npar(mfrow = n2mfrow(nlevels(Ovary$Mare)), mar = c(4, 4, 1, 1))\n\nfor(j in levels(Ovary$Mare)) {\n  ds &lt;- subset(Ovary, Mare == j)\n\n  plot(follicles ~ Time, data = ds)\n\n  f &lt;- fitted(b, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 4, lwd = 2)\n\n  f &lt;- fitted(g, model = \"mu\")[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 3, lwd = 2)\n\n  f &lt;- fitted(m)[Ovary$Mare == j]\n  lines(f ~ ds$Time, col = 2, lwd = 2)\n }",
    "crumbs": [
      "Reference",
      "random"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html",
    "href": "man/gamlss2-package.html",
    "title": "gamlss2",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Reference",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "href": "man/gamlss2-package.html#gamlss-modeling-with-advanced-flexible-infrastructures",
    "title": "gamlss2",
    "section": "",
    "text": "The primary purpose of this package is to facilitate the creation of advanced infrastructures designed to enhance the Generalized Additive Models for Location Scale and Shape (GAMLSS, Rigby and Stasinopoulos 2005) modeling framework. Notably, the gamlss2 package represents a significant overhaul of its predecessor, gamlss, with a key emphasis on improving estimation speed and incorporating more adaptable infrastructures. These enhancements enable the seamless integration of various algorithms into GAMLSS, including gradient boosting, Bayesian estimation, regression trees, and forests, fostering a more versatile and powerful modeling environment.\nMoreover, the package expands its compatibility by supporting all model terms from the base R mgcv package. Additionally, the gamlss2 package introduces the capability to accommodate more than four parameter families. Essentially, this means that users can now specify any type of model using these new infrastructures, making the package highly flexible and accommodating to a wide range of modeling requirements.\n\n\n\nMaintainer: \n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\ngamlss2, fake_formula",
    "crumbs": [
      "Reference",
      "gamlss2-package"
    ]
  },
  {
    "objectID": "man/misc.html",
    "href": "man/misc.html",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Reference",
      "misc"
    ]
  },
  {
    "objectID": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "href": "man/misc.html#auxiliary-functions-for-formulas-and-model-objects",
    "title": "gamlss2",
    "section": "",
    "text": "Various auxiliary functions to facilitate the work with formulas and fitted model objects.\n\n\n\nresponse_name(formula)\n\n\n\n\n\n\n\nformula\n\n\nA formula, Formula, or a fitted model object.\n\n\n\n\n\n\nFunction response_name extracts the response name as a character vector.\n\n\n\ngamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n## basic formula\nf &lt;- y ~ x1 + x2 + log(x3)\nresponse_name(f)\n\n[1] \"y\"\n\n## formula with multiple responses\nf &lt;- y1 | y2 | y3 ~ x1 + s(x2) + x3 + te(log(x3), x4) | x2 + ti(x5)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"\n\n## list of formulas\nf &lt;- list(\n  y1 ~ x1 + s(x2) + x3 + te(log(x3), x4),\n  y2  ~ x2 + sqrt(x5),\n  y3  ~ z2 + x1 + exp(x3) + s(x10)\n)\nresponse_name(f)\n\n[1] \"y1\" \"y2\" \"y3\"",
    "crumbs": [
      "Reference",
      "misc"
    ]
  },
  {
    "objectID": "man/RS_CG.html",
    "href": "man/RS_CG.html",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Reference",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "href": "man/RS_CG.html#rigby-and-stasinopoulos-rs-cole-and-green-cg-algorithm",
    "title": "gamlss2",
    "section": "",
    "text": "The function RS() implements the algorithm of Rigby and Stasinopoulos, the function CG() implements the algorithm of Cole and Green for estimating a GAMLSS with gamlss2.\n\n\n\n## Rigby and Stasinopoulos algorithm.\nRS(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n## Cole and Green algorithm.\nCG(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2. See the details.\n\n\n\n\n\n\nFunctions RS() and CG() are called within gamlss2. Both functions implement a backfitting algorithm for estimating GAMLSS. For algorithm details see Rigby and Stasinopoulos (2005).\nThe functions use the following control arguments:\n\n\neps: Numeric vector of length 2, the stopping criterion. Default is eps = c(1e-05, 1e-05) for the outer and the inner backfitting loop.\n\n\nmaxit: Integer vector of length 2, the maximum number of iterations of the outer and inner backfitting loop. Default is maxit = c(100, 10).\n\n\nstep: Numeric, the step length control parameter. Default is step = 1. Note that if step is set smaller than 1, it might be appropriate to lower the stopping criterion eps, too.\n\n\nCG: Integer, the number of iterations when to start the CG correction. Default is CG = Inf.\n\n\ntrace: Logical, should information be printed while the algorithm is running?\n\n\nflush: Logical, use flush.console for displaying the current output in the console.\n\n\nridge: Logical, should automatic ridge penalization be applied only to linear effects, without penalizing the intercept? For each parameter of the distribution the optimum ridge penalty is estimated using an information criterion. Possible options are criterion = c(“aic”, “aicc”, “bic”, “gaic”, “gcv”). The default is criterion = “gaic” and argument K = 2, which can be set in gamlss2_control.\n\n\nTo facilitate the development of new algorithms for gamlss2, users can exchange them using the optimizer argument in gamlss2_control. Users developing new model fitting functions are advised to use these functions as templates and pass them to gamlss2_control. Alternatively, users can replace the optimizer function by adding a named list element, “optimizer”, to the family object. For instructions on setting up new families in gamlss2, see gamlss2.family.\n\n\n\nFunctions RS() and CG() return a named list of class “gamlss2” containing the following objects:\n\n\n\nfitted.values\n\n\nA data frame of the fitted values of the modeled parameters of the selected distribution.\n\n\n\n\nfitted.specials\n\n\nA named list, one element for each parameter of the distribution, containing the fitted model object information of special model terms.\n\n\n\n\nfitted.linear\n\n\nA named list, one element for each parameter of the distribution, containing the information on fitted linear effects.\n\n\n\n\ncoefficients\n\n\nA named list, one element for each parameter of the distribution, containing the estimated parameters of the linear effects.\n\n\n\n\nelapsed\n\n\nThe elapsed runtime of the algorithm.\n\n\n\n\niterations\n\n\nHow many iterations the algorithm performed.\n\n\n\n\nlogLik\n\n\nThe final value of the log-likelihood of the model.\n\n\n\n\ncontrol\n\n\nAll control arguments used as supplied from function gamlss2_control.\n\n\n\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\n\n\n\ngamlss2, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model using RS (default)\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = RS)\n\n## now with CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, optimizer = CG)\n\n## first 2 RS iterations and afterwards switch to CG\nb &lt;- gamlss2(f, data = abdom, family = BCT, CG = 2)",
    "crumbs": [
      "Reference",
      "RS_CG"
    ]
  },
  {
    "objectID": "man/plots.html",
    "href": "man/plots.html",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Reference",
      "plots"
    ]
  },
  {
    "objectID": "man/plots.html#plotting-gamlss",
    "href": "man/plots.html#plotting-gamlss",
    "title": "gamlss2",
    "section": "",
    "text": "Plotting methods for objects of class “gamlss2” and “gamlss2.list”, which can be used for effect plots of model terms or residual plots. Note that effect plots of model terms with more than two covariates are not supported, for this purpose use the predict method.\n\n\n\n## S3 method for class 'gamlss2'\nplot(x, parameter = NULL,\n  which = \"effects\", terms = NULL,\n  scale = TRUE, spar = TRUE, ...)\n\n## S3 method for class 'gamlss2.list'\nplot(x, parameter = NULL, which = \"effects\",\n  terms = NULL, spar = TRUE, legend = TRUE, ...)\n\n\n\n\n\n\n\nx\n\n\nAn object of class “gamlss2” or “gamlss2.list”, which can be created by using the c() method combining “gamlss2” objects. See th examples.\n\n\n\n\nparameter\n\n\nCharacter or integer. For which parameter/model/what should the plots be created? Note that instead of argument parameter plots can also be specified passing argument model and what to ….\n\n\n\n\nwhich\n\n\nCharacter or integer, selects the type of plot: “effects” produces effect plots of (special) model terms, “hist-resid” shows a histogram of residuals, “qq-resid” shows a quantile-quantile plot of residuals, “scatter-resid” shows a scatter plot of residuals with fitted values for the distribution mean (or median, if available in the family object).\n\n\n\n\nterms\n\n\nCharacter or integer. For which model term should the plot(s) be created?\n\n\n\n\nscale\n\n\nIf set to 1, effect plots all have the same scale on the y-axis. If set to 0 each effect plot has its own scale for the y-axis.\n\n\n\n\nspar\n\n\nShould graphical parameters be set?\n\n\n\n\nlegend\n\n\nShould a legend be added using multiple model plots?\n\n\n\n\n…\n\n\nArguments such as lwd, lty, col, legend = TRUE (for multiple model plots), a.o., depending on the type of plot. See the examples.\n\n\n\n\n\n\ngamlss2.\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"film90\", package = \"gamlss.data\")\n\n## model formula\nf &lt;-  ~ s(lboopen) + s(lnosc)\nf &lt;- rep(list(f), 4)\nf[[1]] &lt;- update(f[[1]], lborev1 ~ .)\n\n## estimate model\nb1 &lt;- gamlss2(f, data = film90, family = BCCG)\n\n## plot effects (default)\nplot(b1)\n\n## plot specific effect\nplot(b1, parameter = \"sigma\")\nplot(b1, model = \"sigma\")\nplot(b1, model = \"nu\", term = 1)\nplot(b1, model = \"nu\", term = 2)\nplot(b1, model = \"nu\", term = \"lnosc\")\nplot(b1, term = \"lnosc\")\n\n## plot all residual diagnostics\nplot(b1, which = \"resid\")\n\n## single diagnostic plots\nplot(b1, which = \"hist-resid\")\nplot(b1, which = \"qq-resid\")\nplot(b1, which = \"wp-resid\")\nplot(b1, which = \"scatter-resid\")\n\n## estimate another model\nb2 &lt;- gamlss2(f, data = film90, family = BCPE)\n\n## compare estimated effects\nplot(c(b1, b2))\nplot(c(b1, b2), term = \"lboopen\",\n  col = c(1, 4), lwd = 3, lty = 1,\n  pos = c(\"topleft\", \"topright\", \"bottomleft\", \"bottomright\"))\nplot(c(b1, b2), model = \"sigma\")\nplot(c(b1, b2), model = \"sigma\", term = 2)\nplot(c(b1, b2), model = c(\"mu\", \"nu\"))",
    "crumbs": [
      "Reference",
      "plots"
    ]
  },
  {
    "objectID": "man/stepwise.html",
    "href": "man/stepwise.html",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## After stepwise search, extract the new formula.\nnew_formula(object)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nobject\n\n\nAn object fitted using step_gamlss2().\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\ngamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Reference",
      "stepwise"
    ]
  },
  {
    "objectID": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "href": "man/stepwise.html#stepwise-model-term-selection-using-gaic",
    "title": "gamlss2",
    "section": "",
    "text": "The optimizer function stepwise() performs stepwise model term selection using a Generalized Akaike Information Criterion (GAIC). Estimation is based on the Rigby and Stasinopoulos (RS) & Cole and Green (CG) algorithm as implemented in function RS.\n\n\n\n## Wrapper function for stepwise GAMLSS estimation.\nstep_gamlss2(formula, ..., K = 2,\n  strategy = c(\"both.linear\", \"both\"), keeporder = FALSE,\n  cores = 1L)\n\n## After stepwise search, extract the new formula.\nnew_formula(object)\n\n## Stepwise optimizer function.\nstepwise(x, y, specials, family, offsets,\n  weights, start, xterms, sterms, control)\n\n\n\n\n\n\n\nformula\n\n\nA model formula for gamlss2.\n\n\n\n\n…\n\n\nArguments passed to gamlss2.\n\n\n\n\nK\n\n\nNumeric, the penalty for the GAIC.\n\n\n\n\nstrategy\n\n\nCharacter, the strategy that should be applied for the stepwise algorithm. Possible options are “forward.linear”, “forward”, “backward”, “backward.linear”, “replace”, “replace.linear”, “both”, “both.linear”. See the details.\n\n\n\n\nkeeporder\n\n\nLogical, For the different strategies of the stepwise algorithm, should the updates be performed sequentially according to the order of the parameters of the response distribution as specified in the family (see gamlss2.family), or should the selection search be performed across all parameters?\n\n\n\n\ncores\n\n\nInteger, if cores &gt; 1L, function mclapply function is used to speed up computations using multiple cores within the selection steps.\n\n\n\n\nobject\n\n\nAn object fitted using step_gamlss2().\n\n\n\n\nx\n\n\nThe full model matrix to be used for fitting.\n\n\n\n\ny\n\n\nThe response vector or matrix.\n\n\n\n\nspecials\n\n\nA named list of special model terms, e.g., including design and penalty matrices for fitting smooth terms using smooth.construct.\n\n\n\n\nfamily\n\n\nA family object, see gamlss2.family.\n\n\n\n\noffsets\n\n\nIf supplied, a list or data frame of possible model offset.\n\n\n\n\nweights\n\n\nIf supplied, a numeric vector of weights.\n\n\n\n\nstart\n\n\nStarting values, either for the parameters of the response distribution or, if specified as a named list in which each element of length one is named with “(Intercept)”, the respective intercepts are initialized. If starting values are specified as a named list, data frame or matrix, where each element/column is a vector with the same length as the number of observations in the data, the respective predictors are initialized with these. See the examples for gamlss2.\n\n\n\n\nxterms\n\n\nA named list specifying the linear model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\nsterms\n\n\nA named list specifying the special model terms. Each named list element represents one parameter as specified in the family object.\n\n\n\n\ncontrol\n\n\nFurther control arguments as specified within the call of gamlss2.\n\n\n\n\n\n\nThe wrapper function step_gamlss2() calls gamlss2 using the stepwise() optimizer function.\nThe stepwise algorithm can apply the following strategies:\n\n\nEach predictor must include an intercept.\n\n\nIn a forward selection step, model terms with the highest improvement on the GAIC are selected.\n\n\nIn a replacement step, each model term is tested to see if an exchange with a model term not yet selected will improve the GAIC.\n\n\nIn a backward step, model terms are deselected, if the GAIC can be further improved.\n\n\nIn a bidirectional step, model terms can be either added or removed.\n\n\nIn addition, the forward, backward and replace selection step can be combined.\n\n\nThe selected strategies are iterated until no further improvement is achieved.\nThe different strategies can be selected using argument strategy. Please see the examples. Possible values are strategy = c(“both”, “forward”, “backward”, “replace”, “all”). Here, strategy = “all” combines the forward, backward and replace selection step.\nIn addition, each of the steps 2-4 can be applied to linear model terms only, prior to performing the steps for all model terms. This can be done by additionally setting strategy = c(“both.linear”, “forward.linear”, “backward.linear”, “replace.linear”, “all.linear”).\nThe default is strategy = c(“both.linear”, “both”) and keeporder = FALSE.\nNote that each of the steps 2-4 can be performed while maintaining the order of the parameters of the response distribution, i.e., if the keeporder = TRUE argument is set, then the parameters will be updated in the order specified in the gamlss2.family. Using backward elimination, the model terms are deselected in reverse order.\n\n\n\nThe optimizer function stepwise() returns the final model as named list of class “gamlss2”. See the return value of function RS. The wrapper function step_gamlss2() also returns the final model.\n\n\n\ngamlss2, gamlss2_control, RS\n\n\n\n\nlibrary(\"gamlss2\")\n\n\ndata(\"rent\", package = \"gamlss.data\")\n\n## because of possible linear interactions,\n## scale the covariates first\nrent$Fl &lt;- scale(rent$Fl)\nrent$A &lt;- scale(rent$A)\n\n## the Formula defines the searching scope\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## estimate a Gamma model using the stepwise algorithm\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2)\n\n## same with\n## b &lt;- gamlss2(f, data = rent, family = GA, optimizer = stepwise, K = 2)\n\n## show the new formula of selected model terms\nnew_formula(b)\n\n## final model summary\nsummary(b)\n\n## effect plots\nplot(b)\n\n## diagnostic plots\nplot(b, which = \"resid\")\n\n## plot GAIC\nplot(b, which = \"selection\")\n\n## use forward linear, replace and backward strategy\nb &lt;- step_gamlss2(f, data = rent, family = GA, K = 2,\n  strategy = c(\"forward.linear\", \"replace\", \"backward\"))\n\n## more complex model\n## note, the third parameter\n## nu does not include any model terms\nf &lt;- R ~ Fl + A + Fl:A + loc + s(Fl) + s(A) + te(Fl, A) |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A) |\n  1 |\n  Fl + A + loc + Fl:A + s(Fl) + s(A) + te(Fl, A)\n\n## model using the BCT family\nb &lt;- step_gamlss2(f, data = rent, family = BCT,\n  K = 2, strategy = c(\"forward.linear\", \"both\"),\n  keeporder = TRUE)\n\n## plot GAIC\nplot(b, which = \"selection\")",
    "crumbs": [
      "Reference",
      "stepwise"
    ]
  },
  {
    "objectID": "man/gamlss2.html",
    "href": "man/gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(x, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(x, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam.\n\n\n\n\nx\n\n\nFor gamlss.list() x is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4683 eps = 0.534345     \nGAMLSS-RS iteration  2: Global Deviance = 4770.229 eps = 0.000887     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1663 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1554 eps = 0.000002     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  226.334      1.257     180   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 4.551\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -2.92264    0.01101  -265.5   &lt;2e-16 ***\n---\nSmooth terms:\n      s(x)\nedf 2.5639\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.18021    0.04599  -3.918 9.95e-05 ***\n---\nSmooth terms:\n      s(x)\nedf 1.0015\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   2.6548     0.0144   184.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n      s(x)\nedf 1.0042\n*--------\nn = 610 df =  13.12 res.df =  596.88\nDeviance = 4770.1554 Null Dev. Red. = 33.39%\nAIC = 4796.3966 elapsed =  0.80sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4789.7797 eps = 0.556012     \nGAMLSS-RS iteration  2: Global Deviance = 4774.5657 eps = 0.003176     \nGAMLSS-RS iteration  3: Global Deviance = 4771.4193 eps = 0.000658     \nGAMLSS-RS iteration  4: Global Deviance = 4769.9947 eps = 0.000298     \nGAMLSS-RS iteration  5: Global Deviance = 4769.9556 eps = 0.000008     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 4799.422 eps = 0.555118     \nGAMLSS-RS iteration  2: Global Deviance = 4795.2807 eps = 0.000862     \nGAMLSS-RS iteration  3: Global Deviance = 4795.2668 eps = 0.000002     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.347632           -2.922923            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4902.0767 eps = 0.372276     \nGAMLSS-RS iteration  2: Global Deviance = 4775.8465 eps = 0.025750     \nGAMLSS-RS iteration  3: Global Deviance = 4775.0302 eps = 0.000170     \nGAMLSS-RS iteration  4: Global Deviance = 4774.9582 eps = 0.000015     \nGAMLSS-RS iteration  5: Global Deviance = 4774.9519 eps = 0.000001     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4683 eps = 0.534345     \nGAMLSS-RS iteration  2: Global Deviance = 4770.229 eps = 0.000887     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1663 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1554 eps = 0.000002",
    "crumbs": [
      "Reference",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "href": "man/gamlss2.html#generalized-additive-models-for-location-scale-and-shape",
    "title": "gamlss2",
    "section": "",
    "text": "Estimation of generalized additive models for location scale and shape (GAMLSS). The model fitting function gamlss2() provides flexible infrastructures to estimate the parameters of a response distribution. The number of distributional parameters is not fixed, see gamlss2.family. Moreover, gamlss2() supports all smooth term constructors from the mgcv package in addition to the classical model terms as provided by gamlss and gamlss.add.\n\n\n\ngamlss2(x, ...)\n\n## S3 method for class 'formula'\ngamlss2(formula, data, family = NO,\n  subset, na.action, weights, offset, start = NULL,\n  control = gamlss2_control(...), ...)\n\n## S3 method for class 'list'\ngamlss2(x, ...)\n\n\n\n\n\n\n\nformula\n\n\nA GAM-type formula or Formula. All smooth terms of the mgcv package are supported, see also formula.gam.\n\n\n\n\nx\n\n\nFor gamlss.list() x is a list of formulas.\n\n\n\n\ndata\n\n\nA data frame or list or environment containing the variables in the model. If not found in data, the variables are taken from environment(formula), typically the environment from which gamlss2 is called.\n\n\n\n\nfamily\n\n\nA gamlss.family or gamlss2.family object used to define distribution and the link functions of the parameters.\n\n\n\n\nsubset\n\n\nAn optional vector specifying a subset of observations to be used in the fitting process.\n\n\n\n\nna.action\n\n\nNA processing for setting up the model.frame.\n\n\n\n\nweights\n\n\nAn optional vector of prior weights to be used in the fitting process. Should be NULL or a numeric vector.\n\n\n\n\noffset\n\n\nThis can be used to specify an a priori known components to be included in the linear predictors during fitting. Please note that if only a single numeric vector is provided, the offset will be assigned to the first specified parameter of the distribution. In the case of multiple offsets, a data frame or list must be supplied. Each offset is assigned in the same order as the parameters of the distribution specified in the family object.\n\n\n\n\nstart\n\n\nStarting values for estimation algorithms.\n\n\n\n\ncontrol\n\n\nA list of control arguments, see gamlss2_control.\n\n\n\n\n…\n\n\nArguments passed to gamlss2_control.\n\n\n\n\n\n\nThe model fitting function gamlss2() provides flexible infrastructures for the estimation of GAMLSS.\n\n\nDistributional models are specified using family objects, either from the gamlss.dist package or using gamlss2.family objects.\n\n\nEstimation is carried out through a Newton-Raphson/Fisher scoring algorithm, see function RS. The estimation algorithms can also be exchanged using gamlss2_control. Additionally, if an optimizer is specified by the family object, this optimizer function will be employed for estimation.\n\n\nThe return value is determined by the object returned from the optimizer function, typically an object of class “gamlss2”. Default methods and extractor functions are available for this class. Nevertheless, users have the flexibility to supply their own optimizer function, along with user-specific methods tailored for the returned object.\n\n\n\n\n\nThe return value is determined by the object returned from the optimizer function. By default, the optimization is performed using the RS optimizer function (see gamlss2_control), yielding an object of class “gamlss2”. Default methods and extractor functions are available for this class.\n\n\n\nRigby RA, Stasinopoulos DM (2005). “Generalized Additive Models for Location, Scale and Shape (with Discussion).” Journal of the Royal Statistical Society, Series C (Applied Statistics), 54, 507–554. doi:10.1111/j.1467-9876.2005.00510.x\nRigby RA, Stasinopoulos DM, Heller GZ, De Bastiani F (2019). Distributions for Modeling Location, Scale, and Shape: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/9780429298547\nStasinopoulos DM, Rigby RA (2007). “Generalized Additive Models for Location Scale and Shape (GAMLSS) in R.” Journal of Statistical Software, 23(7), 1–46. doi:10.18637/jss.v023.i07\nStasinopoulos DM, Rigby RA, Heller GZ, Voudouris V, De Bastiani F (2017). Flexible Regression and Smoothing: Using GAMLSS in R, Chapman and Hall/CRC. doi:10.1201/b21973\n\n\n\nRS, gamlss2_control, gamlss2.family\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## load the abdominal circumference data\ndata(\"abdom\", package = \"gamlss.data\")\n\n## specify the model Formula\nf &lt;- y ~ s(x) | s(x) | s(x) | s(x)\n\n## estimate model\nb &lt;- gamlss2(f, data = abdom, family = BCT)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4683 eps = 0.534345     \nGAMLSS-RS iteration  2: Global Deviance = 4770.229 eps = 0.000887     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1663 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1554 eps = 0.000002     \n\n## model summary\nsummary(b)\n\nCall:\ngamlss2(formula = f, data = abdom, family = BCT)\n---\nFamily: BCT \nLink function: mu = identity, sigma = log, nu = identity, tau = log\n*--------\nParameter: mu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  226.334      1.257     180   &lt;2e-16 ***\n---\nSmooth terms:\n     s(x)\nedf 4.551\n*--------\nParameter: sigma \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -2.92264    0.01101  -265.5   &lt;2e-16 ***\n---\nSmooth terms:\n      s(x)\nedf 2.5639\n*--------\nParameter: nu \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -0.18021    0.04599  -3.918 9.95e-05 ***\n---\nSmooth terms:\n      s(x)\nedf 1.0015\n*--------\nParameter: tau \n---\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   2.6548     0.0144   184.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n---\nSmooth terms:\n      s(x)\nedf 1.0042\n*--------\nn = 610 df =  13.12 res.df =  596.88\nDeviance = 4770.1554 Null Dev. Red. = 33.39%\nAIC = 4796.3966 elapsed =  0.80sec\n\n## plot estimated effects\nplot(b, which = \"effects\")\n\n\n\n\n\n\n\n## plot diagnostics\nplot(b, which = \"resid\")\n\n\n\n\n\n\n\n## predict parameters\npar &lt;- predict(b)\n\n## predict quantiles\npq &lt;- sapply(c(0.05, 0.5, 0.95), function(q) family(b)$q(q, par))\n\n## visualize\nplot(y ~ x, data = abdom, pch = 19,\n  col = rgb(0.1, 0.1, 0.1, alpha = 0.3))\nmatplot(abdom$x, pq, type = \"l\", lwd = 2,\n  lty = 1, col = 4, add = TRUE)\n\n\n\n\n\n\n\n## use of starting values\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10))\n\nGAMLSS-RS iteration  1: Global Deviance = 4789.7797 eps = 0.556012     \nGAMLSS-RS iteration  2: Global Deviance = 4774.5657 eps = 0.003176     \nGAMLSS-RS iteration  3: Global Deviance = 4771.4193 eps = 0.000658     \nGAMLSS-RS iteration  4: Global Deviance = 4769.9947 eps = 0.000298     \nGAMLSS-RS iteration  5: Global Deviance = 4769.9556 eps = 0.000008     \n\n## fix some parameters\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = c(mu = 200, sigma = 0.1, nu = 0, tau = 10),\n  fixed = c(nu = TRUE, tau = TRUE))\n\nGAMLSS-RS iteration  1: Global Deviance = 4799.422 eps = 0.555118     \nGAMLSS-RS iteration  2: Global Deviance = 4795.2807 eps = 0.000862     \nGAMLSS-RS iteration  3: Global Deviance = 4795.2668 eps = 0.000002     \n\n## estimated coefficients (intercepts)\ncoef(m)\n\n   mu.p.(Intercept) sigma.p.(Intercept)    nu.p.(Intercept)   tau.p.(Intercept) \n         226.347632           -2.922923            0.000000            2.302585 \n\n## starting values using full predictors\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = fitted(m))\n\nGAMLSS-RS iteration  1: Global Deviance = 4902.0767 eps = 0.372276     \nGAMLSS-RS iteration  2: Global Deviance = 4775.8465 eps = 0.025750     \nGAMLSS-RS iteration  3: Global Deviance = 4775.0302 eps = 0.000170     \nGAMLSS-RS iteration  4: Global Deviance = 4774.9582 eps = 0.000015     \nGAMLSS-RS iteration  5: Global Deviance = 4774.9519 eps = 0.000001     \n\n## same with\nm &lt;- gamlss2(f, data = abdom, family = BCT,\n  start = m)\n\nGAMLSS-RS iteration  1: Global Deviance = 4774.4683 eps = 0.534345     \nGAMLSS-RS iteration  2: Global Deviance = 4770.229 eps = 0.000887     \nGAMLSS-RS iteration  3: Global Deviance = 4770.1663 eps = 0.000013     \nGAMLSS-RS iteration  4: Global Deviance = 4770.1554 eps = 0.000002",
    "crumbs": [
      "Reference",
      "gamlss2"
    ]
  },
  {
    "objectID": "man/storms.html",
    "href": "man/storms.html",
    "title": "gamlss2",
    "section": "",
    "text": "According to the Beaufort scale, severe storms occur from a wind speed of 24.5-28.4 m/s. This dataset contains annual severe storm counts from weather stations in Germany from 1981 to 2021.\n\n\n\ndata(\"storms\", package = \"gamlss2\")\n\n\n\nA data frame containing 3494 observations on 8 variables.\n\n\nid\n\n\nFactor, the weather station id.\n\n\ncounty\n\n\nCharacter, the county in Germany where the weather station is located.\n\n\nstate\n\n\nCharacter, the state in Germany where the weather station is located.\n\n\nyear\n\n\nInteger, the year the observation was measured.\n\n\ncounts\n\n\nInteger, the number of severe storms in this year.\n\n\nalt\n\n\nNumeric, the altitude in meters above sea level of the weather station.\n\n\nlon\n\n\nNumeric, the longitude coordinate of the weather station.\n\n\nlat\n\n\nNumeric, the latitude coordinate of the weather station.\n\n\n\n\n\nSevere Storms Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nCoordinate Reference System:\n\n\nLongitude/latitude and the WGS84 datum.\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## load the data\ndata(\"storms\", package = \"gamlss2\")\n\n## yearly observations\nplot(counts ~ year, data = storms)\n\n## count distribution\nbarplot(table(storms$counts))\n\n## NBI model\n## model formula including spatial effect\n  s(year) + s(alt) + s(lon, lat)\n\n## estimate model\nb &lt;- gamlss2(f, data = storms, family = NBI)\n\n## estimated effects\nplot(b)\n\n## residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "storms"
    ]
  },
  {
    "objectID": "man/storms.html#severe-storms-in-germany",
    "href": "man/storms.html#severe-storms-in-germany",
    "title": "gamlss2",
    "section": "",
    "text": "According to the Beaufort scale, severe storms occur from a wind speed of 24.5-28.4 m/s. This dataset contains annual severe storm counts from weather stations in Germany from 1981 to 2021.\n\n\n\ndata(\"storms\", package = \"gamlss2\")\n\n\n\nA data frame containing 3494 observations on 8 variables.\n\n\nid\n\n\nFactor, the weather station id.\n\n\ncounty\n\n\nCharacter, the county in Germany where the weather station is located.\n\n\nstate\n\n\nCharacter, the state in Germany where the weather station is located.\n\n\nyear\n\n\nInteger, the year the observation was measured.\n\n\ncounts\n\n\nInteger, the number of severe storms in this year.\n\n\nalt\n\n\nNumeric, the altitude in meters above sea level of the weather station.\n\n\nlon\n\n\nNumeric, the longitude coordinate of the weather station.\n\n\nlat\n\n\nNumeric, the latitude coordinate of the weather station.\n\n\n\n\n\nSevere Storms Data:\n\n\nData Source:\n\n\nDeutscher Wetterdienst (DWD), Climate Data Center (CDC).\n\n\nLicence:\n\n\nCC BY 4.0\n\n\nURL:\n\n\nhttps://opendata.dwd.de/climate_environment/CDC/\n\n\nCoordinate Reference System:\n\n\nLongitude/latitude and the WGS84 datum.\n\n\n\n\n\n\nlibrary(\"gamlss2\")\n\n## load the data\ndata(\"storms\", package = \"gamlss2\")\n\n## yearly observations\nplot(counts ~ year, data = storms)\n\n## count distribution\nbarplot(table(storms$counts))\n\n## NBI model\n## model formula including spatial effect\n  s(year) + s(alt) + s(lon, lat)\n\n## estimate model\nb &lt;- gamlss2(f, data = storms, family = NBI)\n\n## estimated effects\nplot(b)\n\n## residual diagnostics\nplot(b, which = \"resid\")",
    "crumbs": [
      "Reference",
      "storms"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html",
    "href": "man/prodist.gamlss2.html",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3541 eps = 0.125497     \nGAMLSS-RS iteration  2: Global Deviance = 405.7146 eps = 0.004024     \nGAMLSS-RS iteration  3: Global Deviance = 405.6978 eps = 0.000041     \nGAMLSS-RS iteration  4: Global Deviance = 405.6976 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                     1                                      2 \n\"GAMLSS NO(mu = 23.04, sigma = 10.06)\" \"GAMLSS NO(mu = 59.04, sigma = 18.51)\" \n                                     3 \n\"GAMLSS NO(mu = 96.35, sigma = 33.95)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.486962 23.03912  39.59128\n2 28.589641 59.03607  89.48250\n3 40.504887 96.34896 152.19303\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.486962  59.036073 152.193030 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\nvariance(d)\n\n        1         2         3 \n 101.2639  342.6244 1152.6558 \n\n## simulate random numbers\nrandom(d, 5)\n\n         r_1      r_2      r_3       r_4      r_5\n1   3.798459 29.44840 24.32633  14.00356 24.71990\n2  44.366891 51.37050 60.37091  87.46572 55.67057\n3 115.738810 79.35132 53.56630 102.76354 88.13996\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.365786e-34 1.440750e-13 0.0028836944 0.001095127 7.891037e-15\n2 2.012473e-18 6.289547e-10 0.0001332376 0.019131662 1.862073e-03\n3 6.414012e-10 1.084300e-06 0.0002095201 0.004627633 1.168286e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 1.116699e-34 1.961566e-13 0.0110254856 0.99631019 1.0000000\n2 4.279141e-18 1.923739e-09 0.0007128545 0.31271491 0.9865531\n3 3.661574e-09 8.139843e-06 0.0022705648 0.08609812 0.5428194\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                      1 \n\"GAMLSS PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Reference",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "href": "man/prodist.gamlss2.html#extracting-fitted-or-predicted-probability-distributions-from-gamlss2-models",
    "title": "gamlss2",
    "section": "",
    "text": "Methods for gamlss2 model objects for extracting fitted (in-sample) or predicted (out-of-sample) probability distributions as distributions3 objects.\n\n\n\n## S3 method for class 'gamlss2'\nprodist(object, ...)\n\n\n\n\n\n\n\nobject\n\n\nA model object of class gamlss2.\n\n\n\n\n…\n\n\nArguments passed on to predict.gamlss2, e.g., newdata.\n\n\n\n\n\n\nTo facilitate making probabilistic forecasts based on gamlss2 model objects, the prodist method extracts fitted or predicted probability distribution objects. Internally, the predict.gamlss2 method is used first to obtain the distribution parameters (mu, sigma, tau, nu, or a subset thereof). Subsequently, the corresponding distribution object is set up using the GAMLSS class from the gamlss.dist package, enabling the workflow provided by the distributions3 package (see Zeileis et al. 2022).\nNote that these probability distributions only reflect the random variation in the dependent variable based on the model employed (and its associated distributional assumption for the dependent variable). This does not capture the uncertainty in the parameter estimates.\n\n\n\nAn object of class GAMLSS inheriting from distribution.\n\n\n\nZeileis A, Lang MN, Hayes A (2022). “distributions3: From Basic Probability to Probabilistic Regression.” Presented at useR! 2022 - The R User Conference. Slides, video, vignette, code at https://www.zeileis.org/news/user2022/.\n\n\n\nGAMLSS, predict.gamlss2\n\n\n\n\nlibrary(\"gamlss2\")\n\n\n## packages, code, and data\nlibrary(\"distributions3\")\ndata(\"cars\", package = \"datasets\")\n\n## fit heteroscedastic normal GAMLSS model\n## stopping distance (ft) explained by speed (mph)\nm &lt;- gamlss2(dist ~ s(speed) | s(speed), data = cars, family = NO)\n\nGAMLSS-RS iteration  1: Global Deviance = 407.3541 eps = 0.125497     \nGAMLSS-RS iteration  2: Global Deviance = 405.7146 eps = 0.004024     \nGAMLSS-RS iteration  3: Global Deviance = 405.6978 eps = 0.000041     \nGAMLSS-RS iteration  4: Global Deviance = 405.6976 eps = 0.000000     \n\n## obtain predicted distributions for three levels of speed\nd &lt;- prodist(m, newdata = data.frame(speed = c(10, 20, 30)))\nprint(d)\n\n                                     1                                      2 \n\"GAMLSS NO(mu = 23.04, sigma = 10.06)\" \"GAMLSS NO(mu = 59.04, sigma = 18.51)\" \n                                     3 \n\"GAMLSS NO(mu = 96.35, sigma = 33.95)\" \n\n## obtain quantiles (works the same for any distribution object 'd' !)\nquantile(d, 0.5)\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = FALSE)\n\n     q_0.05    q_0.5    q_0.95\n1  6.486962 23.03912  39.59128\n2 28.589641 59.03607  89.48250\n3 40.504887 96.34896 152.19303\n\nquantile(d, c(0.05, 0.5, 0.95), elementwise = TRUE)\n\n         1          2          3 \n  6.486962  59.036073 152.193030 \n\n## visualization\nplot(dist ~ speed, data = cars)\nnd &lt;- data.frame(speed = 0:240/4)\nnd$dist &lt;- prodist(m, newdata = nd)\nnd$fit &lt;- quantile(nd$dist, c(0.05, 0.5, 0.95))\nmatplot(nd$speed, nd$fit, type = \"l\", lty = 1, col = \"slategray\", add = TRUE)\n\n\n\n\n\n\n\n## moments\nmean(d)\n\n       1        2        3 \n23.03912 59.03607 96.34896 \n\nvariance(d)\n\n        1         2         3 \n 101.2639  342.6244 1152.6558 \n\n## simulate random numbers\nrandom(d, 5)\n\n         r_1      r_2      r_3       r_4      r_5\n1   3.798459 29.44840 24.32633  14.00356 24.71990\n2  44.366891 51.37050 60.37091  87.46572 55.67057\n3 115.738810 79.35132 53.56630 102.76354 88.13996\n\n## density and distribution\npdf(d, 50 * -2:2)\n\n        d_-100        d_-50          d_0        d_50        d_100\n1 1.365786e-34 1.440750e-13 0.0028836944 0.001095127 7.891037e-15\n2 2.012473e-18 6.289547e-10 0.0001332376 0.019131662 1.862073e-03\n3 6.414012e-10 1.084300e-06 0.0002095201 0.004627633 1.168286e-02\n\ncdf(d, 50 * -2:2)\n\n        p_-100        p_-50          p_0       p_50     p_100\n1 1.116699e-34 1.961566e-13 0.0110254856 0.99631019 1.0000000\n2 4.279141e-18 1.923739e-09 0.0007128545 0.31271491 0.9865531\n3 3.661574e-09 8.139843e-06 0.0022705648 0.08609812 0.5428194\n\n## Poisson example\ndata(\"FIFA2018\", package = \"distributions3\")\nm2 &lt;- gamlss2(goals ~ s(difference), data = FIFA2018, family = PO)\n\nGAMLSS-RS iteration  1: Global Deviance = 355.3922 eps = 0.045332     \nGAMLSS-RS iteration  2: Global Deviance = 355.3922 eps = 0.000000     \n\nd2 &lt;- prodist(m2, newdata = data.frame(difference = 0))\nprint(d2)\n\n                      1 \n\"GAMLSS PO(mu = 1.237)\" \n\nquantile(d2, c(0.05, 0.5, 0.95))\n\n[1] 0 1 3\n\n## note that log_pdf() can replicate logLik() value\nsum(log_pdf(prodist(m2), FIFA2018$goals))\n\n[1] -177.6961\n\nlogLik(m2)\n\n'log Lik.' -177.6961 (df=2.005144)",
    "crumbs": [
      "Reference",
      "prodist.gamlss2"
    ]
  },
  {
    "objectID": "man/make.link2.html",
    "href": "man/make.link2.html",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr \"link-glm\"",
    "crumbs": [
      "Reference",
      "make.link2"
    ]
  },
  {
    "objectID": "man/make.link2.html#create-a-link-for-families",
    "href": "man/make.link2.html#create-a-link-for-families",
    "title": "gamlss2",
    "section": "",
    "text": "This function is used with the family functions in gamlss2(). Given the name of a link, it returns a link function, an inverse link function, the derivative \\(d\\mu/d\\eta\\), and a function for domain checking. Note that make.link2() is slightly more flexible and also allows functions as arguments.\n\n\n\nmake.link2(link)\n\n\n\n\n\n\n\nlink\n\n\nA character string, see function make.link, or function.\n\n\n\n\n\n\nA list containing the following components:\n\n\n\nlinkfun\n\n\nLink function function(mu).\n\n\n\n\nlinkinv\n\n\nInverse link function function(eta).\n\n\n\n\nmu.eta\n\n\nDerivative function(eta): \\(d\\mu/d\\eta\\).\n\n\n\n\nvalideta\n\n\nFunction function(eta) that returns TRUE if eta is in the domain of linkinv.\n\n\n\n\nname\n\n\nA character string representing the name of the link function.\n\n\n\n\n\n\nmake.link, gamlss2, gamlss2.family.\n\n\n\n\nlibrary(\"gamlss2\")\n\n## character specification\nutils::str(make.link2(\"logit\"))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"logit\"\n $ mu.eta2 :function (eta)  \n - attr(*, \"class\")= chr \"link-glm\"\n\n## functions\nutils::str(make.link2(softplus))\n\nList of 6\n $ linkfun :function (mu)  \n $ linkinv :function (eta)  \n $ mu.eta  :function (eta)  \n $ dmu.eta :function (eta)  \n $ valideta:function (eta)  \n $ name    : chr \"softplus(1)\"\n - attr(*, \"class\")= chr \"link-glm\"",
    "crumbs": [
      "Reference",
      "make.link2"
    ]
  }
]