---
title: "Suplement to Distribution Families in `gamlss2`"
subtitle: "A comparison to families in gamlss"
format: 
  html:
    html-math-method: mathjax
    toc: true
    number-sections: true
    pdf: default
editor: visual
author: The GAMLSS working party
bibliography: gamlss2.bib
---

## Introduction {#sec-Introduction}


The `gamlss2` distributions differ from the original `gamlss` family distributions, @Rigbyetal2019. The structure of the `gamlss.family` object, see @StasinopoulosRigby07, is different from `gamlss2.family`. The two families, contain the same amount of information about the distribution but in a different form. The main reason for the change is that the new `gamlss2.family` is more flexible and can be generalised easier to more that 4 parameters which was one of the restriction of the older implementation of GAMLSS in the `gamlss` package.

In this vignette we are trying to;

-   highlight the structure of a `gamlss2.family` object, @sec-Thestructureofgamlss2family;
-   show how to fit a `marginal`, @sec-fittingmarginal; and a `conditional` distribution for the response $y$, @sec-fittingConditional;
-   show how to transform an old `gamlss.family` objects into a new `gamlss2.family` objects, @sec-Tranformingtheold;
-   use a five parameters distribution,  @sec-Fittinga5parameterdistribution.

First we import the packages we are going to need later.

```{r}
#| warning: false
rm(list=ls())
library(gamlss)
library(gamlss2)
library(Formula)
library(gamlss.ggplots)
```

## The structure of `gamlss2.family` object {#sec-Thestructureofgamlss2family}

A `gamlss2.family` object is a list, called `fam`, with the following components:

-   `family`: the name of the family
-   `names`: the names of the parameters
-   `links`: the link function of the parameters
-   `scores`: the first derivatives of the loh likelihood
-   `hess`: the Hessian (second derivatives)
-   `loglik`: the log likelihood denote as $\ell$, the global deviance is $-2 \times \ell$
-   `mu`: the $\mu$ parameter of the distribution
-   `d`: the pdf
-   `p`: the cdf
-   `r`: random function
-   `q`: the quantile function (inverse cdf)
-   `initialise`: starting values
-   `mean` the mean (if exist)
-   `variance`: the variance (if exist)
-   `valid.response`: the range of the response.

### The Normal distribution as `gamlss2` family {#sec-Normaldistribution}

Here, as an example we show how the normal distribution can be defined as a `gamlss2.family`;

```{r}
Normal <- function(...) 
  { fam <- list( 
    "family" = "Normal", 
    "names" = c("mu", "sigma"), 
    "links" = c("mu" = "identity", "sigma" = "log"), 
    "score" = list( "mu" = function(y, par, ...) 
      { (y - par$mu) / (par$sigma^2) }, 
    "sigma" = function(y, par, ...) 
      { -1 + (y - par$mu)^2 / (par$sigma^2) 
      } ), 
    "hess" = list( 
    "mu" = function(y, par, ...) { 1 / (par$sigma^2)  },  
    "sigma" = function(y, par, ...) {  rep(2, length(y))  },  
    "mu.sigma" = function(y, par, ...) {  rep(0, length(y))  
      } ),  
    "loglik" = function(y, par, ...) 
      {sum(dnorm(y, par$mu, par$sigma, log = TRUE))  
      },  
     "mu" = function(par, ...) {  par$mu },
    "sigma" =  function(par, ...) {  par$sigma},
    "d" = function(y, par, log = FALSE) 
      { dnorm(y, mean = par$mu, sd = par$sigma, log = log) }, 
    "p" = function(y, par, ...) 
      { pnorm(y, mean = par$mu, sd = par$sigma, ...)},
    "r" = function(n, par)
      { rnorm(n, mean = par$mu, sd = par$sigma)}, 
    "q" = function(p, par) {qnorm(p, mean = par$mu, sd = par$sigma)},
    "initialize" = list( 
     "mu"    = function(y, ...) { (y + mean(y)) / 2 },
      "sigma" = function(y, ...) { rep(sd(y), length(y)) }),
      "mean"= function(par) par$mu, 
"variance"  = function(par) par$sigma^2, 
"valid.response" = function(x) 
  { if(is.factor(x) | is.character(x)) stop("the response should be numeric!")
    return(TRUE)})  
class(fam) <- "gamlss2.family" 
return(fam) 
}
```

`family` and `names` are defining the name of the distribution and the names of the parameters of the distribution, respectively.

`links` defines the defaul links functions for the parameters of the distribution. Link functions are basically defined the range of the parameters for example for the scale parameter $\sigma$ a `log` link ensures that the parameter is always positive. Note that the `link` functions change the interpretation of the model. For example an `identical` link implies an additive structure $b_1 x_1+\ldots+ b_p x_p$ while a `log` link is additive is in the predictor scale but has a multiplicative structure in the original parameter scale.

The objects `score`, `hess` and `logLik` defined the first and second derivative and the log-likelihood of the distribution, respectively. This information is used when fitting the model. Also useful in the fitting of the model is the information from `initialise` and `valid.response` which define how the initial values for the parameters are defined and the right range of the response $y$ .

The `d`, `p`, `q` and `r` function defined the pdf, cdf, inverse cdf (or q-function) and the randomised function of the distribution family.

The `mean` and `variance` define the mean the variance of the distribution (if exist). Note that the mean and variance (or possible other moments) maybe do not exist for a specific distribution. This occurs with distribution with heavy tails.

|  `Mikis commends`
| it needs to say here which of the options are compulsory and
| which are not. By undestanding is that
|  `family`, `names`, `links`, `d` and `p` are compulsory the rest not. Am I right?
| I am not clear when and why `rqres` is needed.

## Fitting a `marginal` distributiions {#sec-fittingmarginal}

What we mean by **marginal**, is situations, where we are interested to fit a theoretical distribution, $f(y|\theta)$, to a single vector $y$, without considering explanatory variables. We will use the term **conditional** distribution for $y$ where the x's are used to explain the parameters $\theta$, $f(y|\theta(X))$.

### The function `find_family()`

Here are are trying to find the "best" family for the variable $y$ among all relevant available families:

```{r}
#| cache: true
#| output: false
p <- find_family(rent$R, families=available_families("continuous"))
```

The option `available_families="continuous"` has been used to limited the available distributions to the `continuous` distributions. So the function `find_family` fits all continuous distributions and saves the GAIC in a vectors called `p`. The values of the vector can be printed in order;

```{r}
p[order(p)]
```

Note that similar results can be achieved in `gamlss` using the function `fidDist()`;

```{r}
#| cache: true
#| results: "hide" 
#| warning: false 
a <- gamlss:::fitDist(rent$R)
```

```{r}
a$fits
```

### The function `fit_family()`

The function `fit_family()` is similar to the older `gamlss` function `fitDist()`. It fits a marginal distribution to $y$ and then plots a histogram of $y$ together with the fitted distribution for $y$.

```{r}
fit_family(rent$R, family=BCTo)
```

Here is the output for the older `fitDist()` function;

```{r}
gamlss:::histDist(rent$R, family=BCTo, nbins=30)
```

## Fitting Conditional distributions {#sec-fittingConditional}

### Single conditional distributions

Here we use the \`Normal' family defined in @sec-Normaldistribution to fit a Normal distribution to a model defined by the formula below;

```{r}
## Model formula. 
f <- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = "ps") | 
         ti(Fl) + ti(A) + ti(Fl, A, bs = "ps") 
## Estimate model
 mNormal <- gamlss2(f, data = rent, family = Normal) 
```

The fitted smoothing terms can be displayed using;

```{r}
plot(mNormal)
```

and the residuals of the model using;

```{r}
resid_plots(mNormal)
```

We can improve the residual plots by fitting a more sophisticated distribution with 4 parameters.

```{r}
 mBCTo <- gamlss2(f, data = rent, family = BCTo) 
resid_plots(mBCTo)
```

### Fitting multiple conditional distributions

The function `chooseDist()` of the package `gamlss` can be used here.

```{r}
#| cache: true
T1 <- gamlss:::chooseDist(mNormal, type="realplus")
```

The function creates a table of GAIC's which be printed;

```{r}
library(knitr)
T1  |> kable(digits = c(2, 2, 3, 3 ))
 
```

Note that the function using the same formula `f <- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = "ps") | ti(Fl) + ti(A) + ti(Fl, A, bs = "ps")` to fit all distributional regression models. Also note that `f`, do not contain a model for parameters $\nu$ and $\tau$ and therefore constants are fitted for those two parameters when the distributions have more than 2 parameters.

## Tranforming the old `gamlss.family` to a `gamlss2.family` {#sec-Tranformingtheold}

Any old `gamlss.family` distribution can be transformed to a new `gamlss2` family using the function `tF()`. Below we use the function `tF()` to create a `gamlss2` family `nNO` distribution. Note that the function `gamlss2()` automatically is using `tF()` to translated any old `gamlss.famlily` to a new one in order to fit it.

`Mikis; how the link will be changed then?`

```{r}
nNO <- gamlss2:::tF(NO)
```

We can now fit a model using either new tranform distribution `nNO` or use the old `NO` distribution which automatically is transformed within `gamlss2()`;

```{r}

## Model formula. 
f <- R ~ ti(Fl) + ti(A) + ti(Fl, A, bs = "ps") | 
         ti(Fl) + ti(A) + ti(Fl, A, bs = "ps") 
## Estimate model
 mnNO <- gamlss2(f, data = rent, family = nNO) 
 mNO <- gamlss2(f, data = rent, family = NO) 
 AIC(mNormal, mnNO, mNO)
```

Similar fits, but note that from the residual diagnostic plots of the previous section we know that the normal distribution have not taken into the account the `skewness` of the response variable and therefore is inadequate.

Here we disply the names of the `nNO` `gamlss2.family`

```{r}
names(nNO)
```

to compare them with the names of the `gamlss.family`

```{r}
names(NO())
```

| gamlss        | gamlss2        | needed |
|---------------|:---------------|:-------|
| family        | family         | YES    |
| parameter     | names          | YES    |
| nopar         | NA             | NO     |
| type          | type           | ?      |
| mu.link       | links          | YES    |
| mu.linkfun.   | links          | YES    |
| sigma.link    | links          | YES    |
| sigma.linkfun | links          | YES    |
| \-            | map2par        | ?      |
| dldm          | score          | NO     |
| dldd          | score          | NO     |
| d2ldm2        | hess           | NO     |
| d2ldd2        | hess           | NO     |
| dd2ldmdd      | hess           | NO     |
| G.dev.incr    | logLik         | NO     |
| d             | d              | YES    |
| P             | p              | YES    |
| q             | q              | ?      |
| r             | r              | NO     |
| rqres         | rqres          | ?      |
| mu.initial    | initialize     | ?      |
| sigma.initial | initialize     | ?      |
| mu.valid      | ?              | ?      |
| sigma.valid   | ?              | ?      |
| y.valid       | valid.response | ?      |
| mean          | mean           | NO     |
| varriane      | variance       | NO     |

: Maping the differnt options for `gamlss.family` and `gamlss2.family` {#tbl-comparison .striped .hover}

|  `Mikis commends`
| We have to make sure we map this correctly

## Fitting a 5 parameter distribution {#sec-Fittinga5parameterdistribution}

Here we try to emphasise the advantage of using `gamlss2` compared with `gamlss` as far as distribution families are concerned. We will show that a five parameter distribution can be fitted with little effort. We use as an example the `skew generalised t` distribution.

The distribution has been introduce into **R** by the package `sgt` of @CarterDavis2015. The beauty of the distribution is that it contains a lot of other sub-distributions as special cases see for example @fig-SGT beloow taken from the vignette of the package `sgt`.

::: {#fig-SGT}
![The Skew Generalised T distributions and its sub-distributions (The figure is taken from the vignette of the R package sgt.](SGT.png){{width=1000}
:::

The *Skew Generalised T* distribution and its sub-distributions (The figure is taken from the vignette of the R package `sgt`.

Let us import the package `sgt`.

```{r}
#| warning: false
library("sgt")
```

Now using the `d`, `p`, and `q` function of the package `sgt` we create the function `SGT()` which is a `gamlss2.family` object. Note that the function we created bellow is sort off some of the element of the function `Normal` created in @sec-Normaldistribution. In particular the following ellements are not includedd

-   `score`
-   `hess`
-   `loglik`
-   `mean`
-   `variance`

```{r}
## Skewed Generalized T Distribution.
SGT <- function(...) {
  stopifnot(requireNamespace("sgt"))

  fam <- list(
    "names" = c("mu", "sigma", "lambda", "p", "q"),
    "links" = c("mu" = "identity", "sigma" = "log",
       "lambda" = "rhogit", "p" = "log", "q" = "log"),
    "d" = function(y, par, log = FALSE, ...) {
      sgt::dsgt(y, mu = par$mu, sigma = par$sigma, lambda = par$lambda,
        p = par$p, q = par$q, log = log)
    },
    "p" = function(y, par, lower.tail = TRUE, log.p = FALSE) {
      sgt::psgt(y, mu = par$mu, sigma = par$sigma,
        lambda = par$lambda, p = par$p, q = par$q,
        lower.tail = lower.tail, log.p = log.p)
    },
    "q" = function(p, par, lower.tail = TRUE, log.p = FALSE) {
      sgt::qsgt(p, mu = par$mu, sigma = par$sigma,
        lambda = par$lambda, p = par$p, q = par$q,
        lower.tail = lower.tail, log.p = log.p)
    }
  )

  class(fam) <- "gamlss2.family"

  return(fam)
}
```

```{r}
#| cache: true
#| warning: false
data("abdom", package = "gamlss.data")
## Specify the model Formula.
f <- y ~ s(x) | s(x) | s(x) | s(x) | s(x)
# SGT
# # ## Estimate model.
 msgt <- gamlss2(f, data = abdom, family = SGT,
                 maxit = c(100, 100), eps = 1e-07, trace=FALSE)
# # changing eps makes a difference  
# ## Plot estimated effects.
plot(msgt, which = "effects")
```
