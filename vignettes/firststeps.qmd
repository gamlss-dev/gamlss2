---
title: "First Steps"
format: 
  html:
    html-math-method: mathjax
    toc: true
    number-sections: true
bibliography: gamlss2.bib
nocite: |
  @Rigby+Stasinopoulos:2005
vignette: >
  %\VignetteIndexEntry{Overview}
  %\VignetteEngine{quarto::html}
  %\VignetteDepends{gamlss2}
  %\VignetteKeywords{distributional regression}
  %\VignettePackage{gamlss2}
---

The package is designed to follow the workflow of well-established model fitting functions
like `lm()` or `glm()`, i.e., the step of estimating full distributional regression models
is actually not very difficult.

We illustrate how `gamlss2` builds on the established `gamlss` framework by 
modeling daily maximum temperature (`Tmax`) at Munich Airport (MUC) to estimate
the probability of "heat days" (`Tmax` $\geq 30^\circ\text{C}$).
Heat days can have serious impacts by stressing highways and railways, increasing the
load on healthcare facilities, and affecting airport operations.
Using 30 years of historical `Tmax` data, we fit a flexible distributional
regression model that captures the full conditional distribution of daily temperatures. 
By evaluating this fitted distribution at the $30^\circ\text{C}$ threshold, we obtain
heat-day probabilities. Required packages can be loaded by

```{r}
#| echo: true
#| message: false
#| results: hide
if(!("gamlss" %in% installed.packages())) {
  install.packages("gamlss")
}
library("gamlss")
library("gamlss2")
```

The data comes from the same R-universe as `gamlss2` and is loaded with

```{r}
if(!("WeatherGermany" %in% installed.packages())) {
  install.packages('WeatherGermany',
    repos = c("https://gamlss-dev.r-universe.dev",
              "https://cloud.r-project.org"))
}
data("WeatherGermany", package = "WeatherGermany")
MUC <- subset(WeatherGermany, id == 1262)
```

We find that the four-parameter `SEP` family fits the marginal distribution of `Tmax`
quite well. To estimate a full distributional model, we specify the following additive predictor

$\eta = \beta_0 + f_1(\texttt{year}) + f_2(\texttt{yday}) + f_3(\texttt{year}, \texttt{yday})$

for each parameter. Here, $f_1( \cdot )$ captures the long-term trend, $f_2( \cdot )$ models
seasonal variation, and $f_3( \cdot, \cdot )$ represents a time-varying seasonal effect.
The required variables can be added to the data by

```{r}
MUC$year <- as.POSIXlt(MUC$date)$year + 1900
MUC$yday <- as.POSIXlt(MUC$date)$yday
```

In `gamlss`, model estimation is performed via

```{r, message=FALSE, results="hide"}
if(!("gamlss.add" %in% installed.packages())) {
  install.packages("gamlss.add",
    repos = c("https://gamlss-dev.r-universe.dev",
              "https://cloud.r-project.org"))
}
library("gamlss.add")
```
```{r}
f1 <- Tmax ~ ga(~ s(year) + s(yday, bs = "cc") +
  te(year, yday, bs = c("cr", "cc")))
b1 <- gamlss(f1, family = SEP,
  data = MUC[, c("Tmax", "year", "yday")])
```

This setup requires loading the `gamlss.add` package to access `mgcv`-based
smooth terms. Estimation takes 20 iterations of the backfitting algorithm (without full convergence) 
and about 44 seconds on a 64-bit Linux system. Moreover, `gamlss()` requires that the
input data contains no `NA` values. In `gamlss2` the model can be
specified directly, following `mgcv` syntax

```{r}
f2 <- Tmax ~ s(year) + s(yday, bs = "cc") +
  te(year, yday, bs = c("cr", "cc"))
b2 <- gamlss2(f2, family = SEP, data = MUC)
```

This model converges in 11 iterations and requires only about 2 seconds of computation time, 
yielding a similar deviance (small differences arise due to differences in smoothing
parameter optimization). In many applications, it is desirable to use the same predictor
structure for all distribution parameters. In `gamlss`, this requires specifying
identical formulas separately via `sigma.formula`, `nu.formula`, and
`tau.formula`, which can be tedious. In `gamlss2`, this is simplified using "`.`"

```{r}
f3 <- Tmax ~ s(year) + s(yday, bs = "cc") +
  te(year, yday, bs = c("cr", "cc")) | . | . | .
b3 <- gamlss2(f3, family = SEP, data = MUC)
```

This model converges in 20 iterations in about 30 seconds. After estimation, results can be
inspected using the `summary()` method for both packages. Using `plot()` in
`gamlss` produces standard residual diagnostic plots, whereas in `gamlss2`

```{r}
#| fig-height: 10
#| fig-width: 8
#| fig-align: center
#| out-width: 80%

plot(b3)
```

displays all estimated covariate effects. For residual diagnostics, `gamlss2` leverages
the `topmodels` package, which provides infrastructures for probabilistic model assessment.
E.g., a PIT histogram can be created by

```{r}
#| message: false
#| results: hide
#| fig-height: 5
#| fig-width: 5
#| fig-align: center
if(!("topmodels" %in% installed.packages())) {
  install.packages("topmodels", repos = "https://zeileis.R-universe.dev")
}
library("topmodels")

pithist(b3)
```

showing good model calibration. Finally, we compute the probability of a heat day for 2025.
First, the `procast()` function from `topmodels predicts the fitted distributions

```{r}
nd <- data.frame("year" = 2025, "yday" = 0:365)
pf <- procast(b3, newdata = nd, drop = TRUE)
```

This yields a distribution vector `pf` using the infrastructure from the
`distributions3` package. Probabilities of a heat day can then be calculated
with the corresponding `cdf()` method.

```{r cdf, message=FALSE, results="hide"}
if(!("distributions3" %in% installed.packages())) {
  install.packages("distributions3")
}
library("distributions3")
probs <- 1 - cdf(pf, 30)
```

and visualized, for example, by

```{r}
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
par(mar = c(4, 4, 1, 1))
plot(probs, type = "l", xlab = "Day of Year",
  ylab = "Prob(Tmax > 30)")
```

Note that a `predict()` method is available for both `gamlss` and `gamlss2`,
allowing direct prediction of distribution parameters. However, in `gamlss`,
`predict()` may not fully support new data in all cases.

